<html><head>
<title>EZRadioPRO SPI API</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">
<style type="text/css">    body { padding: 10px; font-size: 14; }    h1, h2, h3 { padding-top: 20px; }    h4 { padding-top: 10px; }    p { font-size: 14; }     code { font-size: 14; color: black }     table { min-width: 50%; border: 1px solid black; border-spacing: 1px; text-align: center; font-size: 14; }    td { border: 1px solid black; border-spacing: 0px; padding-left: 3px; padding-right: 3px; }    thead { text-align: center; background: #bbd5f0; }    dl { width: 100%; margin-top: 0; margin-bottom: 0; overflow: hidden; }    dt { width: 10%; float: left; text-aling: right }     dd { width: 90%; float: left; }     ul { margin-top: 0; margin-bottom: 0; }     </style>
</head>
<body>
<h1>EZRadioPRO SPI API</h1>
<h2>Command Summary</h2>
<table>
<thead><tr><th colspan="3"><a href="#cset-BOOT_COMMANDS">BOOT_COMMANDS</a></th></tr>
<tr><td>Number</td><td>Name</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td align="left"><a href="#cmd-POWER_UP"><code>POWER_UP</code></a></td>
<td align="left">Command to power-up the device and select the operational mode and functionality.</td></tr>
<tr><td>0x03</td>
<td align="left"><a href="#cmd-RAM_TEST"><code>RAM_TEST</code></a></td>
<td align="left">Tests the contents and operation of RAM.</td></tr>
<tr><td>0x04</td>
<td align="left"><a href="#cmd-PATCH_IMAGE"><code>PATCH_IMAGE</code></a></td>
<td align="left">Loads image from NVM/ROM into RAM.</td></tr>
<tr><td>0x05</td>
<td align="left"><a href="#cmd-PATCH_ARGS"><code>PATCH_ARGS</code></a></td>
<td align="left">*ENCRYPTED* Reserved command used for patch file downloads.</td></tr>
<tr><td>0x06</td>
<td align="left"><a href="#cmd-PATCH_COPY"><code>PATCH_COPY</code></a></td>
<td align="left">*ENCRYPTED* Reserved command used for patch file downloads.</td></tr>
<tr><td>0x09</td>
<td align="left"><a href="#cmd-TEST_DATA"><code>TEST_DATA</code></a></td>
<td align="left">Read NVM Test Data block.</td></tr>
<tr><td>0x0a</td>
<td align="left"><a href="#cmd-PATCH_COPY_2"><code>PATCH_COPY_2</code></a></td>
<td align="left">*ENCRYPTED* Reserved command used for patch file downloads.</td></tr>
<tr><td>0xe0</td>
<td align="left"><a href="#cmd-PATCH_DATA"><code>PATCH_DATA</code></a></td>
<td align="left">*ENCRYPTED* Reserved command used for patch file downloads.</td></tr>
</tbody>
<thead><tr><th colspan="3"><a href="#cset-COMMON_COMMANDS">COMMON_COMMANDS</a></th></tr>
<tr><td>Number</td><td>Name</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td align="left"><a href="#cmd-NOP"><code>NOP</code></a></td>
<td align="left">No Operation command.</td></tr>
<tr><td>0x01</td>
<td align="left"><a href="#cmd-PART_INFO"><code>PART_INFO</code></a></td>
<td align="left">Reports basic information about the device.</td></tr>
<tr><td>0x10</td>
<td align="left"><a href="#cmd-FUNC_INFO"><code>FUNC_INFO</code></a></td>
<td align="left">Returns the Function revision information of the device.</td></tr>
<tr><td>0x11</td>
<td align="left"><a href="#cmd-SET_PROPERTY"><code>SET_PROPERTY</code></a></td>
<td align="left">Sets the value of one or more properties.</td></tr>
<tr><td>0x12</td>
<td align="left"><a href="#cmd-GET_PROPERTY"><code>GET_PROPERTY</code></a></td>
<td align="left">Retrieves the value of one or more properties</td></tr>
<tr><td>0x13</td>
<td align="left"><a href="#cmd-GPIO_PIN_CFG"><code>GPIO_PIN_CFG</code></a></td>
<td align="left">Configures the GPIO pins.</td></tr>
<tr><td>0x15</td>
<td align="left"><a href="#cmd-FIFO_INFO"><code>FIFO_INFO</code></a></td>
<td align="left">Access the current byte counts in the TX and RX FIFOs, and provide for resetting the FIFOs.</td></tr>
<tr><td>0x1b</td>
<td align="left"><a href="#cmd-WAIT_PROPERTY_PROCESSED"><code>WAIT_PROPERTY_PROCESSED</code></a></td>
<td align="left">Holds CTS low until all property writes are processed.</td></tr>
<tr><td>0x20</td>
<td align="left"><a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a></td>
<td align="left">Returns the interrupt status of ALL the possible interrupt events (both STATUS and PENDING).  Optionally, it may be used to clear latched (PENDING) interrupt events.</td></tr>
<tr><td>0x33</td>
<td align="left"><a href="#cmd-REQUEST_DEVICE_STATE"><code>REQUEST_DEVICE_STATE</code></a></td>
<td align="left">Request current device state and channel.</td></tr>
<tr><td>0x34</td>
<td align="left"><a href="#cmd-CHANGE_STATE"><code>CHANGE_STATE</code></a></td>
<td align="left">Manually switch the chip to a desired operating state.</td></tr>
<tr><td>0x38</td>
<td align="left"><a href="#cmd-OFFLINE_RECAL"><code>OFFLINE_RECAL</code></a></td>
<td align="left">Switches to high temp or low temp settings and recalibrate blocks.</td></tr>
<tr><td>0x44</td>
<td align="left"><a href="#cmd-READ_CMD_BUFF"><code>READ_CMD_BUFF</code></a></td>
<td align="left">Used to read CTS and the command response.</td></tr>
<tr><td>0x50</td>
<td align="left"><a href="#cmd-FRR_A_READ"><code>FRR_A_READ</code></a></td>
<td align="left">Reads the fast response registers (FRR) starting with FRR_A.</td></tr>
<tr><td>0x51</td>
<td align="left"><a href="#cmd-FRR_B_READ"><code>FRR_B_READ</code></a></td>
<td align="left">Reads the fast response registers (FRR) starting with FRR_B.</td></tr>
<tr><td>0x53</td>
<td align="left"><a href="#cmd-FRR_C_READ"><code>FRR_C_READ</code></a></td>
<td align="left">Reads the fast response registers (FRR) starting with FRR_C.</td></tr>
<tr><td>0x57</td>
<td align="left"><a href="#cmd-FRR_D_READ"><code>FRR_D_READ</code></a></td>
<td align="left">Reads the fast response registers (FRR) starting with FRR_D.</td></tr>
<tr><td>0xd0</td>
<td align="left"><a href="#cmd-AGC_OVERRIDE"><code>AGC_OVERRIDE</code></a></td>
<td align="left">Override the AGC and manually control the gain of the RX chain.</td></tr>
</tbody>
<thead><tr><th colspan="3"><a href="#cset-IR_CAL_COMMANDS">IR_CAL_COMMANDS</a></th></tr>
<tr><td>Number</td><td>Name</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x17</td>
<td align="left"><a href="#cmd-IRCAL"><code>IRCAL</code></a></td>
<td align="left">Image rejection calibration.</td></tr>
<tr><td>0x1a</td>
<td align="left"><a href="#cmd-IRCAL_MANUAL"><code>IRCAL_MANUAL</code></a></td>
<td align="left">Image rejection calibration.</td></tr>
</tbody>
<thead><tr><th colspan="3"><a href="#cset-TX_COMMANDS">TX_COMMANDS</a></th></tr>
<tr><td>Number</td><td>Name</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x31</td>
<td align="left"><a href="#cmd-START_TX"><code>START_TX</code></a></td>
<td align="left">Switches to TX state and starts transmission of a packet.</td></tr>
<tr><td>0x37</td>
<td align="left"><a href="#cmd-TX_HOP"><code>TX_HOP</code></a></td>
<td align="left">Hop to a new frequency while in TX.</td></tr>
<tr><td>0x66</td>
<td align="left"><a href="#cmd-WRITE_TX_FIFO"><code>WRITE_TX_FIFO</code></a></td>
<td align="left">Writes data byte(s) to the TX FIFO.</td></tr>
</tbody>
<thead><tr><th colspan="3"><a href="#cset-RX_COMMANDS">RX_COMMANDS</a></th></tr>
<tr><td>Number</td><td>Name</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x16</td>
<td align="left"><a href="#cmd-PACKET_INFO"><code>PACKET_INFO</code></a></td>
<td align="left">Returns information about the length of the variable field in the last packet received, and (optionally) overrides field length. </td></tr>
<tr><td>0x22</td>
<td align="left"><a href="#cmd-GET_MODEM_STATUS"><code>GET_MODEM_STATUS</code></a></td>
<td align="left">Returns the interrupt status of the Modem Interrupt Group (both STATUS and PENDING).  Optionally, it may be used to clear latched (PENDING) interrupt events.</td></tr>
<tr><td>0x32</td>
<td align="left"><a href="#cmd-START_RX"><code>START_RX</code></a></td>
<td align="left">Switches to RX state and starts reception of a packet.</td></tr>
<tr><td>0x36</td>
<td align="left"><a href="#cmd-RX_HOP"><code>RX_HOP</code></a></td>
<td align="left">Manually hop to a new frequency while in RX mode. </td></tr>
<tr><td>0x77</td>
<td align="left"><a href="#cmd-READ_RX_FIFO"><code>READ_RX_FIFO</code></a></td>
<td align="left">Reads data byte(s) from the RX FIFO.</td></tr>
</tbody>
<thead><tr><th colspan="3"><a href="#cset-ADVANCED_COMMANDS">ADVANCED_COMMANDS</a></th></tr>
<tr><td>Number</td><td>Name</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x14</td>
<td align="left"><a href="#cmd-GET_ADC_READING"><code>GET_ADC_READING</code></a></td>
<td align="left">Performs conversions using the Auxiliary ADC and returns the results of those conversions.</td></tr>
<tr><td>0x18</td>
<td align="left"><a href="#cmd-PROTOCOL_CFG"><code>PROTOCOL_CFG</code></a></td>
<td align="left">Sets the chip up for specified protocol.</td></tr>
<tr><td>0x21</td>
<td align="left"><a href="#cmd-GET_PH_STATUS"><code>GET_PH_STATUS</code></a></td>
<td align="left">Returns the interrupt status of the Packet Handler Interrupt Group (both STATUS and PENDING).  Optionally, it may be used to clear latched (PENDING) interrupt events.</td></tr>
<tr><td>0x23</td>
<td align="left"><a href="#cmd-GET_CHIP_STATUS"><code>GET_CHIP_STATUS</code></a></td>
<td align="left">Returns the interrupt status of the Chip Interrupt Group (both STATUS and PENDING).  Optionally, it may be used to clear latched (PENDING) interrupt events.</td></tr>
</tbody>
<thead><tr><th colspan="3"><a href="#cset-IE154_COMMANDS">IE154_COMMANDS</a></th></tr>
<tr><td>Number</td><td>Name</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x80</td>
<td align="left"><a href="#cmd-IE154_START_TX"><code>IE154_START_TX</code></a></td>
<td align="left">INTERNAL STATUS: Implemented. Transitions to complete and fail states not fully tested
                           Needs argument (cca backoff time) clean-up
                        Starts transmission using 802.15.4 parameters</td></tr>
<tr><td>0x81</td>
<td align="left"><a href="#cmd-IE154_START_RX"><code>IE154_START_RX</code></a></td>
<td align="left">INTERNAL STATUS: Implemented. Need to test transitions to "rx_complete" modes
                        Starts reception using 802.15.4 parameters</td></tr>
<tr><td>0x82</td>
<td align="left"><a href="#cmd-IE154_GET_INT_STATUS"><code>IE154_GET_INT_STATUS</code></a></td>
<td align="left">INTERNAL STATUS: Implemented and tested
Obtains the status of the all operations </td></tr>
<tr><td>0x83</td>
<td align="left"><a href="#cmd-IE154_GET_TX_STATUS"><code>IE154_GET_TX_STATUS</code></a></td>
<td align="left">INTERNAL STATUS: Implemented, not fully tested"
Obtains the status of the last Tx operation </td></tr>
<tr><td>0x84</td>
<td align="left"><a href="#cmd-IE154_GET_RX_STATUS"><code>IE154_GET_RX_STATUS</code></a></td>
<td align="left">INTERNAL STATUS: Implemented, not fully testedObtains the status of the last Rx operation </td></tr>
<tr><td>0x85</td>
<td align="left"><a href="#cmd-IE154_OVERRIDE_NEXT_ACK"><code>IE154_OVERRIDE_NEXT_ACK</code></a></td>
<td align="left">Used to temporarily modify the behavior for the next ack sent</td></tr>
<tr><td>0x86</td>
<td align="left"><a href="#cmd-IE154_GET_MAC_TIMER"><code>IE154_GET_MAC_TIMER</code></a></td>
<td align="left">INTERNAL STATUS: Not implemented
Obtains the 24 bit MAC timer value from the radio</td></tr>
<tr><td>0x87</td>
<td align="left"><a href="#cmd-IE154_START_ENERGY_DETECT"><code>IE154_START_ENERGY_DETECT</code></a></td>
<td align="left">Starts energy detect mode. Energy level is placed in FRR_LATCHED_RSSI</td></tr>
<tr><td>0x89</td>
<td align="left"><a href="#cmd-IE154_IS_CHANNEL_CLEAR"><code>IE154_IS_CHANNEL_CLEAR</code></a></td>
<td align="left">INTERNAL STATUS: Not implemented
Returns the clear or busy status of the channel</td></tr>
<tr><td>0x8a</td>
<td align="left"><a href="#cmd-IE154_QUERY_MODE"><code>IE154_QUERY_MODE</code></a></td>
<td align="left">Returns the current mode and phase of operation </td></tr>
<tr><td>0x8c</td>
<td align="left"><a href="#cmd-IE154_START_IDLE"><code>IE154_START_IDLE</code></a></td>
<td align="left">INTERNAL STATUS: Implemented and tested.
                        Transitions radio to IDLE mode</td></tr>
<tr><td>0x8d</td>
<td align="left"><a href="#cmd-IE154_START_SLEEP"><code>IE154_START_SLEEP</code></a></td>
<td align="left">INTERNAL STATUS: Implemented and tested.
                        Transitions radio to SLEEP mode</td></tr>
</tbody>
<thead><tr><th colspan="3"><a href="#cset-DEBUG_COMMANDS">DEBUG_COMMANDS</a></th></tr>
<tr><td>Number</td><td>Name</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0xf0</td>
<td align="left"><a href="#cmd-PEEK"><code>PEEK</code></a></td>
<td align="left">Read a memory location in the device (if the feature is enabled).</td></tr>
<tr><td>0xf1</td>
<td align="left"><a href="#cmd-POKE"><code>POKE</code></a></td>
<td align="left">Write a memory location in the device (if the feature is enabled).</td></tr>
<tr><td>0xf2</td>
<td align="left"><a href="#cmd-SRAND"><code>SRAND</code></a></td>
<td align="left">Set the seed for the random number generator.</td></tr>
<tr><td>0xfe</td>
<td align="left"><a href="#cmd-DIE_INFO"><code>DIE_INFO</code></a></td>
<td align="left">Reports basic information about the die.</td></tr>
</tbody>
<thead><tr><th colspan="3"><a href="#cset-EZCONFIG_COMMANDS">EZCONFIG_COMMANDS</a></th></tr>
<tr><td>Number</td><td>Name</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x19</td>
<td align="left"><a href="#cmd-EZCONFIG_CHECK"><code>EZCONFIG_CHECK</code></a></td>
<td align="left">Validates the EZConfig array was written correctly.</td></tr>
<tr><td>0x66</td>
<td align="left"><a href="#cmd-EZCONFIG_ARRAY_WRITE"><code>EZCONFIG_ARRAY_WRITE</code></a></td>
<td align="left">Writes data byte(s) to the EZConfig array.</td></tr>
</tbody>
<thead><tr><th colspan="3"><a href="#cset-MFSK_COMMANDS">MFSK_COMMANDS</a></th></tr>
<tr><td>Number</td><td>Name</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x35</td>
<td align="left"><a href="#cmd-START_MFSK"><code>START_MFSK</code></a></td>
<td align="left">Start direct frequency offset transmission mode.</td></tr>
</tbody>
</table>
<hr />
<h2>Property Summary</h2>
<table>
<thead><tr><th colspan="5"><a href="#pgrp-GLOBAL">GLOBAL</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0x00
</td>
<td align="left"><a href="#prop-GLOBAL_XO_TUNE">GLOBAL_XO_TUNE</a></td>
<td>0x40
<td align="left">Configure the internal capacitor frequency tuning bank for the crystal oscillator.</td></tr>
<tr><td>0x00</td>
<td>0x01
</td>
<td align="left"><a href="#prop-GLOBAL_CLK_CFG">GLOBAL_CLK_CFG</a></td>
<td>0x00
<td align="left">Clock configuration options.</td></tr>
<tr><td>0x00</td>
<td>0x02
</td>
<td align="left"><a href="#prop-GLOBAL_LOW_BATT_THRESH">GLOBAL_LOW_BATT_THRESH</a></td>
<td>0x18
<td align="left">Configures the threshold voltage for low-battery detection.</td></tr>
<tr><td>0x00</td>
<td>0x03
</td>
<td align="left"><a href="#prop-GLOBAL_CONFIG">GLOBAL_CONFIG</a></td>
<td>0x20
<td align="left">Global configuration settings.</td></tr>
<tr><td>0x00</td>
<td>0x04
</td>
<td align="left"><a href="#prop-GLOBAL_WUT_CONFIG">GLOBAL_WUT_CONFIG</a></td>
<td>0x00
<td align="left">General Wakeup Timer feature configuration.</td></tr>
<tr><td>0x00</td>
<td>0x05
<br/>0x06
</td>
<td align="left"><a href="#prop-GLOBAL_WUT_M">GLOBAL_WUT_M</a></td>
<td>0x00
<br/>0x01
<td align="left">Configure the mantissa of the Wake-Up Timer (WUT) value. </td></tr>
<tr><td>0x00</td>
<td>0x07
</td>
<td align="left"><a href="#prop-GLOBAL_WUT_R">GLOBAL_WUT_R</a></td>
<td>0x60
<td align="left">Configure the exponent of the Wake-Up Timer (WUT) value.</td></tr>
<tr><td>0x00</td>
<td>0x08
</td>
<td align="left"><a href="#prop-GLOBAL_WUT_LDC">GLOBAL_WUT_LDC</a></td>
<td>0x00
<td align="left">Configures the period of time the chip remains active after automatic wake-up in LDC mode. </td></tr>
<tr><td>0x00</td>
<td>0x09
</td>
<td align="left"><a href="#prop-GLOBAL_WUT_CAL">GLOBAL_WUT_CAL</a></td>
<td>0x00
<td align="left">Controls if calibration of the 32K R-C Oscillator will be performed on intervals of the WUT.</td></tr>
<tr><td>0x00</td>
<td>0x0a
</td>
<td align="left"><a href="#prop-GLOBAL_BUFCLK_CFG">GLOBAL_BUFCLK_CFG</a></td>
<td>0x00
<td align="left">Buffered clock configuration options.</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-INT_CTL">INT_CTL</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td>0x00
</td>
<td align="left"><a href="#prop-INT_CTL_ENABLE">INT_CTL_ENABLE</a></td>
<td>0x04
<td align="left">This property provides for global enabling of the three interrupt groups (Chip, Modem and Packet Handler) in order to generate HW interrupts at the NIRQ pin.</td></tr>
<tr><td>0x01</td>
<td>0x01
</td>
<td align="left"><a href="#prop-INT_CTL_PH_ENABLE">INT_CTL_PH_ENABLE</a></td>
<td>0x00
<td align="left">Enable individual interrupt sources within the Packet Handler Interrupt Group to generate a HW interrupt on the NIRQ output pin.</td></tr>
<tr><td>0x01</td>
<td>0x02
</td>
<td align="left"><a href="#prop-INT_CTL_MODEM_ENABLE">INT_CTL_MODEM_ENABLE</a></td>
<td>0x00
<td align="left">Enable individual interrupt sources within the Modem Interrupt Group to generate a HW interrupt on the NIRQ output pin.</td></tr>
<tr><td>0x01</td>
<td>0x03
</td>
<td align="left"><a href="#prop-INT_CTL_CHIP_ENABLE">INT_CTL_CHIP_ENABLE</a></td>
<td>0x04
<td align="left">Enable individual interrupt sources within the Chip Interrupt Group to generate a HW interrupt on the NIRQ output pin.</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-FRR_CTL">FRR_CTL</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td>0x00
</td>
<td align="left"><a href="#prop-FRR_CTL_A_MODE">FRR_CTL_A_MODE</a></td>
<td>0x01
<td align="left">Fast Response Register A Configuration.</td></tr>
<tr><td>0x02</td>
<td>0x01
</td>
<td align="left"><a href="#prop-FRR_CTL_B_MODE">FRR_CTL_B_MODE</a></td>
<td>0x02
<td align="left">Fast Response Register B Configuration.</td></tr>
<tr><td>0x02</td>
<td>0x02
</td>
<td align="left"><a href="#prop-FRR_CTL_C_MODE">FRR_CTL_C_MODE</a></td>
<td>0x09
<td align="left">Fast Response Register C Configuration.</td></tr>
<tr><td>0x02</td>
<td>0x03
</td>
<td align="left"><a href="#prop-FRR_CTL_D_MODE">FRR_CTL_D_MODE</a></td>
<td>0x00
<td align="left">Fast Response Register D Configuration.</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-PREAMBLE">PREAMBLE</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x10</td>
<td>0x00
</td>
<td align="left"><a href="#prop-PREAMBLE_TX_LENGTH">PREAMBLE_TX_LENGTH</a></td>
<td>0x08
<td align="left">Configure length of TX Preamble.</td></tr>
<tr><td>0x10</td>
<td>0x01
</td>
<td align="left"><a href="#prop-PREAMBLE_CONFIG_STD_1">PREAMBLE_CONFIG_STD_1</a></td>
<td>0x14
<td align="left">Configuration of reception of a packet with a Standard Preamble pattern.</td></tr>
<tr><td>0x10</td>
<td>0x02
</td>
<td align="left"><a href="#prop-PREAMBLE_CONFIG_NSTD">PREAMBLE_CONFIG_NSTD</a></td>
<td>0x00
<td align="left">Configuration of transmission/reception of a packet with a Non-Standard Preamble pattern.</td></tr>
<tr><td>0x10</td>
<td>0x03
</td>
<td align="left"><a href="#prop-PREAMBLE_CONFIG_STD_2">PREAMBLE_CONFIG_STD_2</a></td>
<td>0x0f
<td align="left">Configuration of timeout periods during reception of a packet with Standard Preamble pattern.</td></tr>
<tr><td>0x10</td>
<td>0x04
</td>
<td align="left"><a href="#prop-PREAMBLE_CONFIG">PREAMBLE_CONFIG</a></td>
<td>0x21
<td align="left">General configuration bits for the Preamble field.</td></tr>
<tr><td>0x10</td>
<td>0x05
<br/>0x06
<br/>0x07
<br/>0x08
</td>
<td align="left"><a href="#prop-PREAMBLE_PATTERN">PREAMBLE_PATTERN</a></td>
<td>0x00
<br/>0x00
<br/>0x00
<br/>0x00
<td align="left">Configuration of the bit values describing a Non-Standard Preamble pattern.</td></tr>
<tr><td>0x10</td>
<td>0x09
</td>
<td align="left"><a href="#prop-PREAMBLE_POSTAMBLE_CONFIG">PREAMBLE_POSTAMBLE_CONFIG</a></td>
<td>0x00
<td align="left">Configuration of Postamble functionality and the Postamble pattern bits.</td></tr>
<tr><td>0x10</td>
<td>0x0a
<br/>0x0b
<br/>0x0c
<br/>0x0d
</td>
<td align="left"><a href="#prop-PREAMBLE_POSTAMBLE_PATTERN">PREAMBLE_POSTAMBLE_PATTERN</a></td>
<td>0x00
<br/>0x00
<br/>0x00
<br/>0x00
<td align="left">Defines the Postamble pattern.</td></tr>
<tr><td>0x10</td>
<td>0x0e
</td>
<td align="left"><a href="#prop-PREAMBLE_RESERVED_10_0E">PREAMBLE_RESERVED_10_0E</a></td>
<td>0x00
<td align="left"></td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-SYNC">SYNC</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x11</td>
<td>0x00
</td>
<td align="left"><a href="#prop-SYNC_CONFIG">SYNC_CONFIG</a></td>
<td>0x01
<td align="left">Sync Word configuration bits.</td></tr>
<tr><td>0x11</td>
<td>0x01
<br/>0x02
<br/>0x03
<br/>0x04
</td>
<td align="left"><a href="#prop-SYNC_BITS">SYNC_BITS</a></td>
<td>0x2d
<br/>0xd4
<br/>0x2d
<br/>0xd4
<td align="left">Sync word.</td></tr>
<tr><td>0x11</td>
<td>0x05
</td>
<td align="left"><a href="#prop-SYNC_CONFIG2">SYNC_CONFIG2</a></td>
<td>0x00
<td align="left">Sync Word configuration bits.</td></tr>
<tr><td>0x11</td>
<td>0x06
<br/>0x07
<br/>0x08
<br/>0x09
</td>
<td align="left"><a href="#prop-SYNC_BITS2">SYNC_BITS2</a></td>
<td>0x2d
<br/>0xd4
<br/>0x2d
<br/>0xd4
<td align="left">Sync word 2.</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-PKT">PKT</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x12</td>
<td>0x00
</td>
<td align="left"><a href="#prop-PKT_CRC_CONFIG">PKT_CRC_CONFIG</a></td>
<td>0x00
<td align="left">Select a CRC polynomial and seed.</td></tr>
<tr><td>0x12</td>
<td>0x01
<br/>0x02
</td>
<td align="left"><a href="#prop-PKT_WHT_POLY">PKT_WHT_POLY</a></td>
<td>0x01
<br/>0x08
<td align="left">16-bit polynomial value for the PN Generator (e.g., for Data Whitening)</td></tr>
<tr><td>0x12</td>
<td>0x03
<br/>0x04
</td>
<td align="left"><a href="#prop-PKT_WHT_SEED">PKT_WHT_SEED</a></td>
<td>0xff
<br/>0xff
<td align="left">16-bit seed value for the PN Generator (e.g., for Data Whitening)</td></tr>
<tr><td>0x12</td>
<td>0x05
</td>
<td align="left"><a href="#prop-PKT_WHT_BIT_NUM">PKT_WHT_BIT_NUM</a></td>
<td>0x00
<td align="left">Selects which bit of the LFSR (used to generate the PN / data whitening sequence) is used as the output bit for data scrambling.</td></tr>
<tr><td>0x12</td>
<td>0x06
</td>
<td align="left"><a href="#prop-PKT_CONFIG1">PKT_CONFIG1</a></td>
<td>0x00
<td align="left">General configuration bits for transmission or reception of a packet.</td></tr>
<tr><td>0x12</td>
<td>0x07
</td>
<td align="left"><a href="#prop-PKT_CONFIG2">PKT_CONFIG2</a></td>
<td>0x00
<td align="left">General packet configuration bits.</td></tr>
<tr><td>0x12</td>
<td>0x08
</td>
<td align="left"><a href="#prop-PKT_LEN">PKT_LEN</a></td>
<td>0x00
<td align="left">Configuration bits for reception of a variable length packet.</td></tr>
<tr><td>0x12</td>
<td>0x09
</td>
<td align="left"><a href="#prop-PKT_LEN_FIELD_SOURCE">PKT_LEN_FIELD_SOURCE</a></td>
<td>0x00
<td align="left">Field number containing the received packet length byte(s).</td></tr>
<tr><td>0x12</td>
<td>0x0a
</td>
<td align="left"><a href="#prop-PKT_LEN_ADJUST">PKT_LEN_ADJUST</a></td>
<td>0x00
<td align="left">Provides for adjustment/offset of the received packet length value (in order to accommodate a variety of methods of defining total packet length).</td></tr>
<tr><td>0x12</td>
<td>0x0b
</td>
<td align="left"><a href="#prop-PKT_TX_THRESHOLD">PKT_TX_THRESHOLD</a></td>
<td>0x30
<td align="left">TX FIFO almost empty threshold.</td></tr>
<tr><td>0x12</td>
<td>0x0c
</td>
<td align="left"><a href="#prop-PKT_RX_THRESHOLD">PKT_RX_THRESHOLD</a></td>
<td>0x30
<td align="left">RX FIFO Almost Full threshold.</td></tr>
<tr><td>0x12</td>
<td>0x0d
<br/>0x0e
</td>
<td align="left"><a href="#prop-PKT_FIELD_1_LENGTH">PKT_FIELD_1_LENGTH</a></td>
<td>0x00
<br/>0x00
<td align="left">Unsigned 13-bit Field 1 length value.</td></tr>
<tr><td>0x12</td>
<td>0x0f
</td>
<td align="left"><a href="#prop-PKT_FIELD_1_CONFIG">PKT_FIELD_1_CONFIG</a></td>
<td>0x00
<td align="left">General data processing and packet configuration bits for Field 1.</td></tr>
<tr><td>0x12</td>
<td>0x10
</td>
<td align="left"><a href="#prop-PKT_FIELD_1_CRC_CONFIG">PKT_FIELD_1_CRC_CONFIG</a></td>
<td>0x00
<td align="left">Configuration of CRC control bits across Field 1.</td></tr>
<tr><td>0x12</td>
<td>0x11
<br/>0x12
</td>
<td align="left"><a href="#prop-PKT_FIELD_2_LENGTH">PKT_FIELD_2_LENGTH</a></td>
<td>0x00
<br/>0x00
<td align="left">Unsigned 13-bit Field 2 length value.</td></tr>
<tr><td>0x12</td>
<td>0x13
</td>
<td align="left"><a href="#prop-PKT_FIELD_2_CONFIG">PKT_FIELD_2_CONFIG</a></td>
<td>0x00
<td align="left">General data processing and packet configuration bits for Field 2.</td></tr>
<tr><td>0x12</td>
<td>0x14
</td>
<td align="left"><a href="#prop-PKT_FIELD_2_CRC_CONFIG">PKT_FIELD_2_CRC_CONFIG</a></td>
<td>0x00
<td align="left">Configuration of CRC control bits across Field 2.</td></tr>
<tr><td>0x12</td>
<td>0x15
<br/>0x16
</td>
<td align="left"><a href="#prop-PKT_FIELD_3_LENGTH">PKT_FIELD_3_LENGTH</a></td>
<td>0x00
<br/>0x00
<td align="left">Unsigned 13-bit Field 3 length value.</td></tr>
<tr><td>0x12</td>
<td>0x17
</td>
<td align="left"><a href="#prop-PKT_FIELD_3_CONFIG">PKT_FIELD_3_CONFIG</a></td>
<td>0x00
<td align="left">General data processing and packet configuration bits for Field 3.</td></tr>
<tr><td>0x12</td>
<td>0x18
</td>
<td align="left"><a href="#prop-PKT_FIELD_3_CRC_CONFIG">PKT_FIELD_3_CRC_CONFIG</a></td>
<td>0x00
<td align="left">Configuration of CRC control bits across Field 3.</td></tr>
<tr><td>0x12</td>
<td>0x19
<br/>0x1a
</td>
<td align="left"><a href="#prop-PKT_FIELD_4_LENGTH">PKT_FIELD_4_LENGTH</a></td>
<td>0x00
<br/>0x00
<td align="left">Unsigned 13-bit Field 4 length value.</td></tr>
<tr><td>0x12</td>
<td>0x1b
</td>
<td align="left"><a href="#prop-PKT_FIELD_4_CONFIG">PKT_FIELD_4_CONFIG</a></td>
<td>0x00
<td align="left">General data processing and packet configuration bits for Field 4.</td></tr>
<tr><td>0x12</td>
<td>0x1c
</td>
<td align="left"><a href="#prop-PKT_FIELD_4_CRC_CONFIG">PKT_FIELD_4_CRC_CONFIG</a></td>
<td>0x00
<td align="left">Configuration of CRC control bits across Field 4.</td></tr>
<tr><td>0x12</td>
<td>0x1d
<br/>0x1e
</td>
<td align="left"><a href="#prop-PKT_FIELD_5_LENGTH">PKT_FIELD_5_LENGTH</a></td>
<td>0x00
<br/>0x00
<td align="left">Unsigned 13-bit Field 5 length value.</td></tr>
<tr><td>0x12</td>
<td>0x1f
</td>
<td align="left"><a href="#prop-PKT_FIELD_5_CONFIG">PKT_FIELD_5_CONFIG</a></td>
<td>0x00
<td align="left">General data processing and packet configuration bits for Field 5.</td></tr>
<tr><td>0x12</td>
<td>0x20
</td>
<td align="left"><a href="#prop-PKT_FIELD_5_CRC_CONFIG">PKT_FIELD_5_CRC_CONFIG</a></td>
<td>0x00
<td align="left">Configuration of CRC control bits across Field 5.</td></tr>
<tr><td>0x12</td>
<td>0x21
<br/>0x22
</td>
<td align="left"><a href="#prop-PKT_RX_FIELD_1_LENGTH">PKT_RX_FIELD_1_LENGTH</a></td>
<td>0x00
<br/>0x00
<td align="left">Unsigned 13-bit RX Field 1 length value.</td></tr>
<tr><td>0x12</td>
<td>0x23
</td>
<td align="left"><a href="#prop-PKT_RX_FIELD_1_CONFIG">PKT_RX_FIELD_1_CONFIG</a></td>
<td>0x00
<td align="left">General data processing and packet configuration bits for RX Field 1.</td></tr>
<tr><td>0x12</td>
<td>0x24
</td>
<td align="left"><a href="#prop-PKT_RX_FIELD_1_CRC_CONFIG">PKT_RX_FIELD_1_CRC_CONFIG</a></td>
<td>0x00
<td align="left">Configuration of CRC control bits across RX Field 1.</td></tr>
<tr><td>0x12</td>
<td>0x25
<br/>0x26
</td>
<td align="left"><a href="#prop-PKT_RX_FIELD_2_LENGTH">PKT_RX_FIELD_2_LENGTH</a></td>
<td>0x00
<br/>0x00
<td align="left">Unsigned 13-bit RX Field 2 length value.</td></tr>
<tr><td>0x12</td>
<td>0x27
</td>
<td align="left"><a href="#prop-PKT_RX_FIELD_2_CONFIG">PKT_RX_FIELD_2_CONFIG</a></td>
<td>0x00
<td align="left">General data processing and packet configuration bits for RX Field 2.</td></tr>
<tr><td>0x12</td>
<td>0x28
</td>
<td align="left"><a href="#prop-PKT_RX_FIELD_2_CRC_CONFIG">PKT_RX_FIELD_2_CRC_CONFIG</a></td>
<td>0x00
<td align="left">Configuration of CRC control bits across RX Field 2.</td></tr>
<tr><td>0x12</td>
<td>0x29
<br/>0x2a
</td>
<td align="left"><a href="#prop-PKT_RX_FIELD_3_LENGTH">PKT_RX_FIELD_3_LENGTH</a></td>
<td>0x00
<br/>0x00
<td align="left">Unsigned 13-bit RX Field 3 length value.</td></tr>
<tr><td>0x12</td>
<td>0x2b
</td>
<td align="left"><a href="#prop-PKT_RX_FIELD_3_CONFIG">PKT_RX_FIELD_3_CONFIG</a></td>
<td>0x00
<td align="left">General data processing and packet configuration bits for RX Field 3.</td></tr>
<tr><td>0x12</td>
<td>0x2c
</td>
<td align="left"><a href="#prop-PKT_RX_FIELD_3_CRC_CONFIG">PKT_RX_FIELD_3_CRC_CONFIG</a></td>
<td>0x00
<td align="left">Configuration of CRC control bits across RX Field 3.</td></tr>
<tr><td>0x12</td>
<td>0x2d
<br/>0x2e
</td>
<td align="left"><a href="#prop-PKT_RX_FIELD_4_LENGTH">PKT_RX_FIELD_4_LENGTH</a></td>
<td>0x00
<br/>0x00
<td align="left">Unsigned 13-bit RX Field 4 length value.</td></tr>
<tr><td>0x12</td>
<td>0x2f
</td>
<td align="left"><a href="#prop-PKT_RX_FIELD_4_CONFIG">PKT_RX_FIELD_4_CONFIG</a></td>
<td>0x00
<td align="left">General data processing and packet configuration bits for RX Field 4.</td></tr>
<tr><td>0x12</td>
<td>0x30
</td>
<td align="left"><a href="#prop-PKT_RX_FIELD_4_CRC_CONFIG">PKT_RX_FIELD_4_CRC_CONFIG</a></td>
<td>0x00
<td align="left">Configuration of CRC control bits across RX Field 4.</td></tr>
<tr><td>0x12</td>
<td>0x31
<br/>0x32
</td>
<td align="left"><a href="#prop-PKT_RX_FIELD_5_LENGTH">PKT_RX_FIELD_5_LENGTH</a></td>
<td>0x00
<br/>0x00
<td align="left">Unsigned 13-bit RX Field 5 length value.</td></tr>
<tr><td>0x12</td>
<td>0x33
</td>
<td align="left"><a href="#prop-PKT_RX_FIELD_5_CONFIG">PKT_RX_FIELD_5_CONFIG</a></td>
<td>0x00
<td align="left">General data processing and packet configuration bits for RX Field 5.</td></tr>
<tr><td>0x12</td>
<td>0x34
</td>
<td align="left"><a href="#prop-PKT_RX_FIELD_5_CRC_CONFIG">PKT_RX_FIELD_5_CRC_CONFIG</a></td>
<td>0x00
<td align="left">Configuration of CRC control bits across RX Field 5.</td></tr>
<tr><td>0x12</td>
<td>0x35
</td>
<td align="left"><a href="#prop-PKT_RESERVED_53">PKT_RESERVED_53</a></td>
<td>0x00
<td align="left">Reserved.</td></tr>
<tr><td>0x12</td>
<td>0x36
<br/>0x37
<br/>0x38
<br/>0x39
</td>
<td align="left"><a href="#prop-PKT_CRC_SEED">PKT_CRC_SEED</a></td>
<td>0x00
<br/>0x00
<br/>0x00
<br/>0x00
<td align="left">32-bit seed value for the 32-bit CRC engine</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-MODEM">MODEM</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x20</td>
<td>0x00
</td>
<td align="left"><a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a></td>
<td>0x02
<td align="left">Selects the type of modulation.  In TX mode, additionally selects the source of the modulation.</td></tr>
<tr><td>0x20</td>
<td>0x01
</td>
<td align="left"><a href="#prop-MODEM_MAP_CONTROL">MODEM_MAP_CONTROL</a></td>
<td>0x80
<td align="left">Controls polarity and mapping of transmit and receive bits.</td></tr>
<tr><td>0x20</td>
<td>0x02
</td>
<td align="left"><a href="#prop-MODEM_DSM_CTRL">MODEM_DSM_CTRL</a></td>
<td>0x07
<td align="left">Miscellaneous control bits for the Delta-Sigma Modulator (DSM) in the PLL Synthesizer.</td></tr>
<tr><td>0x20</td>
<td>0x03
<br/>0x04
<br/>0x05
</td>
<td align="left"><a href="#prop-MODEM_DATA_RATE">MODEM_DATA_RATE</a></td>
<td>0x0f
<br/>0x42
<br/>0x40
<td align="left">Unsigned 24-bit value used to determine the TX data rate</td></tr>
<tr><td>0x20</td>
<td>0x06
<br/>0x07
<br/>0x08
<br/>0x09
</td>
<td align="left"><a href="#prop-MODEM_TX_NCO_MODE">MODEM_TX_NCO_MODE</a></td>
<td>0x01
<br/>0xc9
<br/>0xc3
<br/>0x80
<td align="left">TX Gaussian filter oversampling ratio and Byte 3 of unsigned 26-bit TX Numerically Controlled Oscillator (NCO) modulus.</td></tr>
<tr><td>0x20</td>
<td>0x0a
<br/>0x0b
<br/>0x0c
</td>
<td align="left"><a href="#prop-MODEM_FREQ_DEV">MODEM_FREQ_DEV</a></td>
<td>0x00
<br/>0x06
<br/>0xd3
<td align="left">17-bit unsigned TX frequency deviation word.</td></tr>
<tr><td>0x20</td>
<td>0x0d
<br/>0x0e
</td>
<td align="left"><a href="#prop-MODEM_FREQ_OFFSET">MODEM_FREQ_OFFSET</a></td>
<td>0x00
<br/>0x00
<td align="left">Frequency offset adjustment (a 16-bit signed number).</td></tr>
<tr><td>0x20</td>
<td>0x0f
</td>
<td align="left"><a href="#prop-MODEM_TX_FILTER_COEFF_8">MODEM_TX_FILTER_COEFF_8</a></td>
<td>0x67
<td align="left">The 8th coefficient of TX spectral shaping filter.</td></tr>
<tr><td>0x20</td>
<td>0x10
</td>
<td align="left"><a href="#prop-MODEM_TX_FILTER_COEFF_7">MODEM_TX_FILTER_COEFF_7</a></td>
<td>0x60
<td align="left">The 7th coefficient of TX spectral shaping filter.</td></tr>
<tr><td>0x20</td>
<td>0x11
</td>
<td align="left"><a href="#prop-MODEM_TX_FILTER_COEFF_6">MODEM_TX_FILTER_COEFF_6</a></td>
<td>0x4d
<td align="left">The 6th coefficient of TX spectral shaping filter.</td></tr>
<tr><td>0x20</td>
<td>0x12
</td>
<td align="left"><a href="#prop-MODEM_TX_FILTER_COEFF_5">MODEM_TX_FILTER_COEFF_5</a></td>
<td>0x36
<td align="left">The 5th coefficient of TX spectral shaping filter.</td></tr>
<tr><td>0x20</td>
<td>0x13
</td>
<td align="left"><a href="#prop-MODEM_TX_FILTER_COEFF_4">MODEM_TX_FILTER_COEFF_4</a></td>
<td>0x21
<td align="left">The 4th coefficient of TX spectral shaping filter.</td></tr>
<tr><td>0x20</td>
<td>0x14
</td>
<td align="left"><a href="#prop-MODEM_TX_FILTER_COEFF_3">MODEM_TX_FILTER_COEFF_3</a></td>
<td>0x11
<td align="left">The 3rd coefficient of TX spectral shaping filter.</td></tr>
<tr><td>0x20</td>
<td>0x15
</td>
<td align="left"><a href="#prop-MODEM_TX_FILTER_COEFF_2">MODEM_TX_FILTER_COEFF_2</a></td>
<td>0x08
<td align="left">The 2nd coefficient of TX spectral shaping filter.</td></tr>
<tr><td>0x20</td>
<td>0x16
</td>
<td align="left"><a href="#prop-MODEM_TX_FILTER_COEFF_1">MODEM_TX_FILTER_COEFF_1</a></td>
<td>0x03
<td align="left">The 1st coefficient of TX spectral shaping filter.</td></tr>
<tr><td>0x20</td>
<td>0x17
</td>
<td align="left"><a href="#prop-MODEM_TX_FILTER_COEFF_0">MODEM_TX_FILTER_COEFF_0</a></td>
<td>0x01
<td align="left">The 0th coefficient of TX spectral shaping filter.</td></tr>
<tr><td>0x20</td>
<td>0x18
</td>
<td align="left"><a href="#prop-MODEM_TX_RAMP_DELAY">MODEM_TX_RAMP_DELAY</a></td>
<td>0x01
<td align="left">TX ramp-down delay setting.</td></tr>
<tr><td>0x20</td>
<td>0x19
</td>
<td align="left"><a href="#prop-MODEM_MDM_CTRL">MODEM_MDM_CTRL</a></td>
<td>0x00
<td align="left">MDM control.</td></tr>
<tr><td>0x20</td>
<td>0x1a
</td>
<td align="left"><a href="#prop-MODEM_IF_CONTROL">MODEM_IF_CONTROL</a></td>
<td>0x08
<td align="left">Selects Fixed-IF, Scaled-IF, or Zero-IF mode of RX Modem operation.</td></tr>
<tr><td>0x20</td>
<td>0x1b
<br/>0x1c
<br/>0x1d
</td>
<td align="left"><a href="#prop-MODEM_IF_FREQ">MODEM_IF_FREQ</a></td>
<td>0x03
<br/>0xc0
<br/>0x00
<td align="left">the IF frequency setting (an 18-bit signed number).</td></tr>
<tr><td>0x20</td>
<td>0x1e
</td>
<td align="left"><a href="#prop-MODEM_DECIMATION_CFG1">MODEM_DECIMATION_CFG1</a></td>
<td>0x10
<td align="left">Specifies three decimator ratios for the Cascaded Integrator Comb (CIC) filter.</td></tr>
<tr><td>0x20</td>
<td>0x1f
</td>
<td align="left"><a href="#prop-MODEM_DECIMATION_CFG0">MODEM_DECIMATION_CFG0</a></td>
<td>0x20
<td align="left">Specifies miscellaneous parameters and decimator ratios for the Cascaded Integrator Comb (CIC) filter.</td></tr>
<tr><td>0x20</td>
<td>0x20
</td>
<td align="left"><a href="#prop-MODEM_RESERVED_20_20">MODEM_RESERVED_20_20</a></td>
<td>0x00
<td align="left">Reserved.</td></tr>
<tr><td>0x20</td>
<td>0x21
</td>
<td align="left"><a href="#prop-MODEM_RESERVED_20_21">MODEM_RESERVED_20_21</a></td>
<td>0x00
<td align="left">Reserved.</td></tr>
<tr><td>0x20</td>
<td>0x22
<br/>0x23
</td>
<td align="left"><a href="#prop-MODEM_BCR_OSR">MODEM_BCR_OSR</a></td>
<td>0x00
<br/>0x4b
<td align="left">RX BCR/Slicer oversampling rate (12-bit unsigned number).</td></tr>
<tr><td>0x20</td>
<td>0x24
<br/>0x25
<br/>0x26
</td>
<td align="left"><a href="#prop-MODEM_BCR_NCO_OFFSET">MODEM_BCR_NCO_OFFSET</a></td>
<td>0x06
<br/>0xd3
<br/>0xa0
<td align="left">RX BCR NCO offset value (an unsigned 22-bit number).</td></tr>
<tr><td>0x20</td>
<td>0x27
<br/>0x28
</td>
<td align="left"><a href="#prop-MODEM_BCR_GAIN">MODEM_BCR_GAIN</a></td>
<td>0x06
<br/>0xd3
<td align="left">The unsigned 11-bit RX BCR loop gain value.</td></tr>
<tr><td>0x20</td>
<td>0x29
</td>
<td align="left"><a href="#prop-MODEM_BCR_GEAR">MODEM_BCR_GEAR</a></td>
<td>0x02
<td align="left">RX BCR loop gear control.</td></tr>
<tr><td>0x20</td>
<td>0x2a
</td>
<td align="left"><a href="#prop-MODEM_BCR_MISC1">MODEM_BCR_MISC1</a></td>
<td>0xc0
<td align="left">Miscellaneous control bits for the RX BCR loop.</td></tr>
<tr><td>0x20</td>
<td>0x2b
</td>
<td align="left"><a href="#prop-MODEM_BCR_MISC0">MODEM_BCR_MISC0</a></td>
<td>0x00
<td align="left">Miscellaneous RX BCR loop controls.</td></tr>
<tr><td>0x20</td>
<td>0x2c
</td>
<td align="left"><a href="#prop-MODEM_AFC_GEAR">MODEM_AFC_GEAR</a></td>
<td>0x00
<td align="left">RX AFC loop gear control.</td></tr>
<tr><td>0x20</td>
<td>0x2d
</td>
<td align="left"><a href="#prop-MODEM_AFC_WAIT">MODEM_AFC_WAIT</a></td>
<td>0x23
<td align="left">RX AFC loop wait time control.</td></tr>
<tr><td>0x20</td>
<td>0x2e
<br/>0x2f
</td>
<td align="left"><a href="#prop-MODEM_AFC_GAIN">MODEM_AFC_GAIN</a></td>
<td>0x83
<br/>0x69
<td align="left">Sets the gain of the PLL-based AFC acquisition loop, and provides miscellaneous control bits for AFC functionality.</td></tr>
<tr><td>0x20</td>
<td>0x30
<br/>0x31
</td>
<td align="left"><a href="#prop-MODEM_AFC_LIMITER">MODEM_AFC_LIMITER</a></td>
<td>0x00
<br/>0x40
<td align="left">Set the AFC limiter value.</td></tr>
<tr><td>0x20</td>
<td>0x32
</td>
<td align="left"><a href="#prop-MODEM_AFC_MISC">MODEM_AFC_MISC</a></td>
<td>0xa0
<td align="left">Specifies miscellaneous AFC control bits.</td></tr>
<tr><td>0x20</td>
<td>0x33
</td>
<td align="left"><a href="#prop-MODEM_AFC_ZIFOFF">MODEM_AFC_ZIFOFF</a></td>
<td>0x00
<td align="left">AFC fixed frequency offset in zero IF mode.</td></tr>
<tr><td>0x20</td>
<td>0x34
</td>
<td align="left"><a href="#prop-MODEM_ADC_CTRL">MODEM_ADC_CTRL</a></td>
<td>0x00
<td align="left">Sigma Delta ADC controls.</td></tr>
<tr><td>0x20</td>
<td>0x35
</td>
<td align="left"><a href="#prop-MODEM_AGC_CONTROL">MODEM_AGC_CONTROL</a></td>
<td>0xe0
<td align="left">Miscellaneous control bits for the Automatic Gain Control (AGC) function in the RX Chain.</td></tr>
<tr><td>0x20</td>
<td>0x36
</td>
<td align="left"><a href="#prop-MODEM_RESERVED_20_36">MODEM_RESERVED_20_36</a></td>
<td>0x00
<td align="left">Reserved.</td></tr>
<tr><td>0x20</td>
<td>0x37
</td>
<td align="left"><a href="#prop-MODEM_RESERVED_20_37">MODEM_RESERVED_20_37</a></td>
<td>0x00
<td align="left">Reserved.</td></tr>
<tr><td>0x20</td>
<td>0x38
</td>
<td align="left"><a href="#prop-MODEM_AGC_WINDOW_SIZE">MODEM_AGC_WINDOW_SIZE</a></td>
<td>0x11
<td align="left">Specifies the size of the measurement and settling windows for the AGC algorithm. </td></tr>
<tr><td>0x20</td>
<td>0x39
</td>
<td align="left"><a href="#prop-MODEM_AGC_RFPD_DECAY">MODEM_AGC_RFPD_DECAY</a></td>
<td>0x10
<td align="left">Sets the decay time of the RF peak detectors. </td></tr>
<tr><td>0x20</td>
<td>0x3a
</td>
<td align="left"><a href="#prop-MODEM_AGC_IFPD_DECAY">MODEM_AGC_IFPD_DECAY</a></td>
<td>0x10
<td align="left">Sets the decay time of the IF peak detectors.</td></tr>
<tr><td>0x20</td>
<td>0x3b
</td>
<td align="left"><a href="#prop-MODEM_FSK4_GAIN1">MODEM_FSK4_GAIN1</a></td>
<td>0x0b
<td align="left">Specifies the gain factor of the secondary branch in 4(G)FSK ISI-suppression.</td></tr>
<tr><td>0x20</td>
<td>0x3c
</td>
<td align="left"><a href="#prop-MODEM_FSK4_GAIN0">MODEM_FSK4_GAIN0</a></td>
<td>0x1c
<td align="left">Specifies the gain factor of the primary branch in 4(G)FSK ISI-suppression.</td></tr>
<tr><td>0x20</td>
<td>0x3d
<br/>0x3e
</td>
<td align="left"><a href="#prop-MODEM_FSK4_TH">MODEM_FSK4_TH</a></td>
<td>0x40
<br/>0x00
<td align="left">16 bit 4(G)FSK slicer threshold.</td></tr>
<tr><td>0x20</td>
<td>0x3f
</td>
<td align="left"><a href="#prop-MODEM_FSK4_MAP">MODEM_FSK4_MAP</a></td>
<td>0x00
<td align="left">4(G)FSK symbol mapping code.</td></tr>
<tr><td>0x20</td>
<td>0x40
</td>
<td align="left"><a href="#prop-MODEM_OOK_PDTC">MODEM_OOK_PDTC</a></td>
<td>0x2b
<td align="left">Configures the attack and decay times of the OOK Peak Detector.</td></tr>
<tr><td>0x20</td>
<td>0x41
</td>
<td align="left"><a href="#prop-MODEM_OOK_BLOPK">MODEM_OOK_BLOPK</a></td>
<td>0x0c
<td align="left">Configures the slicing reference level of the OOK Peak Detector.</td></tr>
<tr><td>0x20</td>
<td>0x42
</td>
<td align="left"><a href="#prop-MODEM_OOK_CNT1">MODEM_OOK_CNT1</a></td>
<td>0xa4
<td align="left">OOK control.</td></tr>
<tr><td>0x20</td>
<td>0x43
</td>
<td align="left"><a href="#prop-MODEM_OOK_MISC">MODEM_OOK_MISC</a></td>
<td>0x03
<td align="left">Selects the detector(s) used for demodulation of an OOK signal, or for demodulation of a (G)FSK signal when using the asynchronous demodulator.</td></tr>
<tr><td>0x20</td>
<td>0x44
</td>
<td align="left"><a href="#prop-MODEM_RAW_SEARCH">MODEM_RAW_SEARCH</a></td>
<td>0x56
<td align="left">Defines and controls the search period length for the Moving Average and Min-Max detectors.</td></tr>
<tr><td>0x20</td>
<td>0x45
</td>
<td align="left"><a href="#prop-MODEM_RAW_CONTROL">MODEM_RAW_CONTROL</a></td>
<td>0x02
<td align="left">Defines gain and enable controls for raw / nonstandard mode.</td></tr>
<tr><td>0x20</td>
<td>0x46
<br/>0x47
</td>
<td align="left"><a href="#prop-MODEM_RAW_EYE">MODEM_RAW_EYE</a></td>
<td>0x00
<br/>0xa3
<td align="left">11 bit eye-open detector threshold.</td></tr>
<tr><td>0x20</td>
<td>0x48
</td>
<td align="left"><a href="#prop-MODEM_ANT_DIV_MODE">MODEM_ANT_DIV_MODE</a></td>
<td>0x02
<td align="left">Antenna diversity mode settings.</td></tr>
<tr><td>0x20</td>
<td>0x49
</td>
<td align="left"><a href="#prop-MODEM_ANT_DIV_CONTROL">MODEM_ANT_DIV_CONTROL</a></td>
<td>0x80
<td align="left">Specifies controls for the Antenna Diversity algorithm.</td></tr>
<tr><td>0x20</td>
<td>0x4a
</td>
<td align="left"><a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a></td>
<td>0xff
<td align="left">Configures the RSSI threshold. </td></tr>
<tr><td>0x20</td>
<td>0x4b
</td>
<td align="left"><a href="#prop-MODEM_RSSI_JUMP_THRESH">MODEM_RSSI_JUMP_THRESH</a></td>
<td>0x0c
<td align="left">Configures the RSSI Jump Detection threshold.</td></tr>
<tr><td>0x20</td>
<td>0x4c
</td>
<td align="left"><a href="#prop-MODEM_RSSI_CONTROL">MODEM_RSSI_CONTROL</a></td>
<td>0x01
<td align="left">Control of the averaging modes and latching time for reporting RSSI value(s).</td></tr>
<tr><td>0x20</td>
<td>0x4d
</td>
<td align="left"><a href="#prop-MODEM_RSSI_CONTROL2">MODEM_RSSI_CONTROL2</a></td>
<td>0x00
<td align="left">RSSI Jump Detection control.</td></tr>
<tr><td>0x20</td>
<td>0x4e
</td>
<td align="left"><a href="#prop-MODEM_RSSI_COMP">MODEM_RSSI_COMP</a></td>
<td>0x32
<td align="left">RSSI compensation value.</td></tr>
<tr><td>0x20</td>
<td>0x4f
</td>
<td align="left"><a href="#prop-MODEM_DC_CONTROL">MODEM_DC_CONTROL</a></td>
<td>0x03
<td align="left">Modem DC cancellation controls.</td></tr>
<tr><td>0x20</td>
<td>0x50
</td>
<td align="left"><a href="#prop-MODEM_RAW_SEARCH2">MODEM_RAW_SEARCH2</a></td>
<td>0x00
<td align="left">Defines and controls the search period length for the Moving Average and Min-Max detectors.</td></tr>
<tr><td>0x20</td>
<td>0x51
</td>
<td align="left"><a href="#prop-MODEM_CLKGEN_BAND">MODEM_CLKGEN_BAND</a></td>
<td>0x08
<td align="left">Select PLL Synthesizer output divider ratio as a function of frequency band.</td></tr>
<tr><td>0x20</td>
<td>0x52
</td>
<td align="left"><a href="#prop-MODEM_RESERVED_20_52">MODEM_RESERVED_20_52</a></td>
<td>0x00
<td align="left">Reserved.</td></tr>
<tr><td>0x20</td>
<td>0x53
</td>
<td align="left"><a href="#prop-MODEM_PLL_SETTLE_TIME">MODEM_PLL_SETTLE_TIME</a></td>
<td>0x28
<td align="left">Configures an internal timer for the expected PLL Synthesizer settling time.</td></tr>
<tr><td>0x20</td>
<td>0x54
</td>
<td align="left"><a href="#prop-MODEM_SPIKE_DET">MODEM_SPIKE_DET</a></td>
<td>0x00
<td align="left">Configures the threshold for (G)FSK SPike Detection.</td></tr>
<tr><td>0x20</td>
<td>0x55
</td>
<td align="left"><a href="#prop-MODEM_ONE_SHOT_AFC">MODEM_ONE_SHOT_AFC</a></td>
<td>0x00
<td align="left">Configures parameters for th e One Shot AFC function and for BCR timing/acquisition.</td></tr>
<tr><td>0x20</td>
<td>0x56
</td>
<td align="left"><a href="#prop-MODEM_RSSI_HYSTERESIS">MODEM_RSSI_HYSTERESIS</a></td>
<td>0xff
<td align="left">Configures the amount of hysteresis on the RSSI threshold detection function.</td></tr>
<tr><td>0x20</td>
<td>0x57
</td>
<td align="left"><a href="#prop-MODEM_RSSI_MUTE">MODEM_RSSI_MUTE</a></td>
<td>0x00
<td align="left">Configures muting of the RSSI to avoid false RSSI interrupts.</td></tr>
<tr><td>0x20</td>
<td>0x58
</td>
<td align="left"><a href="#prop-MODEM_FAST_RSSI_DELAY">MODEM_FAST_RSSI_DELAY</a></td>
<td>0x00
<td align="left">Configures the delay for fast RSSI Latching mode.</td></tr>
<tr><td>0x20</td>
<td>0x59
<br/>0x5a
</td>
<td align="left"><a href="#prop-MODEM_PSM">MODEM_PSM</a></td>
<td>0x00
<br/>0x00
<td align="left">Configures the Preamble Sense Mode feature</td></tr>
<tr><td>0x20</td>
<td>0x5b
</td>
<td align="left"><a href="#prop-MODEM_DSA_CTRL1">MODEM_DSA_CTRL1</a></td>
<td>0x00
<td align="left">Configures parameters for the Signal Arrival Detection circuit block and algorithm.</td></tr>
<tr><td>0x20</td>
<td>0x5c
</td>
<td align="left"><a href="#prop-MODEM_DSA_CTRL2">MODEM_DSA_CTRL2</a></td>
<td>0x00
<td align="left">Signal Arrival Detection Control 2</td></tr>
<tr><td>0x20</td>
<td>0x5d
</td>
<td align="left"><a href="#prop-MODEM_DSA_QUAL">MODEM_DSA_QUAL</a></td>
<td>0x00
<td align="left">Configures parameters for the Eye Opening qualification m ethod of the Signal Arrival Detection algorithm.</td></tr>
<tr><td>0x20</td>
<td>0x5e
</td>
<td align="left"><a href="#prop-MODEM_DSA_RSSI">MODEM_DSA_RSSI</a></td>
<td>0x00
<td align="left">Signal Arrival Detect RSSI Qualifier Config</td></tr>
<tr><td>0x20</td>
<td>0x5f
</td>
<td align="left"><a href="#prop-MODEM_DSA_MISC">MODEM_DSA_MISC</a></td>
<td>0x00
<td align="left">Miscellaneous detection of signal arrival bits.</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-MODEM_CHFLT">MODEM_CHFLT</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x21</td>
<td>0x00
<br/>0x01
<br/>0x02
<br/>0x03
<br/>0x04
<br/>0x05
<br/>0x06
<br/>0x07
<br/>0x08
<br/>0x09
<br/>0x0a
<br/>0x0b
<br/>0x0c
<br/>0x0d
<br/>0x0e
<br/>0x0f
<br/>0x10
<br/>0x11
</td>
<td align="left"><a href="#prop-MODEM_CHFLT_RX1_CHFLT_COE">MODEM_CHFLT_RX1_CHFLT_COE</a></td>
<td>0xff
<br/>0xba
<br/>0x0f
<br/>0x51
<br/>0xcf
<br/>0xa9
<br/>0xc9
<br/>0xfc
<br/>0x1b
<br/>0x1e
<br/>0x0f
<br/>0x01
<br/>0xfc
<br/>0xfd
<br/>0x15
<br/>0xff
<br/>0x00
<br/>0x0f
<td align="left">Filter coefficients for the first set of RX filter coefficients.</td></tr>
<tr><td>0x21</td>
<td>0x12
<br/>0x13
<br/>0x14
<br/>0x15
<br/>0x16
<br/>0x17
<br/>0x18
<br/>0x19
<br/>0x1a
<br/>0x1b
<br/>0x1c
<br/>0x1d
<br/>0x1e
<br/>0x1f
<br/>0x20
<br/>0x21
<br/>0x22
<br/>0x23
</td>
<td align="left"><a href="#prop-MODEM_CHFLT_RX2_CHFLT_COE">MODEM_CHFLT_RX2_CHFLT_COE</a></td>
<td>0xff
<br/>0xc4
<br/>0x30
<br/>0x7f
<br/>0xf5
<br/>0xb5
<br/>0xb8
<br/>0xde
<br/>0x05
<br/>0x17
<br/>0x16
<br/>0x0c
<br/>0x03
<br/>0x00
<br/>0x15
<br/>0xff
<br/>0x00
<br/>0x00
<td align="left">Filter coefficients for the second set of RX filter coefficients.</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-PA">PA</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x22</td>
<td>0x00
</td>
<td align="left"><a href="#prop-PA_MODE">PA_MODE</a></td>
<td>0x08
<td align="left">Selects the PA operating mode, and selects resolution of PA power adjustment (i.e., step size).</td></tr>
<tr><td>0x22</td>
<td>0x01
</td>
<td align="left"><a href="#prop-PA_PWR_LVL">PA_PWR_LVL</a></td>
<td>0x7f
<td align="left">Configuration of PA output power level.</td></tr>
<tr><td>0x22</td>
<td>0x02
</td>
<td align="left"><a href="#prop-PA_BIAS_CLKDUTY">PA_BIAS_CLKDUTY</a></td>
<td>0x00
<td align="left">Configuration of the PA Bias and duty cycle of the TX clock source.</td></tr>
<tr><td>0x22</td>
<td>0x03
</td>
<td align="left"><a href="#prop-PA_TC">PA_TC</a></td>
<td>0x5d
<td align="left">Configuration of PA ramping parameters.</td></tr>
<tr><td>0x22</td>
<td>0x04
</td>
<td align="left"><a href="#prop-PA_RAMP_EX">PA_RAMP_EX</a></td>
<td>0x80
<td align="left">Select the time constant of the external PA ramp signal.</td></tr>
<tr><td>0x22</td>
<td>0x05
</td>
<td align="left"><a href="#prop-PA_RAMP_DOWN_DELAY">PA_RAMP_DOWN_DELAY</a></td>
<td>0x23
<td align="left">Delay from the start of the PA ramp down to disabling of the PA output. </td></tr>
<tr><td>0x22</td>
<td>0x06
</td>
<td align="left"><a href="#prop-PA_DIG_PWR_SEQ_CONFIG">PA_DIG_PWR_SEQ_CONFIG</a></td>
<td>0x03
<td align="left">Configuration for digital power sequencing.</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-SYNTH">SYNTH</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x23</td>
<td>0x00
</td>
<td align="left"><a href="#prop-SYNTH_PFDCP_CPFF">SYNTH_PFDCP_CPFF</a></td>
<td>0x2c
<td align="left">Feed forward charge pump current selection.</td></tr>
<tr><td>0x23</td>
<td>0x01
</td>
<td align="left"><a href="#prop-SYNTH_PFDCP_CPINT">SYNTH_PFDCP_CPINT</a></td>
<td>0x0e
<td align="left">Integration charge pump current selection.</td></tr>
<tr><td>0x23</td>
<td>0x02
</td>
<td align="left"><a href="#prop-SYNTH_VCO_KV">SYNTH_VCO_KV</a></td>
<td>0x0b
<td align="left">Gain scaling factors (Kv) for the VCO tuning varactors on both the integrated-path and feed forward path.</td></tr>
<tr><td>0x23</td>
<td>0x03
</td>
<td align="left"><a href="#prop-SYNTH_LPFILT3">SYNTH_LPFILT3</a></td>
<td>0x04
<td align="left">Value of resistor R2 in feed-forward path of loop filter.</td></tr>
<tr><td>0x23</td>
<td>0x04
</td>
<td align="left"><a href="#prop-SYNTH_LPFILT2">SYNTH_LPFILT2</a></td>
<td>0x0c
<td align="left">Value of capacitor C2 in feed-forward path of loop filter.</td></tr>
<tr><td>0x23</td>
<td>0x05
</td>
<td align="left"><a href="#prop-SYNTH_LPFILT1">SYNTH_LPFILT1</a></td>
<td>0x73
<td align="left">Value of capacitors C1 and C3 in feed-forward path of loop filter.</td></tr>
<tr><td>0x23</td>
<td>0x06
</td>
<td align="left"><a href="#prop-SYNTH_LPFILT0">SYNTH_LPFILT0</a></td>
<td>0x03
<td align="left">Bias current of the active amplifier in the feed-forward loop filter.</td></tr>
<tr><td>0x23</td>
<td>0x07
</td>
<td align="left"><a href="#prop-SYNTH_VCO_KVCAL">SYNTH_VCO_KVCAL</a></td>
<td>0x05
<td align="left">Scaling entire KV of VCO.</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-EZCONFIG">EZCONFIG</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x24</td>
<td>0x00
</td>
<td align="left"><a href="#prop-EZCONFIG_MODULATION">EZCONFIG_MODULATION</a></td>
<td>0x02
<td align="left">Selects the type of modulation using the EZConfig feature.</td></tr>
<tr><td>0x24</td>
<td>0x01
</td>
<td align="left"><a href="#prop-EZCONFIG_CONFIG_SELECT">EZCONFIG_CONFIG_SELECT</a></td>
<td>0x00
<td align="left">REMOVED as of fw_3_0_9 Used to be: Select the index from EZ config table.</td></tr>
<tr><td>0x24</td>
<td>0x02
</td>
<td align="left"><a href="#prop-EZCONFIG_PKT">EZCONFIG_PKT</a></td>
<td>0x00
<td align="left">REMOVED as of fw_3_0_9 Used to be: EZ config packet configure.</td></tr>
<tr><td>0x24</td>
<td>0x03
</td>
<td align="left"><a href="#prop-EZCONFIG_XO_TUNE">EZCONFIG_XO_TUNE</a></td>
<td>0x40
<td align="left">Configure the internal capacitor frequency tuning bank for the crystal oscillator.</td></tr>
<tr><td>0x24</td>
<td>0x04
</td>
<td align="left"><a href="#prop-EZCONFIG_SPARE0">EZCONFIG_SPARE0</a></td>
<td>0x00
<td align="left">For use in patches.</td></tr>
<tr><td>0x24</td>
<td>0x05
</td>
<td align="left"><a href="#prop-EZCONFIG_SPARE1">EZCONFIG_SPARE1</a></td>
<td>0x00
<td align="left">For use in patches.</td></tr>
<tr><td>0x24</td>
<td>0x06
</td>
<td align="left"><a href="#prop-EZCONFIG_SPARE2">EZCONFIG_SPARE2</a></td>
<td>0x00
<td align="left">For use in patches.</td></tr>
<tr><td>0x24</td>
<td>0x07
</td>
<td align="left"><a href="#prop-EZCONFIG_SPARE3">EZCONFIG_SPARE3</a></td>
<td>0x00
<td align="left">For use in patches.</td></tr>
<tr><td>0x24</td>
<td>0x08
</td>
<td align="left"><a href="#prop-EZCONFIG_SPARE4">EZCONFIG_SPARE4</a></td>
<td>0x00
<td align="left">For use in patches.</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-MATCH">MATCH</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x30</td>
<td>0x00
</td>
<td align="left"><a href="#prop-MATCH_VALUE_1">MATCH_VALUE_1</a></td>
<td>0x00
<td align="left">Match value to be compared with the result of logically AND-ing (bit-wise) the Mask 1 value with the received Match 1 byte. </td></tr>
<tr><td>0x30</td>
<td>0x01
</td>
<td align="left"><a href="#prop-MATCH_MASK_1">MATCH_MASK_1</a></td>
<td>0x00
<td align="left">Mask value to be logically AND-ed (bit-wise) with the Match 1 byte.</td></tr>
<tr><td>0x30</td>
<td>0x02
</td>
<td align="left"><a href="#prop-MATCH_CTRL_1">MATCH_CTRL_1</a></td>
<td>0x00
<td align="left">Enable for Packet Match functionality, and configuration of Match Byte 1.</td></tr>
<tr><td>0x30</td>
<td>0x03
</td>
<td align="left"><a href="#prop-MATCH_VALUE_2">MATCH_VALUE_2</a></td>
<td>0x00
<td align="left">Match value to be compared with the result of logically AND-ing (bit-wise) the Mask 2 value with the received Match 2 byte. </td></tr>
<tr><td>0x30</td>
<td>0x04
</td>
<td align="left"><a href="#prop-MATCH_MASK_2">MATCH_MASK_2</a></td>
<td>0x00
<td align="left">Mask value to be logically AND-ed (bit-wise) with the Match 2 byte.</td></tr>
<tr><td>0x30</td>
<td>0x05
</td>
<td align="left"><a href="#prop-MATCH_CTRL_2">MATCH_CTRL_2</a></td>
<td>0x00
<td align="left">Configuration of Match Byte 2.</td></tr>
<tr><td>0x30</td>
<td>0x06
</td>
<td align="left"><a href="#prop-MATCH_VALUE_3">MATCH_VALUE_3</a></td>
<td>0x00
<td align="left">Match value to be compared with the result of logically AND-ing (bit-wise) the Mask 3 value with the received Match 3 byte. </td></tr>
<tr><td>0x30</td>
<td>0x07
</td>
<td align="left"><a href="#prop-MATCH_MASK_3">MATCH_MASK_3</a></td>
<td>0x00
<td align="left">Mask value to be logically AND-ed (bit-wise) with the Match 3 byte.</td></tr>
<tr><td>0x30</td>
<td>0x08
</td>
<td align="left"><a href="#prop-MATCH_CTRL_3">MATCH_CTRL_3</a></td>
<td>0x00
<td align="left">Configuration of Match Byte 3.</td></tr>
<tr><td>0x30</td>
<td>0x09
</td>
<td align="left"><a href="#prop-MATCH_VALUE_4">MATCH_VALUE_4</a></td>
<td>0x00
<td align="left">Match value to be compared with the result of logically AND-ing (bit-wise) the Mask 4 value with the received Match 4 byte. </td></tr>
<tr><td>0x30</td>
<td>0x0a
</td>
<td align="left"><a href="#prop-MATCH_MASK_4">MATCH_MASK_4</a></td>
<td>0x00
<td align="left">Mask value to be logically AND-ed (bit-wise) with the Match 4 byte.</td></tr>
<tr><td>0x30</td>
<td>0x0b
</td>
<td align="left"><a href="#prop-MATCH_CTRL_4">MATCH_CTRL_4</a></td>
<td>0x00
<td align="left">Configuration of Match Byte 4.</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-FREQ_CONTROL">FREQ_CONTROL</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x40</td>
<td>0x00
</td>
<td align="left"><a href="#prop-FREQ_CONTROL_INTE">FREQ_CONTROL_INTE</a></td>
<td>0x3c
<td align="left">Frac-N PLL Synthesizer integer divide number.</td></tr>
<tr><td>0x40</td>
<td>0x01
<br/>0x02
<br/>0x03
</td>
<td align="left"><a href="#prop-FREQ_CONTROL_FRAC">FREQ_CONTROL_FRAC</a></td>
<td>0x08
<br/>0x00
<br/>0x00
<td align="left">Frac-N PLL fraction number.</td></tr>
<tr><td>0x40</td>
<td>0x04
<br/>0x05
</td>
<td align="left"><a href="#prop-FREQ_CONTROL_CHANNEL_STEP_SIZE">FREQ_CONTROL_CHANNEL_STEP_SIZE</a></td>
<td>0x00
<br/>0x00
<td align="left">EZ Frequency Programming channel step size.</td></tr>
<tr><td>0x40</td>
<td>0x06
</td>
<td align="left"><a href="#prop-FREQ_CONTROL_W_SIZE">FREQ_CONTROL_W_SIZE</a></td>
<td>0x20
<td align="left">Set window gating period (in number of crystal reference clock cycles) for counting VCO frequency during calibration.</td></tr>
<tr><td>0x40</td>
<td>0x07
</td>
<td align="left"><a href="#prop-FREQ_CONTROL_VCOCNT_RX_ADJ">FREQ_CONTROL_VCOCNT_RX_ADJ</a></td>
<td>0xff
<td align="left">Adjust target count for VCO calibration in RX mode.</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-RX_HOP">RX_HOP</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x50</td>
<td>0x00
</td>
<td align="left"><a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a></td>
<td>0x04
<td align="left">Configuration options for the automatic RX Hop functionality.</td></tr>
<tr><td>0x50</td>
<td>0x01
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_SIZE">RX_HOP_TABLE_SIZE</a></td>
<td>0x01
<td align="left">Specifies the number of entries (channels) in the RX Hop table.</td></tr>
<tr><td>0x50</td>
<td>0x02
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[0]</td>
<td>0x00
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x03
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[1]</td>
<td>0x01
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x04
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[2]</td>
<td>0x02
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x05
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[3]</td>
<td>0x03
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x06
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[4]</td>
<td>0x04
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x07
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[5]</td>
<td>0x05
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x08
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[6]</td>
<td>0x06
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x09
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[7]</td>
<td>0x07
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x0a
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[8]</td>
<td>0x08
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x0b
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[9]</td>
<td>0x09
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x0c
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[10]</td>
<td>0x0a
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x0d
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[11]</td>
<td>0x0b
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x0e
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[12]</td>
<td>0x0c
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x0f
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[13]</td>
<td>0x0d
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x10
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[14]</td>
<td>0x0e
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x11
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[15]</td>
<td>0x0f
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x12
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[16]</td>
<td>0x10
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x13
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[17]</td>
<td>0x11
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x14
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[18]</td>
<td>0x12
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x15
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[19]</td>
<td>0x13
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x16
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[20]</td>
<td>0x14
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x17
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[21]</td>
<td>0x15
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x18
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[22]</td>
<td>0x16
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x19
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[23]</td>
<td>0x17
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x1a
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[24]</td>
<td>0x18
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x1b
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[25]</td>
<td>0x19
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x1c
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[26]</td>
<td>0x1a
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x1d
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[27]</td>
<td>0x1b
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x1e
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[28]</td>
<td>0x1c
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x1f
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[29]</td>
<td>0x1d
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x20
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[30]</td>
<td>0x1e
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x21
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[31]</td>
<td>0x1f
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x22
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[32]</td>
<td>0x20
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x23
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[33]</td>
<td>0x21
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x24
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[34]</td>
<td>0x22
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x25
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[35]</td>
<td>0x23
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x26
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[36]</td>
<td>0x24
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x27
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[37]</td>
<td>0x25
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x28
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[38]</td>
<td>0x26
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x29
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[39]</td>
<td>0x27
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x2a
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[40]</td>
<td>0x28
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x2b
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[41]</td>
<td>0x29
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x2c
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[42]</td>
<td>0x2a
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x2d
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[43]</td>
<td>0x2b
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x2e
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[44]</td>
<td>0x2c
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x2f
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[45]</td>
<td>0x2d
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x30
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[46]</td>
<td>0x2e
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x31
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[47]</td>
<td>0x2f
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x32
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[48]</td>
<td>0x30
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x33
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[49]</td>
<td>0x31
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x34
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[50]</td>
<td>0x32
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x35
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[51]</td>
<td>0x33
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x36
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[52]</td>
<td>0x34
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x37
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[53]</td>
<td>0x35
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x38
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[54]</td>
<td>0x36
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x39
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[55]</td>
<td>0x37
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x3a
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[56]</td>
<td>0x38
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x3b
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[57]</td>
<td>0x39
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x3c
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[58]</td>
<td>0x3a
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x3d
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[59]</td>
<td>0x3b
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x3e
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[60]</td>
<td>0x3c
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x3f
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[61]</td>
<td>0x3d
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x40
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[62]</td>
<td>0x3e
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
<tr><td>0x50</td>
<td>0x41
</td>
<td align="left"><a href="#prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a>[63]</td>
<td>0x3f
<td align="left">Defines entries in the RX Hopping Table (N=0 to 63)</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-IE154_TX">IE154_TX</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x60</td>
<td>0x00
</td>
<td align="left"><a href="#prop-IE154_TX_FLAGS">IE154_TX_FLAGS</a></td>
<td>0x00
<td align="left">Configure ie154_tx_flags</td></tr>
<tr><td>0x60</td>
<td>0x01
</td>
<td align="left"><a href="#prop-IE154_TX_BACKOFF_TURNAROUND_TIME_SYMBOLS">IE154_TX_BACKOFF_TURNAROUND_TIME_SYMBOLS</a></td>
<td>0x0c
<td align="left">Configure TX Mode transition time after sending a packet and starting to receive the ack</td></tr>
<tr><td>0x60</td>
<td>0x02
<br/>0x03
</td>
<td align="left"><a href="#prop-IE154_TX_ACK_TIMEOUT">IE154_TX_ACK_TIMEOUT</a></td>
<td>0x00
<br/>0xff
<td align="left">Configure the number of symbols for ack timeout.</td></tr>
<tr><td>0x60</td>
<td>0x04
</td>
<td align="left"><a href="#prop-IE154_TX_CCA_MODE">IE154_TX_CCA_MODE</a></td>
<td>0x00
<td align="left">TX Mode CCA configuration.</td></tr>
<tr><td>0x60</td>
<td>0x05
</td>
<td align="left"><a href="#prop-IE154_TX_CCA_THRESHOLD">IE154_TX_CCA_THRESHOLD</a></td>
<td>0x50
<td align="left">Configure CCA Threshold</td></tr>
<tr><td>0x60</td>
<td>0x06
<br/>0x07
</td>
<td align="left"><a href="#prop-IE154_TX_CSMA_BACKOFF_BASE_SYMBOLS">IE154_TX_CSMA_BACKOFF_BASE_SYMBOLS</a></td>
<td>0x00
<br/>0x14
<td align="left">Define the base number of symbols for the CSMA backoff.</td></tr>
<tr><td>0x60</td>
<td>0x08
<br/>0x09
<br/>0x0a
<br/>0x0b
<br/>0x0c
<br/>0x0d
<br/>0x0e
<br/>0x0f
<br/>0x10
<br/>0x11
</td>
<td align="left"><a href="#prop-IE154_TX_CSMA_BACKOFF">IE154_TX_CSMA_BACKOFF</a></td>
<td>0x00
<br/>0x07
<br/>0x00
<br/>0x0f
<br/>0x00
<br/>0x1f
<br/>0x00
<br/>0x1f
<br/>0x00
<br/>0x1f
<td align="left">Configure the range of CSMA backoff for five attempts.</td></tr>
<tr><td>0x60</td>
<td>0x12
<br/>0x13
</td>
<td align="left"><a href="#prop-IE154_TX_CSMA_ON_SYMBOLS">IE154_TX_CSMA_ON_SYMBOLS</a></td>
<td>0x00
<br/>0x08
<td align="left">Define the number of symbols to measure RSSI during CCA.</td></tr>
<tr><td>0x60</td>
<td>0x14
</td>
<td align="left"><a href="#prop-IE154_TX_LBT_CLEAR_TIME_MIN">IE154_TX_LBT_CLEAR_TIME_MIN</a></td>
<td>0x05
<td align="left">Define the LBT minimum clear time.</td></tr>
<tr><td>0x60</td>
<td>0x15
</td>
<td align="left"><a href="#prop-IE154_TX_LBT_CLEAR_TIME_MAX">IE154_TX_LBT_CLEAR_TIME_MAX</a></td>
<td>0x0a
<td align="left">Define the LBT maximum clear time.</td></tr>
<tr><td>0x60</td>
<td>0x16
</td>
<td align="left"><a href="#prop-IE154_TX_LBT_TOTAL_TIME">IE154_TX_LBT_TOTAL_TIME</a></td>
<td>0x32
<td align="left">Total time to check for a clear channel with the Listen Before Talk algorithm.</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-IE154_RX">IE154_RX</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x61</td>
<td>0x00
</td>
<td align="left"><a href="#prop-IE154_RX_FLAGS">IE154_RX_FLAGS</a></td>
<td>0x13
<td align="left">Control fields for Rx mode.</td></tr>
<tr><td>0x61</td>
<td>0x01
</td>
<td align="left"><a href="#prop-IE154_RX_FLAGS2">IE154_RX_FLAGS2</a></td>
<td>0x00
<td align="left">Control fields for Rx mode.</td></tr>
<tr><td>0x61</td>
<td>0x02
</td>
<td align="left"><a href="#prop-IE154_RX_BACKOFF_TURNAROUND_TIME">IE154_RX_BACKOFF_TURNAROUND_TIME</a></td>
<td>0x0c
<td align="left">Turnaround time between receiving the packet and transmitting the ack</td></tr>
<tr><td>0x61</td>
<td>0x03
<br/>0x04
<br/>0x05
<br/>0x06
<br/>0x07
<br/>0x08
<br/>0x09
<br/>0x0a
</td>
<td align="left"><a href="#prop-IE154_RX_EUI_64">IE154_RX_EUI_64</a></td>
<td>0x00
<br/>0x00
<br/>0x00
<br/>0x00
<br/>0x00
<br/>0x00
<br/>0x00
<br/>0x00
<td align="left">Configure EUI 64</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-IE154_COMMON">IE154_COMMON</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x62</td>
<td>0x00
</td>
<td align="left"><a href="#prop-IE154_COMMON_FLAGS">IE154_COMMON_FLAGS</a></td>
<td>0x80
<td align="left">TODO</td></tr>
<tr><td>0x62</td>
<td>0x01
</td>
<td align="left"><a href="#prop-IE154_COMMON_PHY_CFG">IE154_COMMON_PHY_CFG</a></td>
<td>0x03
<td align="left">TODO</td></tr>
<tr><td>0x62</td>
<td>0x02
<br/>0x03
</td>
<td align="left"><a href="#prop-IE154_COMMON_MAX_PAYLOAD_SIZE">IE154_COMMON_MAX_PAYLOAD_SIZE</a></td>
<td>0x00
<br/>0x7d
<td align="left">Configure maximum allowed payload size.  Packets that have a length larger than this value will be filtered out and will not be placed into the RX FIFO.</td></tr>
<tr><td>0x62</td>
<td>0x04
</td>
<td align="left"><a href="#prop-IE154_COMMON_MIN_PAYLOAD_SIZE">IE154_COMMON_MIN_PAYLOAD_SIZE</a></td>
<td>0x02
<td align="left"> Configure minimum allowed payload size when </td></tr>
<tr><td>0x62</td>
<td>0x05
<br/>0x06
</td>
<td align="left"><a href="#prop-IE154_COMMON_XTAL_TICK_PER_SYMBOL">IE154_COMMON_XTAL_TICK_PER_SYMBOL</a></td>
<td>0x01
<br/>0x2c
<td align="left">Defines the number of crystal ticks that makes up a symbol time.</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-IE154_INT_CTL">IE154_INT_CTL</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x63</td>
<td>0x00
</td>
<td align="left"><a href="#prop-IE154_INT_CTL_ENABLE">IE154_INT_CTL_ENABLE</a></td>
<td>0x00
<td align="left">INTERNAL STATUS: Implemented, not fully tested
                        tx_int_status_en: Implemented, not used nor tested
                        rx_int_status_en: Implemented, not used nor tested
                        chip_int_status_en: Implemented, not used nor tested
                        This property provides for global enabling of the three interrupt groups in order to generate HW interrupts at the NIRQ pin.</td></tr>
<tr><td>0x63</td>
<td>0x01
</td>
<td align="left"><a href="#prop-IE154_INT_CTL_TX_ENABLE">IE154_INT_CTL_TX_ENABLE</a></td>
<td>0x00
<td align="left">INTERNAL STATUS: Implemented, Does not seem to be used for any flag ??
Configure 802.15.4 Tx Interrupts</td></tr>
<tr><td>0x63</td>
<td>0x02
</td>
<td align="left"><a href="#prop-IE154_INT_CTL_RX_ENABLE">IE154_INT_CTL_RX_ENABLE</a></td>
<td>0x00
<td align="left">INTERNAL STATUS: Implemented, Does not seem to be used for any flag ??
Configure 802.15.4 Rx Interrupts</td></tr>
<tr><td>0x63</td>
<td>0x03
</td>
<td align="left"><a href="#prop-IE154_INT_CTL_IE154_CHIP_ENABLE">IE154_INT_CTL_IE154_CHIP_ENABLE</a></td>
<td>0x00
<td align="left">INTERNAL STATUS: Implemented, Does not seem to be used for any flag ??
Enable individual interrupt sources within the Chip Interrupt Group to generate a HW interrupt on the NIRQ output pin.</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-IE154_NETWORK">IE154_NETWORK</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x64</td>
<td>0x00
</td>
<td align="left"><a href="#prop-IE154_NETWORK_COORDINATOR_MASK">IE154_NETWORK_COORDINATOR_MASK</a></td>
<td>0x00
<td align="left">Configure network coordinator mask</td></tr>
<tr><td>0x64</td>
<td>0x01
<br/>0x02
<br/>0x03
<br/>0x04
<br/>0x05
<br/>0x06
</td>
<td align="left"><a href="#prop-IE154_NETWORK_LIST">IE154_NETWORK_LIST</a>[0]</td>
<td>0xff
<br/>0xff
<br/>0xff
<br/>0xfe
<br/>0x00
<br/>0x0f
<td align="left">Configure PAN ID, node ID and channel ID</td></tr>
<tr><td>0x64</td>
<td>0x07
<br/>0x08
<br/>0x09
<br/>0x0a
<br/>0x0b
<br/>0x0c
</td>
<td align="left"><a href="#prop-IE154_NETWORK_LIST">IE154_NETWORK_LIST</a>[1]</td>
<td>0xff
<br/>0xff
<br/>0xff
<br/>0xfe
<br/>0x00
<br/>0x0f
<td align="left">Configure PAN ID, node ID and channel ID</td></tr>
<tr><td>0x64</td>
<td>0x0d
<br/>0x0e
<br/>0x0f
<br/>0x10
<br/>0x11
<br/>0x12
</td>
<td align="left"><a href="#prop-IE154_NETWORK_LIST">IE154_NETWORK_LIST</a>[2]</td>
<td>0xff
<br/>0xff
<br/>0xff
<br/>0xfe
<br/>0x00
<br/>0x0f
<td align="left">Configure PAN ID, node ID and channel ID</td></tr>
<tr><td>0x64</td>
<td>0x13
<br/>0x14
<br/>0x15
<br/>0x16
<br/>0x17
<br/>0x18
</td>
<td align="left"><a href="#prop-IE154_NETWORK_LIST">IE154_NETWORK_LIST</a>[3]</td>
<td>0xff
<br/>0xff
<br/>0xff
<br/>0xfe
<br/>0x00
<br/>0x0f
<td align="left">Configure PAN ID, node ID and channel ID</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-MBUS">MBUS</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0x70</td>
<td>0x00
</td>
<td align="left"><a href="#prop-MBUS_FRAME">MBUS_FRAME</a></td>
<td>0x00
<td align="left">Controls data frame format and encoding.</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-PTI">PTI</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0xf0</td>
<td>0x00
</td>
<td align="left"><a href="#prop-PTI_CTL">PTI_CTL</a></td>
<td>0x80
<td align="left">Packet Trace Interface control fields.</td></tr>
<tr><td>0xf0</td>
<td>0x01
<br/>0x02
</td>
<td align="left"><a href="#prop-PTI_BAUD">PTI_BAUD</a></td>
<td>0x13
<br/>0x88
<td align="left">Desired baud rate for the PTI interface.</td></tr>
<tr><td>0xf0</td>
<td>0x03
</td>
<td align="left"><a href="#prop-PTI_LOG_EN">PTI_LOG_EN</a></td>
<td>0x00
<td align="left">Enables what the PTI logs.</td></tr>
<tr><td>0xf0</td>
<td>0x04
</td>
<td align="left"><a href="#prop-PTI_LOG_EN_2">PTI_LOG_EN_2</a></td>
<td>0x00
<td align="left">Enables what the PTI logs.</td></tr>
</tbody>
<thead><tr><th colspan="5"><a href="#pgrp-OTP_VARS">OTP_VARS</a></th></tr>
<tr><td>Group</td><td>Number</td><td>Name</td><td>Default</td><td>Summary</td></tr>
</thead><tbody>
<tr><td>0xf2</td>
<td>0x00
<br/>0x01
</td>
<td align="left"><a href="#prop-OTP_VARS_SPI_ACTIVE_SEQ_DELAY">OTP_VARS_SPI_ACTIVE_SEQ_DELAY</a></td>
<td>0x01
<br/>0xf4
<td align="left">Sequencer delay from SPI active to ready.</td></tr>
<tr><td>0xf2</td>
<td>0x02
</td>
<td align="left"><a href="#prop-OTP_VARS_TX_TUNE_SEQ_DELAY">OTP_VARS_TX_TUNE_SEQ_DELAY</a></td>
<td>0x4b
<td align="left">Sequencer delay from TX tune to TX.</td></tr>
<tr><td>0xf2</td>
<td>0x03
</td>
<td align="left"><a href="#prop-OTP_VARS_READY_SEQ_DELAY">OTP_VARS_READY_SEQ_DELAY</a></td>
<td>0x96
<td align="left">Sequencer delay from ready to TX.</td></tr>
<tr><td>0xf2</td>
<td>0x04
<br/>0x05
</td>
<td align="left"><a href="#prop-OTP_VARS_RX_SEQ_DELAY">OTP_VARS_RX_SEQ_DELAY</a></td>
<td>0x00
<br/>0x96
<td align="left">Sequencer delay from rx to tx.</td></tr>
<tr><td>0xf2</td>
<td>0x06
</td>
<td align="left"><a href="#prop-OTP_VARS_CAL_ENABLE_VTR">OTP_VARS_CAL_ENABLE_VTR</a></td>
<td>0x61
<td align="left">VTR calibration enables.</td></tr>
<tr><td>0xf2</td>
<td>0x07
</td>
<td align="left"><a href="#prop-OTP_VARS_CAL_ENABLE">OTP_VARS_CAL_ENABLE</a></td>
<td>0x45
<td align="left">Calibration enables.</td></tr>
<tr><td>0xf2</td>
<td>0x08
</td>
<td align="left"><a href="#prop-OTP_VARS_VTR_VCO_V3P3_TARGET_VOLTAGE">OTP_VARS_VTR_VCO_V3P3_TARGET_VOLTAGE</a></td>
<td>0xfb
<td align="left">VCO v3.3 target voltage.</td></tr>
<tr><td>0xf2</td>
<td>0x09
</td>
<td align="left"><a href="#prop-OTP_VARS_VTR_VCO_V1P5_TARGET_VOLTAGE">OTP_VARS_VTR_VCO_V1P5_TARGET_VOLTAGE</a></td>
<td>0x08
<td align="left">VCO v1.5 target voltage.</td></tr>
<tr><td>0xf2</td>
<td>0x0a
</td>
<td align="left"><a href="#prop-OTP_VARS_VTR_VCO_LADR_TARGET_VOLTAGE">OTP_VARS_VTR_VCO_LADR_TARGET_VOLTAGE</a></td>
<td>0x01
<td align="left">VCO Ladder target voltage.</td></tr>
<tr><td>0xf2</td>
<td>0x0b
<br/>0x0c
</td>
<td align="left"><a href="#prop-OTP_VARS_RC_CAL_ADC_TARGET">OTP_VARS_RC_CAL_ADC_TARGET</a></td>
<td>0x7d
<br/>0x00
<td align="left">RC32K ADC calibration target.</td></tr>
<tr><td>0xf2</td>
<td>0x0d
</td>
<td align="left"><a href="#prop-OTP_VARS_RC_CAL">OTP_VARS_RC_CAL</a></td>
<td>0x04
<td align="left">RC32k calibration parameters.</td></tr>
<tr><td>0xf2</td>
<td>0x0e
</td>
<td align="left"><a href="#prop-OTP_VARS_RC_CAL1">OTP_VARS_RC_CAL1</a></td>
<td>0x44
<td align="left">RC32k calibration parameters.</td></tr>
<tr><td>0xf2</td>
<td>0x0f
</td>
<td align="left"><a href="#prop-OTP_VARS_RC_CAL2">OTP_VARS_RC_CAL2</a></td>
<td>0x42
<td align="left">RC32k calibration parameters.</td></tr>
<tr><td>0xf2</td>
<td>0x10
</td>
<td align="left"><a href="#prop-OTP_VARS_BOOT_OSC_CAL">OTP_VARS_BOOT_OSC_CAL</a></td>
<td>0x09
<td align="left">Boot osc calibration parameters.</td></tr>
<tr><td>0xf2</td>
<td>0x11
</td>
<td align="left"><a href="#prop-OTP_VARS_BOOT_OSC_CAL1">OTP_VARS_BOOT_OSC_CAL1</a></td>
<td>0x02
<td align="left">Boot osc calibration parameters.</td></tr>
<tr><td>0xf2</td>
<td>0x12
</td>
<td align="left"><a href="#prop-OTP_VARS_AUXADC_TEMP_SLOPE">OTP_VARS_AUXADC_TEMP_SLOPE</a></td>
<td>0x63
<td align="left"></td></tr>
<tr><td>0xf2</td>
<td>0x13
</td>
<td align="left"><a href="#prop-OTP_VARS_AUXADC_TEMP_INTERCEPT">OTP_VARS_AUXADC_TEMP_INTERCEPT</a></td>
<td>0x4a
<td align="left"></td></tr>
<tr><td>0xf2</td>
<td>0x14
</td>
<td align="left"><a href="#prop-OTP_VARS_AUXADC_SY_GAIN_ERROR">OTP_VARS_AUXADC_SY_GAIN_ERROR</a></td>
<td>0x00
<td align="left">AuxADC gain adjustment, 8-bit signed.</td></tr>
<tr><td>0xf2</td>
<td>0x15
</td>
<td align="left"><a href="#prop-OTP_VARS_AUXADC_SY_OFFSET_ERROR">OTP_VARS_AUXADC_SY_OFFSET_ERROR</a></td>
<td>0x00
<td align="left">AuxADC offset adjustment, 8-bit signed.</td></tr>
<tr><td>0xf2</td>
<td>0x16
</td>
<td align="left"><a href="#prop-OTP_VARS_ADC_VOLTAGE_TRIM">OTP_VARS_ADC_VOLTAGE_TRIM</a></td>
<td>0x0f
<td align="left"></td></tr>
<tr><td>0xf2</td>
<td>0x17
</td>
<td align="left"><a href="#prop-OTP_VARS_VCO_LOAD5_XO">OTP_VARS_VCO_LOAD5_XO</a></td>
<td>0x04
<td align="left"></td></tr>
<tr><td>0xf2</td>
<td>0x18
</td>
<td align="left"><a href="#prop-OTP_VARS_REG_RXFE_LPF">OTP_VARS_REG_RXFE_LPF</a></td>
<td>0x35
<td align="left"></td></tr>
<tr><td>0xf2</td>
<td>0x19
</td>
<td align="left"><a href="#prop-OTP_VARS_REG_ADC_LPF">OTP_VARS_REG_ADC_LPF</a></td>
<td>0x40
<td align="left"></td></tr>
<tr><td>0xf2</td>
<td>0x1a
</td>
<td align="left"><a href="#prop-OTP_VARS_REG_CLKGEN_COM_LPF">OTP_VARS_REG_CLKGEN_COM_LPF</a></td>
<td>0x10
<td align="left">CLKGEN ACONFIG register value.</td></tr>
<tr><td>0xf2</td>
<td>0x1b
</td>
<td align="left"><a href="#prop-OTP_VARS_REG_FBDIV_LPF">OTP_VARS_REG_FBDIV_LPF</a></td>
<td>0x01
<td align="left">Low power mode feedback divider regulator settings.</td></tr>
<tr><td>0xf2</td>
<td>0x1c
</td>
<td align="left"><a href="#prop-OTP_VARS_REG_CLKGEN_TX_LPF">OTP_VARS_REG_CLKGEN_TX_LPF</a></td>
<td>0x10
<td align="left">CLKGEN ACONFIG register value.</td></tr>
<tr><td>0xf2</td>
<td>0x1d
</td>
<td align="left"><a href="#prop-OTP_VARS_REG_CLKGEN_COM_LOW_BAND">OTP_VARS_REG_CLKGEN_COM_LOW_BAND</a></td>
<td>0x10
<td align="left">CLKGEN ACONFIG register value.</td></tr>
<tr><td>0xf2</td>
<td>0x1e
</td>
<td align="left"><a href="#prop-OTP_VARS_REG_RXFE_HPF">OTP_VARS_REG_RXFE_HPF</a></td>
<td>0x40
<td align="left"></td></tr>
<tr><td>0xf2</td>
<td>0x1f
</td>
<td align="left"><a href="#prop-OTP_VARS_REG_ADC_HPF">OTP_VARS_REG_ADC_HPF</a></td>
<td>0x40
<td align="left"></td></tr>
<tr><td>0xf2</td>
<td>0x20
</td>
<td align="left"><a href="#prop-OTP_VARS_REG_CLKGEN_COM_HPF">OTP_VARS_REG_CLKGEN_COM_HPF</a></td>
<td>0x30
<td align="left">CLKGEN ACONFIG register value.</td></tr>
<tr><td>0xf2</td>
<td>0x21
</td>
<td align="left"><a href="#prop-OTP_VARS_REG_FBDIV_HPF">OTP_VARS_REG_FBDIV_HPF</a></td>
<td>0x04
<td align="left"></td></tr>
<tr><td>0xf2</td>
<td>0x22
</td>
<td align="left"><a href="#prop-OTP_VARS_REG_CLKGEN_TX_HPF">OTP_VARS_REG_CLKGEN_TX_HPF</a></td>
<td>0x20
<td align="left">CLKGEN ACONFIG register value.</td></tr>
<tr><td>0xf2</td>
<td>0x23
</td>
<td align="left"><a href="#prop-OTP_VARS_ETSI_CFG0">OTP_VARS_ETSI_CFG0</a></td>
<td>0x09
<td align="left">ETSI configuration register.</td></tr>
<tr><td>0xf2</td>
<td>0x24
</td>
<td align="left"><a href="#prop-OTP_VARS_ETSI_CFG1">OTP_VARS_ETSI_CFG1</a></td>
<td>0x40
<td align="left">ETSI configuration register.</td></tr>
<tr><td>0xf2</td>
<td>0x25
</td>
<td align="left"><a href="#prop-OTP_VARS_ETSI_CFG2">OTP_VARS_ETSI_CFG2</a></td>
<td>0x3c
<td align="left">ETSI configuration register.</td></tr>
<tr><td>0xf2</td>
<td>0x26
</td>
<td align="left"><a href="#prop-OTP_VARS_PH_WATERMARK">OTP_VARS_PH_WATERMARK</a></td>
<td>0x42
<td align="left"></td></tr>
<tr><td>0xf2</td>
<td>0x27
</td>
<td align="left"><a href="#prop-OTP_VARS_PROC_MON_RCAL">OTP_VARS_PROC_MON_RCAL</a></td>
<td>0x00
<td align="left"></td></tr>
<tr><td>0xf2</td>
<td>0x28
</td>
<td align="left"><a href="#prop-OTP_VARS_REF_CAL_BANDGAP">OTP_VARS_REF_CAL_BANDGAP</a></td>
<td>0x00
<td align="left">REF_CAL bandgap calibration.</td></tr>
<tr><td>0xf2</td>
<td>0x29
</td>
<td align="left"><a href="#prop-OTP_VARS_VCO_ADJ">OTP_VARS_VCO_ADJ</a></td>
<td>0x00
<td align="left"></td></tr>
<tr><td>0xf2</td>
<td>0x2a
</td>
<td align="left"><a href="#prop-OTP_VARS_MISC_DELAY">OTP_VARS_MISC_DELAY</a></td>
<td>0x00
<td align="left">Miscellaneous delay values.</td></tr>
<tr><td>0xf2</td>
<td>0x2b
</td>
<td align="left"><a href="#prop-OTP_VARS_CAL_MAN">OTP_VARS_CAL_MAN</a></td>
<td>0x02
<td align="left">Controls rssi latching and temperature-based calibration enables (cal_man).</td></tr>
<tr><td>0xf2</td>
<td>0x2c
</td>
<td align="left"><a href="#prop-OTP_VARS_REG_CLKGEN_COM_HPF_HOT">OTP_VARS_REG_CLKGEN_COM_HPF_HOT</a></td>
<td>0x00
<td align="left">Under high temperature, CLKGEN ACONFIG register value.</td></tr>
<tr><td>0xf2</td>
<td>0x2d
</td>
<td align="left"><a href="#prop-OTP_VARS_VTR_VCO_V1P5_TARGET_VOLTAGE_HOT">OTP_VARS_VTR_VCO_V1P5_TARGET_VOLTAGE_HOT</a></td>
<td>0x08
<td align="left">Under high temperature, VCO v1.5 target voltage.</td></tr>
<tr><td>0xf2</td>
<td>0x2e
</td>
<td align="left"><a href="#prop-OTP_VARS_REG_FBDIV_COM_HOT">OTP_VARS_REG_FBDIV_COM_HOT</a></td>
<td>0x00
<td align="left">Under high temperature, this value is used in place of reg_fbdiv_com_.</td></tr>
<tr><td>0xf2</td>
<td>0x2f
</td>
<td align="left"><a href="#prop-OTP_VARS_REG_DIG_LOAD_ACFG_DIGREG_HOT">OTP_VARS_REG_DIG_LOAD_ACFG_DIGREG_HOT</a></td>
<td>0x20
<td align="left">Under high temperature, this value is used in place of reg_dig_load_acfg_digreg aconfig init value.</td></tr>
<tr><td>0xf2</td>
<td>0x30
</td>
<td align="left"><a href="#prop-OTP_VARS_CAL_MAN_ONLINE_TEMP_DELTA">OTP_VARS_CAL_MAN_ONLINE_TEMP_DELTA</a></td>
<td>0x06
<td align="left">Sets limit for online recalibration control loop. A value of 6 equates to 19.16 degrees Celsius.</td></tr>
<tr><td>0xf2</td>
<td>0x31
</td>
<td align="left"><a href="#prop-OTP_VARS_CAL_MAN_OFFLINE_TEMP_DELTA">OTP_VARS_CAL_MAN_OFFLINE_TEMP_DELTA</a></td>
<td>0x12
<td align="left">Sets limit for user interupt meaning it is time to recalibrate offline. A value of 18 equates to 57.49 degrees Celsius.</td></tr>
<tr><td>0xf2</td>
<td>0x32
</td>
<td align="left"><a href="#prop-OTP_VARS_CAL_MAN_LOWER_TEMP_TARGET">OTP_VARS_CAL_MAN_LOWER_TEMP_TARGET</a></td>
<td>0x14
<td align="left">Sets limit for switching to use lower temperature settings. A value of 20 equates to 89.39 degrees Celsius.</td></tr>
<tr><td>0xf2</td>
<td>0x33
</td>
<td align="left"><a href="#prop-OTP_VARS_CAL_MAN_HIGHER_TEMP_TARGET">OTP_VARS_CAL_MAN_HIGHER_TEMP_TARGET</a></td>
<td>0x16
<td align="left">Sets limit for switching to use higher temperature settings. A value of 22 equates to 95.78 degrees Celsius.</td></tr>
<tr><td>0xf2</td>
<td>0x34
</td>
<td align="left"><a href="#prop-OTP_VARS_NVM_TIMING">OTP_VARS_NVM_TIMING</a></td>
<td>0x0b
<td align="left">Configure the timing used when copying out of nvm.</td></tr>
<tr><td>0xf2</td>
<td>0x35
</td>
<td align="left"><a href="#prop-OTP_VARS_SPARE_35">OTP_VARS_SPARE_35</a></td>
<td>0x00
<td align="left">For use in patches.</td></tr>
<tr><td>0xf2</td>
<td>0x36
</td>
<td align="left"><a href="#prop-OTP_VARS_SPARE_36">OTP_VARS_SPARE_36</a></td>
<td>0x00
<td align="left">For use in patches.</td></tr>
</tbody>
</table>
<hr />
<h2><a name="cmd-details">Command Details</a></h2>
<h3><a name="cset-BOOT_COMMANDS">BOOT_COMMANDS</a></h3>
<h4><a name="cmd-POWER_UP">POWER_UP</a></h4>
<ul>
<li>Number: 0x02</li>
<li>Summary: Command to power-up the device and select the operational mode and functionality.</li>
<li>Purpose:</li>
<ul><li>
This command MUST be issued to complete the power-up sequence for the device.                  The POWER_UP command is issued after the POR sequence has completed                 AND CTS is high.  CTS can be polled using <a href="#cmd-READ_CMD_BUFF"><code>READ_CMD_BUFF</code></a>
.</li><li>
In the event that a patch is downloaded to the chip, the patch must be downloaded before the POWER_UP command is issued.</li><li>
Power-up is complete when the CTS is high.  This command may take longer to complete than other commands,                    as the chip also performs several internal calibrations.</li><li>
These calibrations include calibration of the boot clock oscillator and the 32kHz R-C oscillator against                    the crystal oscillator; it is therefore necessary to specify the frequency of the crystal oscillator through the XO_FREQ parameter.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">POWER_UP Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x02</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>BOOT_OPTIONS</b></td>
<td colspan="1">PATCH</td>
<td>0</td>
<td colspan="6">FUNC</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>XTAL_OPTIONS</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">TCXO</td>
</tr>
<tr><td>0x03</td>
<td rowspan="4"><b>XO_FREQ</b></td>
<td colspan="8">XO_FREQ[31:24]</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">XO_FREQ[23:16]</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">XO_FREQ[15:8]</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">XO_FREQ[7:0]</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">POWER_UP Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-POWER_UP%3ABOOT_OPTIONS">BOOT_OPTIONS</a><ul>
<li><a name="arg-POWER_UP%3APATCH">PATCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Select patch mode or normal boot mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NO_PATCH</td><td>0</td><td align="left">
<ul><li>
Power up into functional mode specified by FUNC parameter.</li></ul>
</td></tr>
<tr valign="top"><td align="left">PATCH</td><td>1</td><td align="left">
<ul><li>
Indicates a patch has been applied.  Validate patch matches the function selected (indicated by the FUNC parameter) and boot the device.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-POWER_UP%3AFUNC">FUNC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the functionality of the device by specifying the firmware image to be loaded upon boot-up. </li></ul>
</dd></dl>
<dl><dt>Comments:</dt><dd>
<ul><li>
Functional groups are divided by part family.  i.e. IE154 will always be 2 even if it is the only image avaliable.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">BOOT</td><td>0</td><td align="left">
<ul><li>
Stay in boot mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">PRO</td><td>1</td><td align="left">
<ul><li>
Power the chip up into EZRadio PRO functional mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154</td><td>2</td><td align="left">
<ul><li>
Power the chip up into IEEE 802.15.4 functional mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">MBUS</td><td>3</td><td align="left">
<ul><li>
Power the chip up into MBUS functional mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">EZRADIO</td><td>1</td><td align="left">
<ul><li>
Power the chip up into EZRadio functional mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LOADED</td><td>63</td><td align="left">
<ul><li>
Firmware image already loaded, just complete booting the device.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="arg-POWER_UP%3AXTAL_OPTIONS">XTAL_OPTIONS</a><ul>
<li><a name="arg-POWER_UP%3ATCXO">TCXO</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects if the reference oscillator signal is derived from an external TCXO (connected to the XIN pin),    or from the internal crystal oscillator in conjunction with a crystal blank (connected across the XIN/XOUT pins). </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">XTAL</td><td>0</td><td align="left">
<ul><li>
Reference signal is derived from the internal crystal oscillator.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TCXO</td><td>1</td><td align="left">
<ul><li>
Reference signal is derived from an external TCXO. </li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="arg-POWER_UP%3AXO_FREQ">XO_FREQ</a><ul>
<li><a name="arg-POWER_UP%3AXO_FREQ">XO_FREQ</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Specifies the frequency of the internal crystal oscillator or external TCXO in Hz.    The nominal value is 30000000 (30 MHz) = 0x01C9C380.
    </li><li>
This parameter is used during calibration of the Boot Clock Oscillator and 32kHz R-C Oscillator,    but is NOT used for calibration or tuning of the PLL Synthesizer. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U32</dd>
</dl>
<dl><dt>Min:</dt><dd>0x17d7840</dd></dl>
<dl><dt>Max:</dt><dd>0x1e84800</dd></dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-POWER_UP%3ACTS">CTS</a><ul>
<li><a name="reply-POWER_UP%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-RAM_TEST">RAM_TEST</a></h4>
<ul>
<li>Number: 0x03</li>
<li>Summary: Tests the contents and operation of RAM.</li>
<li>Purpose:</li>
<ul><li>
Calculate CRC of RAMs selected by MEMORY mask.  CRC is calculated before other operations are performed.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">RAM_TEST Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x03</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>OPERATION</b></td>
<td colspan="1">MCUPX_RAM_TEST</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CRC_EN</td>
</tr>
<tr><td>0x02</td>
<td rowspan="2"><b>CRC_START_ADDR</b></td>
<td colspan="8">CRC_START_ADDR[15:8]</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">CRC_START_ADDR[7:0]</td>
</tr>
<tr><td>0x04</td>
<td rowspan="2"><b>CRC_SIZE</b></td>
<td colspan="8">CRC_SIZE[15:8]</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">CRC_SIZE[7:0]</td>
</tr>
<tr><td>0x06</td>
<td rowspan="1"><b>RAM_TEST_FILL_BYTE</b></td>
<td colspan="8">RAM_TEST_FILL_BYTE</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">RAM_TEST Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>RESULT</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">RAM_TEST_PASS</td>
</tr>
<tr><td>0x02</td>
<td rowspan="2"><b>OTP_CRC</b></td>
<td colspan="8">OTP_CRC[15:8]</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">OTP_CRC[7:0]</td>
</tr>
<tr><td>0x04</td>
<td rowspan="2"><b>CRC</b></td>
<td colspan="8">CRC[15:8]</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">CRC[7:0]</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-RAM_TEST%3AOPERATION">OPERATION</a><ul>
<li><a name="arg-RAM_TEST%3AMCUPX_RAM_TEST">MCUPX_RAM_TEST</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, run RAM test on MCUPX RAM.  When tests are complete part should be reset.   Simple fills ram with alternating pattern of RAM_TEST_FILL_BYTE and ~RAM_TEST_FILL_BYTE.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="arg-RAM_TEST%3ACRC_EN">CRC_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, compute CRC started at CRC_START_ADDR over CRC_SIZE bytes.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-RAM_TEST%3ACRC_START_ADDR">CRC_START_ADDR</a><ul>
<li><a name="arg-RAM_TEST%3ACRC_START_ADDR">CRC_START_ADDR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Address to start CRC calculation at:              RAM starts at 0x4000 and is 2k in size,           ROM starts at 0x8000 and is 16k in size,          OTP starts at 0xC000 and is 8k in size</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-RAM_TEST%3ACRC_SIZE">CRC_SIZE</a><ul>
<li><a name="arg-RAM_TEST%3ACRC_SIZE">CRC_SIZE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Number of bytes to calculate CRC over.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-RAM_TEST%3ARAM_TEST_FILL_BYTE">RAM_TEST_FILL_BYTE</a><ul>
<li><a name="arg-RAM_TEST%3ARAM_TEST_FILL_BYTE">RAM_TEST_FILL_BYTE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Fill byte to run RAM test with.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-RAM_TEST%3ACTS">CTS</a><ul>
<li><a name="reply-RAM_TEST%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-RAM_TEST%3ARESULT">RESULT</a><ul>
<li><a name="reply-RAM_TEST%3ARAM_TEST_PASS">RAM_TEST_PASS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Indicates if the ram test passed or failed.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">FAILED</td><td>0</td><td align="left">
<ul><li>
RAM Test Failed.</li></ul>
</td></tr>
<tr valign="top"><td align="left">PASSED</td><td>1</td><td align="left">
<ul><li>
RAM Test Passed.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="reply-RAM_TEST%3AOTP_CRC">OTP_CRC</a><ul>
<li><a name="reply-RAM_TEST%3AOTP_CRC">OTP_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
CRC of application from OTP.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-RAM_TEST%3ACRC">CRC</a><ul>
<li><a name="reply-RAM_TEST%3ACRC">CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
CRC of selected memory.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-PATCH_IMAGE">PATCH_IMAGE</a></h4>
<ul>
<li>Number: 0x04</li>
<li>Summary: Loads image from NVM/ROM into RAM.</li>
<li>Purpose:</li>
<ul><li>
Loads the selected function into RAM for execution or patching.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">PATCH_IMAGE Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x04</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>FLAGS</b></td>
<td>0</td>
<td>0</td>
<td colspan="1">VERIFYCRC</td>
<td colspan="1">NONVM</td>
<td colspan="4">FUNC</td>
</tr>
<tr><td>0x02</td>
<td rowspan="2"><b>CRC</b></td>
<td colspan="8">CRC[15:8]</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">CRC[7:0]</td>
</tr>
<tr><td>0x04</td>
<td rowspan="1"><b>RESERVED1</b></td>
<td colspan="8">RESERVED1</td>
</tr>
<tr><td>0x05</td>
<td rowspan="1"><b>RESERVED2</b></td>
<td colspan="8">RESERVED2</td>
</tr>
<tr><td>0x06</td>
<td rowspan="1"><b>KEY1</b></td>
<td colspan="8">KEY1</td>
</tr>
<tr><td>0x07</td>
<td rowspan="1"><b>KEY2</b></td>
<td colspan="8">KEY2</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">PATCH_IMAGE Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-PATCH_IMAGE%3AFLAGS">FLAGS</a><ul>
<li><a name="arg-PATCH_IMAGE%3AVERIFYCRC">VERIFYCRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Verify CRC. If no match, do not load NVM and report error. Set in patches along with CRC.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="arg-PATCH_IMAGE%3ANONVM">NONVM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Do not load image from NVM, this is a full download.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="arg-PATCH_IMAGE%3AFUNC">FUNC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the image to load.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">BOOT</td><td>0</td><td align="left">
<ul><li>
Boot Loader - No image is loaded.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TRX</td><td>1</td><td align="left">
<ul><li>
Transceiver.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="arg-PATCH_IMAGE%3ACRC">CRC</a><ul>
<li><a name="arg-PATCH_IMAGE%3ACRC">CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
CRC value which the RAMs must match after the image is loaded. If VERIFYCRC is not set,  then the CRC supplied is ignored. If the CRC does not match,  no <a href="#cmd-PATCH_ARGS"><code>PATCH_ARGS</code></a>
, <a href="#cmd-PATCH_DATA"><code>PATCH_DATA</code></a>
, <a href="#cmd-PATCH_COPY"><code>PATCH_COPY</code></a>
 or <a href="#cmd-POWER_UP"><code>POWER_UP</code></a>
 commands will be accepted.  This condition can be cleared by sending another PATCH_IMAGE command with VERIFYCRC cleared.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-PATCH_IMAGE%3ARESERVED1">RESERVED1</a><ul>
<li><a name="arg-PATCH_IMAGE%3ARESERVED1">RESERVED1</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Not used in this product.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-PATCH_IMAGE%3ARESERVED2">RESERVED2</a><ul>
<li><a name="arg-PATCH_IMAGE%3ARESERVED2">RESERVED2</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Not used in this product.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-PATCH_IMAGE%3AKEY1">KEY1</a><ul>
<li><a name="arg-PATCH_IMAGE%3AKEY1">KEY1</a>
<dl><dt>Description:</dt><dd>
<ul><li>
decryption key1 for patch.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-PATCH_IMAGE%3AKEY2">KEY2</a><ul>
<li><a name="arg-PATCH_IMAGE%3AKEY2">KEY2</a>
<dl><dt>Description:</dt><dd>
<ul><li>
decryption key2 for patch.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-PATCH_IMAGE%3ACTS">CTS</a><ul>
<li><a name="reply-PATCH_IMAGE%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-PATCH_ARGS">PATCH_ARGS</a></h4>
<ul>
<li>Number: 0x05</li>
<li>Summary: *ENCRYPTED* Reserved command used for patch file downloads.</li>
<li>Purpose:</li>
<ul><li>
Initialize parameters for patching.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">PATCH_ARGS Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x05</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>PIP</b></td>
<td colspan="8">PIP</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>RESERVED1</b></td>
<td colspan="8">RESERVED1</td>
</tr>
<tr><td>0x03</td>
<td rowspan="2"><b>ADDR</b></td>
<td colspan="8">ADDR[15:8]</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">ADDR[7:0]</td>
</tr>
<tr><td>0x05</td>
<td rowspan="1"><b>RESERVED2</b></td>
<td colspan="8">RESERVED2</td>
</tr>
<tr><td>0x06</td>
<td rowspan="2"><b>CRC</b></td>
<td colspan="8">CRC[15:8]</td>
</tr>
<tr><td>0x07</td>
<td colspan="8">CRC[7:0]</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">PATCH_ARGS Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-PATCH_ARGS%3APIP">PIP</a><ul>
<li><a name="arg-PATCH_ARGS%3APIP">PIP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Patch In Progress. This bit is set in all but the final PATCH_ARGS command.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-PATCH_ARGS%3ARESERVED1">RESERVED1</a><ul>
<li><a name="arg-PATCH_ARGS%3ARESERVED1">RESERVED1</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Not used in this product.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-PATCH_ARGS%3AADDR">ADDR</a><ul>
<li><a name="arg-PATCH_ARGS%3AADDR">ADDR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Memory Controller destination address to write.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-PATCH_ARGS%3ARESERVED2">RESERVED2</a><ul>
<li><a name="arg-PATCH_ARGS%3ARESERVED2">RESERVED2</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Not used in this product.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-PATCH_ARGS%3ACRC">CRC</a><ul>
<li><a name="arg-PATCH_ARGS%3ACRC">CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Validates the data loaded from patch commands. If the CRC fails, no further <a href="#cmd-PATCH_DATA"><code>PATCH_DATA</code></a>
, <a href="#cmd-PATCH_ARGS"><code>PATCH_ARGS</code></a>
, <a href="#cmd-PATCH_COPY"><code>PATCH_COPY</code></a>
 or <a href="#cmd-POWER_UP"><code>POWER_UP</code></a>
 commands will be accepted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-PATCH_ARGS%3ACTS">CTS</a><ul>
<li><a name="reply-PATCH_ARGS%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed
                        execution and DATA[1..16] is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-PATCH_COPY">PATCH_COPY</a></h4>
<ul>
<li>Number: 0x06</li>
<li>Summary: *ENCRYPTED* Reserved command used for patch file downloads.</li>
<li>Purpose:</li>
<ul><li>
Patch RAM by copying from ROM/RAM/NVM to RAMs.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">PATCH_COPY Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x06</td>
</tr>
<tr><td>0x01</td>
<td rowspan="2"><b>SRC_ADDR</b></td>
<td colspan="8">SRC_ADDR[15:8]</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">SRC_ADDR[7:0]</td>
</tr>
<tr><td>0x03</td>
<td rowspan="2"><b>DST_ADDR</b></td>
<td colspan="8">DST_ADDR[15:8]</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">DST_ADDR[7:0]</td>
</tr>
<tr><td>0x05</td>
<td rowspan="2"><b>COUNT</b></td>
<td colspan="8">COUNT[15:8]</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">COUNT[7:0]</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">PATCH_COPY Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-PATCH_COPY%3ASRC_ADDR">SRC_ADDR</a><ul>
<li><a name="arg-PATCH_COPY%3ASRC_ADDR">SRC_ADDR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Memory Controller source address for copy.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-PATCH_COPY%3ADST_ADDR">DST_ADDR</a><ul>
<li><a name="arg-PATCH_COPY%3ADST_ADDR">DST_ADDR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Memory Controller destination address for copy.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-PATCH_COPY%3ACOUNT">COUNT</a><ul>
<li><a name="arg-PATCH_COPY%3ACOUNT">COUNT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Number of bytes to copy.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-PATCH_COPY%3ACTS">CTS</a><ul>
<li><a name="reply-PATCH_COPY%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-TEST_DATA">TEST_DATA</a></h4>
<ul>
<li>Number: 0x09</li>
<li>Summary: Read NVM Test Data block.</li>
<li>Purpose:</li>
<ul><li>
Reports Test Data block read from NVM.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">TEST_DATA Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x09</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>OFFSET</b></td>
<td colspan="8">OFFSET</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">TEST_DATA Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-TEST_DATA%3AOFFSET">OFFSET</a><ul>
<li><a name="arg-TEST_DATA%3AOFFSET">OFFSET</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Offset in test data block to begin reading at.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-TEST_DATA%3ACTS">CTS</a><ul>
<li><a name="reply-TEST_DATA%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-PATCH_COPY_2">PATCH_COPY_2</a></h4>
<ul>
<li>Number: 0x0a</li>
<li>Summary: *ENCRYPTED* Reserved command used for patch file downloads.</li>
<li>Purpose:</li>
<ul><li>
This is the same command as <a href="#cmd-PATCH_COPY"><code>PATCH_COPY</code></a>
 with the lsb of the CRC set.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">PATCH_COPY_2 Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x0a</td>
</tr>
<tr><td>0x01</td>
<td rowspan="2"><b>SRC_ADDR</b></td>
<td colspan="8">SRC_ADDR[15:8]</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">SRC_ADDR[7:0]</td>
</tr>
<tr><td>0x03</td>
<td rowspan="2"><b>DST_ADDR</b></td>
<td colspan="8">DST_ADDR[15:8]</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">DST_ADDR[7:0]</td>
</tr>
<tr><td>0x05</td>
<td rowspan="2"><b>COUNT</b></td>
<td colspan="8">COUNT[15:8]</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">COUNT[7:0]</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">PATCH_COPY_2 Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-PATCH_COPY_2%3ASRC_ADDR">SRC_ADDR</a><ul>
<li><a name="arg-PATCH_COPY_2%3ASRC_ADDR">SRC_ADDR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Memory Controller source address for copy.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-PATCH_COPY_2%3ADST_ADDR">DST_ADDR</a><ul>
<li><a name="arg-PATCH_COPY_2%3ADST_ADDR">DST_ADDR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Memory Controller destination address for copy.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-PATCH_COPY_2%3ACOUNT">COUNT</a><ul>
<li><a name="arg-PATCH_COPY_2%3ACOUNT">COUNT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Number of bytes to copy.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-PATCH_COPY_2%3ACTS">CTS</a><ul>
<li><a name="reply-PATCH_COPY_2%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-PATCH_DATA">PATCH_DATA</a></h4>
<ul>
<li>Number: 0xe0</li>
<li>Summary: *ENCRYPTED* Reserved command used for patch file downloads.</li>
<li>Purpose:</li>
<ul><li>
Load patch data. Technically, there are 16 PATCH_DATA commands 0x10-0x1F. CMD[2:0]  is the number of valid bytes in the command. CMD[3] is the LSB of the CRC.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">PATCH_DATA Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0xe0</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">PATCH_DATA Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-PATCH_DATA%3ACTS">CTS</a><ul>
<li><a name="reply-PATCH_DATA%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="cset-COMMON_COMMANDS">COMMON_COMMANDS</a></h3>
<h4><a name="cmd-NOP">NOP</a></h4>
<ul>
<li>Number: 0x00</li>
<li>Summary: No Operation command.</li>
<li>Purpose:</li>
<ul><li>
This command may be used to ensure that communication with the device has been established.     Upon receipt of this command, the chip performs no action except to return CTS.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">NOP Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x00</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">NOP Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-NOP%3ACTS">CTS</a><ul>
<li><a name="reply-NOP%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-PART_INFO">PART_INFO</a></h4>
<ul>
<li>Number: 0x01</li>
<li>Summary: Reports basic information about the device.</li>
<li>Purpose:</li>
<ul><li>
Returns Part Number, Part Version, ROM ID, etc.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">PART_INFO Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x01</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">PART_INFO Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>CHIPREV</b></td>
<td colspan="8">CHIPREV</td>
</tr>
<tr><td>0x02</td>
<td rowspan="2"><b>PART</b></td>
<td colspan="8">PART[15:8]</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">PART[7:0]</td>
</tr>
<tr><td>0x04</td>
<td rowspan="1"><b>PBUILD</b></td>
<td colspan="8">PBUILD</td>
</tr>
<tr><td>0x05</td>
<td rowspan="2"><b>ID</b></td>
<td colspan="8">ID[15:8]</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">ID[7:0]</td>
</tr>
<tr><td>0x07</td>
<td rowspan="1"><b>CUSTOMER</b></td>
<td colspan="8">CUSTOMER</td>
</tr>
<tr><td>0x08</td>
<td rowspan="1"><b>ROMID</b></td>
<td colspan="8">ROMID</td>
</tr>
<tr><td>0x09</td>
<td rowspan="1"><b>BOND</b></td>
<td colspan="8">BOND</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-PART_INFO%3ACTS">CTS</a><ul>
<li><a name="reply-PART_INFO%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-PART_INFO%3ACHIPREV">CHIPREV</a><ul>
<li><a name="reply-PART_INFO%3ACHIPREV">CHIPREV</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Chip Mask Revision.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-PART_INFO%3APART">PART</a><ul>
<li><a name="reply-PART_INFO%3APART">PART</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Part Number (e.g., si4461 will return - 0x4461).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-PART_INFO%3APBUILD">PBUILD</a><ul>
<li><a name="reply-PART_INFO%3APBUILD">PBUILD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Part Build.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-PART_INFO%3AID">ID</a><ul>
<li><a name="reply-PART_INFO%3AID">ID</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Id.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-PART_INFO%3ACUSTOMER">CUSTOMER</a><ul>
<li><a name="reply-PART_INFO%3ACUSTOMER">CUSTOMER</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Customer ID.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-PART_INFO%3AROMID">ROMID</a><ul>
<li><a name="reply-PART_INFO%3AROMID">ROMID</a>
<dl><dt>Description:</dt><dd>
<ul><li>
ROM Id.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-PART_INFO%3ABOND">BOND</a><ul>
<li><a name="reply-PART_INFO%3ABOND">BOND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Bond Option.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-FUNC_INFO">FUNC_INFO</a></h4>
<ul>
<li>Number: 0x10</li>
<li>Summary: Returns the Function revision information of the device.</li>
<li>Purpose:</li>
<ul><li>
Return Function revision numbers for currently loaded functional mode. Contrast with <a href="#cmd-PART_INFO"><code>PART_INFO</code></a>
.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">FUNC_INFO Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x10</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">FUNC_INFO Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>REVEXT</b></td>
<td colspan="8">REVEXT</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>REVBRANCH</b></td>
<td colspan="8">REVBRANCH</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>REVINT</b></td>
<td colspan="8">REVINT</td>
</tr>
<tr><td>0x04</td>
<td rowspan="2"><b>PATCH</b></td>
<td colspan="8">PATCH[15:8]</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">PATCH[7:0]</td>
</tr>
<tr><td>0x06</td>
<td rowspan="1"><b>FUNC</b></td>
<td colspan="8">FUNC</td>
</tr>
<tr><td>0x07</td>
<td rowspan="1"><b>SVNFLAGS</b></td>
<td>0</td>
<td>0</td>
<td colspan="2">LOCATION</td>
<td>0</td>
<td>0</td>
<td colspan="1">MIXEDREV</td>
<td colspan="1">LOCALMOD</td>
</tr>
<tr><td>0x08</td>
<td rowspan="4"><b>SVNREV</b></td>
<td colspan="8">SVNREV[31:24]</td>
</tr>
<tr><td>0x09</td>
<td colspan="8">SVNREV[23:16]</td>
</tr>
<tr><td>0x0a</td>
<td colspan="8">SVNREV[15:8]</td>
</tr>
<tr><td>0x0b</td>
<td colspan="8">SVNREV[7:0]</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-FUNC_INFO%3ACTS">CTS</a><ul>
<li><a name="reply-FUNC_INFO%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FUNC_INFO%3AREVEXT">REVEXT</a><ul>
<li><a name="reply-FUNC_INFO%3AREVEXT">REVEXT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
External revision number.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
<li><a name="reply-FUNC_INFO%3AREVBRANCH">REVBRANCH</a><ul>
<li><a name="reply-FUNC_INFO%3AREVBRANCH">REVBRANCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Branch revision number.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
<li><a name="reply-FUNC_INFO%3AREVINT">REVINT</a><ul>
<li><a name="reply-FUNC_INFO%3AREVINT">REVINT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Internal revision number.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
<li><a name="reply-FUNC_INFO%3APATCH">PATCH</a><ul>
<li><a name="reply-FUNC_INFO%3APATCH">PATCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
ID of applied patch. This is also the last 2 bytes in the associated patch file (*.csg).</li><li>
0x0000 = No patch applied.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FUNC_INFO%3AFUNC">FUNC</a><ul>
<li><a name="reply-FUNC_INFO%3AFUNC">FUNC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Current functional mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FUNC_INFO%3ASVNFLAGS">SVNFLAGS</a><ul>
<li><a name="reply-FUNC_INFO%3ALOCATION">LOCATION</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Trunk, Branch or Tag.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">TAG</td><td>0</td><td align="left">
<ul><li>
Built from a SVN Tag.</li></ul>
</td></tr>
<tr valign="top"><td align="left">BRANCH</td><td>1</td><td align="left">
<ul><li>
Built from a SVN Branch. MAJOR, MINOR and BUILD will be 0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TRUNK</td><td>2</td><td align="left">
<ul><li>
Built from the SVN Trunk. MAJOR, MINOR and BUILD will be 0.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="reply-FUNC_INFO%3AMIXEDREV">MIXEDREV</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, image has mixed revisions. MAJOR, MINOR and BUILD will be 0.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-FUNC_INFO%3ALOCALMOD">LOCALMOD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, image has local modifications. MAJOR, MINOR and BUILD will be 0.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FUNC_INFO%3ASVNREV">SVNREV</a><ul>
<li><a name="reply-FUNC_INFO%3ASVNREV">SVNREV</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Subversion revision image was built from.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U32</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-SET_PROPERTY">SET_PROPERTY</a></h4>
<ul>
<li>Number: 0x11</li>
<li>Summary: Sets the value of one or more properties.</li>
<li>Purpose:</li>
<ul><li>
This command sets the value of one or more properties.     Properties are similar to parameters passed to an API command, but are not expected to change frequently.     They are typically used to configure the operation of various internal circuit blocks.
    </li><li>
Properties may be controlled by higher layers of the user's software.     Setting some properties may not cause the device to take immediate action;     however, the property will take effect once a command which uses that property is issued.
    </li><li>
Properties that affect similar circuit blocks or functions     (e.g., MODEM or PA or SYNTH properties) are grouped together and share the same GROUP parameter value.      Each property within that GROUP has a different offset number or index.
    </li><li>
A single property may be configured by setting the NUM_PROPS parameter = 0x01,     setting the START_PROP parameter to the offset number of that particular property,     followed by a single data byte representing the desired value of the property.
    </li><li>
Multiple contiguous properties may be configured by setting the NUM_PROPS parameter equal to the number of desired properties,    setting the START_PROP parameter to the offset number of the first property within that contiguous block of properties,    followed by a string of data bytes representing the desired values of the properties.
    </li><li>
The maximum number of properties that may be set with a single SET_PROPERTY command is 12. </li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">SET_PROPERTY Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x11</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>GROUP</b></td>
<td colspan="8">GROUP</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>NUM_PROPS</b></td>
<td colspan="8">NUM_PROPS</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>START_PROP</b></td>
<td colspan="8">START_PROP</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">SET_PROPERTY Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-SET_PROPERTY%3AGROUP">GROUP</a><ul>
<li><a name="arg-SET_PROPERTY%3AGROUP">GROUP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the property group to be configured.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-SET_PROPERTY%3ANUM_PROPS">NUM_PROPS</a><ul>
<li><a name="arg-SET_PROPERTY%3ANUM_PROPS">NUM_PROPS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the number of contiguous properties to be written, starting at START_PROP.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x1</dd></dl>
<dl><dt>Max:</dt><dd>0xc</dd></dl>
</li>
</ul></li>
<li><a name="arg-SET_PROPERTY%3ASTART_PROP">START_PROP</a><ul>
<li><a name="arg-SET_PROPERTY%3ASTART_PROP">START_PROP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the offset number or index of the property within the specified group. The available properties are  determined by the part number and the <a href="#arg-POWER_UP%3AFUNC">POWER_UP:FUNC</a>
 selection.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-SET_PROPERTY%3ACTS">CTS</a><ul>
<li><a name="reply-SET_PROPERTY%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-GET_PROPERTY">GET_PROPERTY</a></h4>
<ul>
<li>Number: 0x12</li>
<li>Summary: Retrieves the value of one or more properties</li>
<li>Purpose:</li>
<ul><li>
This command retrieves the value of one or more properties.     Properties are similar to parameters passed to an API command, but are not expected to change frequently.     They are typically used to configure the operation of various internal circuit blocks.     The returned value represents the default property value upon <a href="#cmd-POWER_UP"><code>POWER_UP</code></a>
 or the value set previously with a <a href="#cmd-SET_PROPERTY"><code>SET_PROPERTY</code></a>
 command.
</li><li>
Properties that affect similar circuit blocks or functions (e.g., MODEM or PA or SYNTH properties)     are grouped together and share the same GROUP parameter value.    Each property within that GROUP has a different offset number or index.
    </li><li>
A single property may be retrieved by setting the NUM_PROPS parameter = 0x01     and setting the START_PROP parameter to the offset number of that particular property.     The first data byte of the reply stream represents the value of that property.
    </li><li>
Multiple contiguous properties may be retrieved by setting the NUM_PROPS parameter    equal to the number of desired properties and setting the START_PROP parameter to the    offset number of the first property within that contiguous block of properties.     The data bytes of the reply stream represent the values of the contiguous properties in sequential order of their offset number.
    </li><li>
The maximum number of properties that may be retrieved with a single GET_PROPERTY command is 16.
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">GET_PROPERTY Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x12</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>GROUP</b></td>
<td colspan="8">GROUP</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>NUM_PROPS</b></td>
<td colspan="8">NUM_PROPS</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>START_PROP</b></td>
<td colspan="8">START_PROP</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">GET_PROPERTY Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-GET_PROPERTY%3AGROUP">GROUP</a><ul>
<li><a name="arg-GET_PROPERTY%3AGROUP">GROUP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the property group to be retrieved.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-GET_PROPERTY%3ANUM_PROPS">NUM_PROPS</a><ul>
<li><a name="arg-GET_PROPERTY%3ANUM_PROPS">NUM_PROPS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the number of contiguous properties to be retrieved, starting at START_PROP.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x1</dd></dl>
<dl><dt>Max:</dt><dd>0x10</dd></dl>
</li>
</ul></li>
<li><a name="arg-GET_PROPERTY%3ASTART_PROP">START_PROP</a><ul>
<li><a name="arg-GET_PROPERTY%3ASTART_PROP">START_PROP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the offset number or index of the property within the specified group.    the available properties are determined by the part number and the <a href="#arg-POWER_UP%3AFUNC">POWER_UP:FUNC</a>
 selection</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-GET_PROPERTY%3ACTS">CTS</a><ul>
<li><a name="reply-GET_PROPERTY%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-GPIO_PIN_CFG">GPIO_PIN_CFG</a></h4>
<ul>
<li>Number: 0x13</li>
<li>Summary: Configures the GPIO pins.</li>
<li>Purpose:</li>
<ul><li>
The chip provides General Purpose Input/Output (GPIO) pins for handling a variety of signals.     This command is used to select the desired signal for each GPIO pin from an enumerated list of available signals.
    </li><li>
The drive strength is selectable for those pins configured as outputs.     The selected drive strength is applied simultaneously to all outputs;    it is currently not possible to individually configure each GPIO pin for different drive strengths.
    </li><li>
Each pin provides a weak pull-up resistor (~1 Megohm) that may be individually enabled or disabled.     It is recommended to disable the pull-up resistor when the pin is configured as an input and driven from an external source (other than an open-drain source).
    </li><li>
The pins referenced by this command share similar hardware characteristics (i.e., drive strength, pull-up resistors, input/output configurability)    but may provide access to different sets of signals.    Specifically, the NIRQ and SDO pins are not "signal equivalent" to the GPIO pins.
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">GPIO_PIN_CFG Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x13</td>
</tr>
<tr><td>0x05</td>
<td rowspan="1"><b>NIRQ</b></td>
<td>0</td>
<td colspan="1">PULL_CTL</td>
<td colspan="6">NIRQ_MODE</td>
</tr>
<tr><td>0x06</td>
<td rowspan="1"><b>SDO</b></td>
<td>0</td>
<td colspan="1">PULL_CTL</td>
<td colspan="6">SDO_MODE</td>
</tr>
<tr><td>0x07</td>
<td rowspan="1"><b>GEN_CONFIG</b></td>
<td>0</td>
<td colspan="2">DRV_STRENGTH</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">GPIO_PIN_CFG Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x05</td>
<td rowspan="1"><b>NIRQ</b></td>
<td colspan="1">NIRQ_STATE</td>
<td>0</td>
<td colspan="6">NIRQ_MODE</td>
</tr>
<tr><td>0x06</td>
<td rowspan="1"><b>SDO</b></td>
<td colspan="1">SDO_STATE</td>
<td>0</td>
<td colspan="6">SDO_MODE</td>
</tr>
<tr><td>0x07</td>
<td rowspan="1"><b>GEN_CONFIG</b></td>
<td>0</td>
<td colspan="2">DRV_STRENGTH</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-GPIO_PIN_CFG%3ANIRQ">NIRQ</a><ul>
<li><a name="arg-GPIO_PIN_CFG%3APULL_CTL">PULL_CTL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The pin pull-up control.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">PULL_DIS</td><td>0</td><td align="left">
<ul><li>
Disable pull-up resistor (recommended setting if the pin is driven from an external source, other than an open-drain source).</li></ul>
</td></tr>
<tr valign="top"><td align="left">PULL_EN</td><td>1</td><td align="left">
<ul><li>
Enable pull-up resistor.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-GPIO_PIN_CFG%3ANIRQ_MODE">NIRQ_MODE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The pin mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DONOTHING</td><td>0</td><td align="left">
<ul><li>
Behavior of this pin is not modified.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TRISTATE</td><td>1</td><td align="left">
<ul><li>
Input and output drivers disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DRIVE0</td><td>2</td><td align="left">
<ul><li>
Pin is configured as a CMOS output and driven low.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DRIVE1</td><td>3</td><td align="left">
<ul><li>
Pin is configured as a CMOS output and driven high.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INPUT</td><td>4</td><td align="left">
<ul><li>
Pin is configured as a CMOS input. This is used for all GPIO functions that require the pin to be an input (e.g., TXDATA input for TX Direct Mode).     However, configuration of this pin as an input does NOT additionally select which internal circuit receives that input;     that functionality is controlled by other properties, as appropriate.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIV_CLK</td><td>7</td><td align="left">
<ul><li>
Outputs the divided clock signal (or the divided boot clock signal in SPI ACTIVE state).  This output is               low while the chip is in SLEEP state as the source (e.g., the Xtal Oscillator) for the divided clock               signal is not running, and outputs the divided XtalOsc signal in all other states.               The divider is configured using the <a href="#field-GLOBAL_CLK_CFG%3ADIVIDED_CLK_SEL">GLOBAL_CLK_CFG:DIVIDED_CLK_SEL</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CTS</td><td>8</td><td align="left">
<ul><li>
Clear To Send signal.  This output goes high when the command handler is able to receive a new command, and is low otherwise.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SDO</td><td>11</td><td align="left">
<ul><li>
Outputs the Serial Data Out (SDO) signal for the SPI bus.</li></ul>
</td></tr>
<tr valign="top"><td align="left">POR</td><td>12</td><td align="left">
<ul><li>
This output goes low during Power-On Reset and goes high upon completion of POR.</li></ul>
</td></tr>
<tr valign="top"><td align="left">EN_PA</td><td>15</td><td align="left">
<ul><li>
This output goes high when the internal PA is enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_DATA_CLK</td><td>16</td><td align="left">
<ul><li>
Outputs the TX Data Clock signal.  This signal is a square wave at the selected TX data rate, and is intended for use in TX Direct Synchronous Mode (i.e., in conjunction with a pin configured for TX Data Input).</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_DATA_CLK</td><td>17</td><td align="left">
<ul><li>
Outputs the RX Data CLK signal.  This signal is nominally a square wave that is synchronized to the received data rate, and is typically used to latch the RX Data signal into the host MCU. </li></ul>
</td></tr>
<tr valign="top"><td align="left">EN_LNA</td><td>18</td><td align="left">
<ul><li>
This output goes low when the internal LNA is enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_DATA</td><td>19</td><td align="left">
<ul><li>
Outputs the TX data bits pulled from the TX FIFO and sent to the TX modulator.  This is an output signal (primarily for diagnostic purposes) and is NOT used as an input for TX Direct Sync/Async mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_DATA</td><td>20</td><td align="left">
<ul><li>
Outputs the demodulated RX Data stream, after synchronization and re-timing by the local RX Data Clock.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_RAW_DATA</td><td>21</td><td align="left">
<ul><li>
Outputs the demodulated RX Raw Data stream, prior to synchronization and re-timing by the local RX Data Clock.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ANTENNA_1_SW</td><td>22</td><td align="left">
<ul><li>
Antenna-1 Switch signal used for control of an RF switch during Antenna Diversity operation.  This signal normally assumes the complementary polarity of the Antenna-2 Switch signal (except during SLEEP state).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ANTENNA_2_SW</td><td>23</td><td align="left">
<ul><li>
Antenna-2 Switch signal used for control of an RF switch during Antenna Diversity operation.  This signal normally assumes the complementary polarity of the Antenna-1 Switch signal (except during SLEEP state).</li></ul>
</td></tr>
<tr valign="top"><td align="left">VALID_PREAMBLE</td><td>24</td><td align="left">
<ul><li>
This output goes high when a valid preamble is detected, and returns low after the packet is received or Sync Word timeout occurs.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INVALID_PREAMBLE</td><td>25</td><td align="left">
<ul><li>
Output low normally, pulses output high when the preamble is not                           detected within a period time (determined by <a href="#field-PREAMBLE_CONFIG_STD_2%3ARX_PREAMBLE_TIMEOUT">PREAMBLE_CONFIG_STD_2:RX_PREAMBLE_TIMEOUT</a>
)                           after the demodulator is enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SYNC_WORD_DETECT</td><td>26</td><td align="left">
<ul><li>
This output goes high when a Sync Word is detected, and returns low after the packet is received. </li></ul>
</td></tr>
<tr valign="top"><td align="left">CCA</td><td>27</td><td align="left">
<ul><li>
Clear Channel Assessment.  This output goes high when the Current RSSI signal exceeds the threshold                           value set by the <a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a>
 property, and is low when the Current RSSI is below threshold.                            This is a real-time (non-latched) signal.</li></ul>
</td></tr>
<tr valign="top"><td align="left">PKT_TRACE</td><td>29</td><td align="left">
<ul><li>
Outputs packet trace data when not in sleep state.  Output low when in sleep state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_RX_DATA_CLK</td><td>31</td><td align="left">
<ul><li>
Outputs TX or RX data CLK to be used in conjunction with TX or RX Data pin depending on the current power state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">NIRQ</td><td>39</td><td align="left">
<ul><li>
Active low interrupt signal.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="arg-GPIO_PIN_CFG%3ASDO">SDO</a><ul>
<li><a name="arg-GPIO_PIN_CFG%3APULL_CTL">PULL_CTL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The pin pull-up control.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">PULL_DIS</td><td>0</td><td align="left">
<ul><li>
Disable pull-up resistor (recommended setting if the pin is driven from an external source, other than an open-drain source).</li></ul>
</td></tr>
<tr valign="top"><td align="left">PULL_EN</td><td>1</td><td align="left">
<ul><li>
Enable pull-up resistor.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-GPIO_PIN_CFG%3ASDO_MODE">SDO_MODE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The pin mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DONOTHING</td><td>0</td><td align="left">
<ul><li>
Behavior of this pin is not modified.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TRISTATE</td><td>1</td><td align="left">
<ul><li>
Input and output drivers disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DRIVE0</td><td>2</td><td align="left">
<ul><li>
Pin is configured as a CMOS output and driven low.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DRIVE1</td><td>3</td><td align="left">
<ul><li>
Pin is configured as a CMOS output and driven high.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INPUT</td><td>4</td><td align="left">
<ul><li>
Pin is configured as a CMOS input. This is used for all GPIO functions that require the pin to be an input (e.g., TXDATA input for TX Direct Mode).     However, configuration of this pin as an input does NOT additionally select which internal circuit receives that input;     that functionality is controlled by other properties, as appropriate.</li></ul>
</td></tr>
<tr valign="top"><td align="left">32K_CLK</td><td>5</td><td align="left">
<ul><li>
Outputs 32 kHz clock selected using <a href="#field-GLOBAL_CLK_CFG%3ACLK_32K_SEL">GLOBAL_CLK_CFG:CLK_32K_SEL</a>
.                            Output low if the 32 kHz clock is not enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIV_CLK</td><td>7</td><td align="left">
<ul><li>
Outputs the divided clock signal (or the divided boot clock signal in SPI ACTIVE state).  This output is               low while the chip is in SLEEP state as the source (e.g., the Xtal Oscillator) for the divided clock               signal is not running, and outputs the divided XtalOsc signal in all other states.               The divider is configured using the <a href="#field-GLOBAL_CLK_CFG%3ADIVIDED_CLK_SEL">GLOBAL_CLK_CFG:DIVIDED_CLK_SEL</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CTS</td><td>8</td><td align="left">
<ul><li>
Clear To Send signal.  This output goes high when the command handler is able to receive a new command, and is low otherwise.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SDO</td><td>11</td><td align="left">
<ul><li>
Outputs the Serial Data Out (SDO) signal for the SPI bus.</li></ul>
</td></tr>
<tr valign="top"><td align="left">POR</td><td>12</td><td align="left">
<ul><li>
This output goes low during Power-On Reset and goes high upon completion of POR.</li></ul>
</td></tr>
<tr valign="top"><td align="left">WUT</td><td>14</td><td align="left">
<ul><li>
This output is normally low, and pulses high for 2<sup>(WUT_R+1)</sup> cycles of the 32 kHz clock upon expiration of the Wake-Up Timer (WUT). The 32 kHz clock must be enabled in order to use the WUT.  The period of the WUT is configured using <a href="#prop-GLOBAL_WUT_M">GLOBAL_WUT_M</a>
, and <a href="#prop-GLOBAL_WUT_R">GLOBAL_WUT_R</a>
 and enabled by <a href="#field-GLOBAL_WUT_CONFIG%3AWUT_EN">GLOBAL_WUT_CONFIG:WUT_EN</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">EN_PA</td><td>15</td><td align="left">
<ul><li>
This output goes high when the internal PA is enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_DATA_CLK</td><td>16</td><td align="left">
<ul><li>
Outputs the TX Data Clock signal.  This signal is a square wave at the selected TX data rate, and is intended for use in TX Direct Synchronous Mode (i.e., in conjunction with a pin configured for TX Data Input).</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_DATA_CLK</td><td>17</td><td align="left">
<ul><li>
Outputs the RX Data CLK signal.  This signal is nominally a square wave that is synchronized to the received data rate, and is typically used to latch the RX Data signal into the host MCU. </li></ul>
</td></tr>
<tr valign="top"><td align="left">EN_LNA</td><td>18</td><td align="left">
<ul><li>
This output goes low when the internal LNA is enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_DATA</td><td>19</td><td align="left">
<ul><li>
Outputs the TX data bits pulled from the TX FIFO and sent to the TX modulator.  This is an output signal (primarily for diagnostic purposes) and is NOT used as an input for TX Direct Sync/Async mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_DATA</td><td>20</td><td align="left">
<ul><li>
Outputs the demodulated RX Data stream, after synchronization and re-timing by the local RX Data Clock.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_RAW_DATA</td><td>21</td><td align="left">
<ul><li>
Outputs the demodulated RX Raw Data stream, prior to synchronization and re-timing by the local RX Data Clock.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ANTENNA_1_SW</td><td>22</td><td align="left">
<ul><li>
Antenna-1 Switch signal used for control of an RF switch during Antenna Diversity operation.  This signal normally assumes the complementary polarity of the Antenna-2 Switch signal (except during SLEEP state).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ANTENNA_2_SW</td><td>23</td><td align="left">
<ul><li>
Antenna-2 Switch signal used for control of an RF switch during Antenna Diversity operation.  This signal normally assumes the complementary polarity of the Antenna-1 Switch signal (except during SLEEP state).</li></ul>
</td></tr>
<tr valign="top"><td align="left">VALID_PREAMBLE</td><td>24</td><td align="left">
<ul><li>
This output goes high when a valid preamble is detected, and returns low after the packet is received or Sync Word timeout occurs.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INVALID_PREAMBLE</td><td>25</td><td align="left">
<ul><li>
Output low normally, pulses output high when the preamble is not                           detected within a period time (determined by <a href="#field-PREAMBLE_CONFIG_STD_2%3ARX_PREAMBLE_TIMEOUT">PREAMBLE_CONFIG_STD_2:RX_PREAMBLE_TIMEOUT</a>
)                           after the demodulator is enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SYNC_WORD_DETECT</td><td>26</td><td align="left">
<ul><li>
This output goes high when a Sync Word is detected, and returns low after the packet is received. </li></ul>
</td></tr>
<tr valign="top"><td align="left">CCA</td><td>27</td><td align="left">
<ul><li>
Clear Channel Assessment.  This output goes high when the Current RSSI signal exceeds the threshold                           value set by the <a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a>
 property, and is low when the Current RSSI is below threshold.                            This is a real-time (non-latched) signal.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="arg-GPIO_PIN_CFG%3AGEN_CONFIG">GEN_CONFIG</a><ul>
<li><a name="arg-GPIO_PIN_CFG%3ADRV_STRENGTH">DRV_STRENGTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
 Selects the level of drive strength for those GPIO/NIRQ/SDO pins configured as outputs.
    </li><li>
The selected level of drive strength is applied simultaneously to all output pins,    with the following exception: GPIO0 will exhibit a weaker drive strength than the other GPIO pins but only in the lowest drive strength setting;    its drive strength is the same for all other settings.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">HIGH</td><td>0</td><td align="left">
<ul><li>
GPIOs configured as outputs will have the highest drive strength.</li></ul>
</td></tr>
<tr valign="top"><td align="left">MED_HIGH</td><td>1</td><td align="left">
<ul><li>
GPIOs configured as outputs will have a medium drive strength.</li></ul>
</td></tr>
<tr valign="top"><td align="left">MED_LOW</td><td>2</td><td align="left">
<ul><li>
GPIOs configured as outputs will have a medium drive strength.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LOW</td><td>3</td><td align="left">
<ul><li>
GPIOs configured as outputs will have the lowest drive strength.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-GPIO_PIN_CFG%3ACTS">CTS</a><ul>
<li><a name="reply-GPIO_PIN_CFG%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GPIO_PIN_CFG%3ANIRQ">NIRQ</a><ul>
<li><a name="reply-GPIO_PIN_CFG%3ANIRQ_STATE">NIRQ_STATE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Reads back the logic level on the NIRQ pin.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">INACTIVE</td><td>0</td><td align="left">
<ul><li>
Pin was read back as a 0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ACTIVE</td><td>1</td><td align="left">
<ul><li>
Pin was read back as a 1.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="reply-GPIO_PIN_CFG%3ANIRQ_MODE">NIRQ_MODE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Reads back the enumeration of the currently selected function for the NIRQ pin.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DONOTHING</td><td>0</td><td align="left">
<ul><li>
Behavior of this pin is not modified.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TRISTATE</td><td>1</td><td align="left">
<ul><li>
Input and output drivers disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DRIVE0</td><td>2</td><td align="left">
<ul><li>
Pin is configured as a CMOS output and driven low.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DRIVE1</td><td>3</td><td align="left">
<ul><li>
Pin is configured as a CMOS output and driven high.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INPUT</td><td>4</td><td align="left">
<ul><li>
Pin is configured as a CMOS input. This is used for all GPIO functions that require the pin to be an input (e.g., TXDATA input for TX Direct Mode).     However, configuration of this pin as an input does NOT additionally select which internal circuit receives that input;     that functionality is controlled by other properties, as appropriate.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIV_CLK</td><td>7</td><td align="left">
<ul><li>
Outputs the divided clock signal (or the divided boot clock signal in SPI ACTIVE state).  This output is               low while the chip is in SLEEP state as the source (e.g., the Xtal Oscillator) for the divided clock               signal is not running, and outputs the divided XtalOsc signal in all other states.               The divider is configured using the <a href="#field-GLOBAL_CLK_CFG%3ADIVIDED_CLK_SEL">GLOBAL_CLK_CFG:DIVIDED_CLK_SEL</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CTS</td><td>8</td><td align="left">
<ul><li>
Clear To Send signal.  This output goes high when the command handler is able to receive a new command, and is low otherwise.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SDO</td><td>11</td><td align="left">
<ul><li>
Outputs the Serial Data Out (SDO) signal for the SPI bus.</li></ul>
</td></tr>
<tr valign="top"><td align="left">POR</td><td>12</td><td align="left">
<ul><li>
This output goes low during Power-On Reset and goes high upon completion of POR.</li></ul>
</td></tr>
<tr valign="top"><td align="left">EN_PA</td><td>15</td><td align="left">
<ul><li>
This output goes high when the internal PA is enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_DATA_CLK</td><td>16</td><td align="left">
<ul><li>
Outputs the TX Data Clock signal.  This signal is a square wave at the selected TX data rate, and is intended for use in TX Direct Synchronous Mode (i.e., in conjunction with a pin configured for TX Data Input).</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_DATA_CLK</td><td>17</td><td align="left">
<ul><li>
Outputs the RX Data CLK signal.  This signal is nominally a square wave that is synchronized to the received data rate, and is typically used to latch the RX Data signal into the host MCU. </li></ul>
</td></tr>
<tr valign="top"><td align="left">EN_LNA</td><td>18</td><td align="left">
<ul><li>
This output goes low when the internal LNA is enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_DATA</td><td>19</td><td align="left">
<ul><li>
Outputs the TX data bits pulled from the TX FIFO and sent to the TX modulator.  This is an output signal (primarily for diagnostic purposes) and is NOT used as an input for TX Direct Sync/Async mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_DATA</td><td>20</td><td align="left">
<ul><li>
Outputs the demodulated RX Data stream, after synchronization and re-timing by the local RX Data Clock.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_RAW_DATA</td><td>21</td><td align="left">
<ul><li>
Outputs the demodulated RX Raw Data stream, prior to synchronization and re-timing by the local RX Data Clock.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ANTENNA_1_SW</td><td>22</td><td align="left">
<ul><li>
Antenna-1 Switch signal used for control of an RF switch during Antenna Diversity operation.  This signal normally assumes the complementary polarity of the Antenna-2 Switch signal (except during SLEEP state).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ANTENNA_2_SW</td><td>23</td><td align="left">
<ul><li>
Antenna-2 Switch signal used for control of an RF switch during Antenna Diversity operation.  This signal normally assumes the complementary polarity of the Antenna-1 Switch signal (except during SLEEP state).</li></ul>
</td></tr>
<tr valign="top"><td align="left">VALID_PREAMBLE</td><td>24</td><td align="left">
<ul><li>
This output goes high when a valid preamble is detected, and returns low after the packet is received or Sync Word timeout occurs.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INVALID_PREAMBLE</td><td>25</td><td align="left">
<ul><li>
Output low normally, pulses output high when the preamble is not                           detected within a period time (determined by <a href="#field-PREAMBLE_CONFIG_STD_2%3ARX_PREAMBLE_TIMEOUT">PREAMBLE_CONFIG_STD_2:RX_PREAMBLE_TIMEOUT</a>
)                           after the demodulator is enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SYNC_WORD_DETECT</td><td>26</td><td align="left">
<ul><li>
This output goes high when a Sync Word is detected, and returns low after the packet is received. </li></ul>
</td></tr>
<tr valign="top"><td align="left">CCA</td><td>27</td><td align="left">
<ul><li>
Clear Channel Assessment.  This output goes high when the Current RSSI signal exceeds the threshold                           value set by the <a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a>
 property, and is low when the Current RSSI is below threshold.                            This is a real-time (non-latched) signal.</li></ul>
</td></tr>
<tr valign="top"><td align="left">PKT_TRACE</td><td>29</td><td align="left">
<ul><li>
Outputs packet trace data when not in sleep state.  Output low when in sleep state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_RX_DATA_CLK</td><td>31</td><td align="left">
<ul><li>
Outputs TX or RX data CLK to be used in conjunction with TX or RX Data pin depending on the current power state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">NIRQ</td><td>39</td><td align="left">
<ul><li>
Active low interrupt signal.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="reply-GPIO_PIN_CFG%3ASDO">SDO</a><ul>
<li><a name="reply-GPIO_PIN_CFG%3ASDO_STATE">SDO_STATE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Reads back the logic level on the SDO pin.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">INACTIVE</td><td>0</td><td align="left">
<ul><li>
Pin was read back as a 0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ACTIVE</td><td>1</td><td align="left">
<ul><li>
Pin was read back as a 1.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="reply-GPIO_PIN_CFG%3ASDO_MODE">SDO_MODE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Reads back the enumeration of the currently selected function for the SDO pin.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DONOTHING</td><td>0</td><td align="left">
<ul><li>
Behavior of this pin is not modified.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TRISTATE</td><td>1</td><td align="left">
<ul><li>
Input and output drivers disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DRIVE0</td><td>2</td><td align="left">
<ul><li>
Pin is configured as a CMOS output and driven low.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DRIVE1</td><td>3</td><td align="left">
<ul><li>
Pin is configured as a CMOS output and driven high.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INPUT</td><td>4</td><td align="left">
<ul><li>
Pin is configured as a CMOS input. This is used for all GPIO functions that require the pin to be an input (e.g., TXDATA input for TX Direct Mode).     However, configuration of this pin as an input does NOT additionally select which internal circuit receives that input;     that functionality is controlled by other properties, as appropriate.</li></ul>
</td></tr>
<tr valign="top"><td align="left">32K_CLK</td><td>5</td><td align="left">
<ul><li>
Outputs 32 kHz clock selected using <a href="#field-GLOBAL_CLK_CFG%3ACLK_32K_SEL">GLOBAL_CLK_CFG:CLK_32K_SEL</a>
.                            Output low if the 32 kHz clock is not enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIV_CLK</td><td>7</td><td align="left">
<ul><li>
Outputs the divided clock signal (or the divided boot clock signal in SPI ACTIVE state).  This output is               low while the chip is in SLEEP state as the source (e.g., the Xtal Oscillator) for the divided clock               signal is not running, and outputs the divided XtalOsc signal in all other states.               The divider is configured using the <a href="#field-GLOBAL_CLK_CFG%3ADIVIDED_CLK_SEL">GLOBAL_CLK_CFG:DIVIDED_CLK_SEL</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CTS</td><td>8</td><td align="left">
<ul><li>
Clear To Send signal.  This output goes high when the command handler is able to receive a new command, and is low otherwise.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SDO</td><td>11</td><td align="left">
<ul><li>
Outputs the Serial Data Out (SDO) signal for the SPI bus.</li></ul>
</td></tr>
<tr valign="top"><td align="left">POR</td><td>12</td><td align="left">
<ul><li>
This output goes low during Power-On Reset and goes high upon completion of POR.</li></ul>
</td></tr>
<tr valign="top"><td align="left">WUT</td><td>14</td><td align="left">
<ul><li>
This output is normally low, and pulses high for 2<sup>(WUT_R+1)</sup> cycles of the 32 kHz clock upon expiration of the Wake-Up Timer (WUT). The 32 kHz clock must be enabled in order to use the WUT.  The period of the WUT is configured using <a href="#prop-GLOBAL_WUT_M">GLOBAL_WUT_M</a>
, and <a href="#prop-GLOBAL_WUT_R">GLOBAL_WUT_R</a>
 and enabled by <a href="#field-GLOBAL_WUT_CONFIG%3AWUT_EN">GLOBAL_WUT_CONFIG:WUT_EN</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">EN_PA</td><td>15</td><td align="left">
<ul><li>
This output goes high when the internal PA is enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_DATA_CLK</td><td>16</td><td align="left">
<ul><li>
Outputs the TX Data Clock signal.  This signal is a square wave at the selected TX data rate, and is intended for use in TX Direct Synchronous Mode (i.e., in conjunction with a pin configured for TX Data Input).</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_DATA_CLK</td><td>17</td><td align="left">
<ul><li>
Outputs the RX Data CLK signal.  This signal is nominally a square wave that is synchronized to the received data rate, and is typically used to latch the RX Data signal into the host MCU. </li></ul>
</td></tr>
<tr valign="top"><td align="left">EN_LNA</td><td>18</td><td align="left">
<ul><li>
This output goes low when the internal LNA is enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_DATA</td><td>19</td><td align="left">
<ul><li>
Outputs the TX data bits pulled from the TX FIFO and sent to the TX modulator.  This is an output signal (primarily for diagnostic purposes) and is NOT used as an input for TX Direct Sync/Async mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_DATA</td><td>20</td><td align="left">
<ul><li>
Outputs the demodulated RX Data stream, after synchronization and re-timing by the local RX Data Clock.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_RAW_DATA</td><td>21</td><td align="left">
<ul><li>
Outputs the demodulated RX Raw Data stream, prior to synchronization and re-timing by the local RX Data Clock.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ANTENNA_1_SW</td><td>22</td><td align="left">
<ul><li>
Antenna-1 Switch signal used for control of an RF switch during Antenna Diversity operation.  This signal normally assumes the complementary polarity of the Antenna-2 Switch signal (except during SLEEP state).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ANTENNA_2_SW</td><td>23</td><td align="left">
<ul><li>
Antenna-2 Switch signal used for control of an RF switch during Antenna Diversity operation.  This signal normally assumes the complementary polarity of the Antenna-1 Switch signal (except during SLEEP state).</li></ul>
</td></tr>
<tr valign="top"><td align="left">VALID_PREAMBLE</td><td>24</td><td align="left">
<ul><li>
This output goes high when a valid preamble is detected, and returns low after the packet is received or Sync Word timeout occurs.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INVALID_PREAMBLE</td><td>25</td><td align="left">
<ul><li>
Output low normally, pulses output high when the preamble is not                           detected within a period time (determined by <a href="#field-PREAMBLE_CONFIG_STD_2%3ARX_PREAMBLE_TIMEOUT">PREAMBLE_CONFIG_STD_2:RX_PREAMBLE_TIMEOUT</a>
)                           after the demodulator is enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SYNC_WORD_DETECT</td><td>26</td><td align="left">
<ul><li>
This output goes high when a Sync Word is detected, and returns low after the packet is received. </li></ul>
</td></tr>
<tr valign="top"><td align="left">CCA</td><td>27</td><td align="left">
<ul><li>
Clear Channel Assessment.  This output goes high when the Current RSSI signal exceeds the threshold                           value set by the <a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a>
 property, and is low when the Current RSSI is below threshold.                            This is a real-time (non-latched) signal.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="reply-GPIO_PIN_CFG%3AGEN_CONFIG">GEN_CONFIG</a><ul>
<li><a name="reply-GPIO_PIN_CFG%3ADRV_STRENGTH">DRV_STRENGTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Reads back the enumeration of the currently selected drive strength.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">HIGH</td><td>0</td><td align="left">
<ul><li>
GPIOs configured as outputs will have the highest drive strength.</li></ul>
</td></tr>
<tr valign="top"><td align="left">MED_HIGH</td><td>1</td><td align="left">
<ul><li>
GPIOs configured as outputs will have a medium drive strength.</li></ul>
</td></tr>
<tr valign="top"><td align="left">MED_LOW</td><td>2</td><td align="left">
<ul><li>
GPIOs configured as outputs will have a medium drive strength.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LOW</td><td>3</td><td align="left">
<ul><li>
GPIOs configured as outputs will have the lowest drive strength.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-FIFO_INFO">FIFO_INFO</a></h4>
<ul>
<li>Number: 0x15</li>
<li>Summary: Access the current byte counts in the TX and RX FIFOs, and provide for resetting the FIFOs.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for two separate 64-byte FIFO memories for the purpose of storing transmit and receive data.     (When the <a href="#field-GLOBAL_CONFIG%3AFIFO_MODE">GLOBAL_CONFIG:FIFO_MODE</a>
 bit is set, these two FIFOs are combined into a single 129-byte shared FIFO.)</li><li>
The reply stream for this command returns the current number of received bytes stored in the RX FIFO,    and the number of remaining empty bytes in the TX FIFO.
    </li><li>
The command may also be used to reset the individual FIFOs.     This is typically used for error recovery (e.g., after encountering a CRC error in RX mode).     Any valid data that has not yet been retrieved from the RX FIFO will be lost as a result of a reset;    it is recommended to read such data prior to a reset.    The FIFOs do not need to be reset prior to initial use after power-up.
    </li><li>
The FIFO reset function (if enabled) is processed prior to returning the byte count in the FIFOs.     Thus the reply stream to a <a href="#cmd-FIFO_INFO"><code>FIFO_INFO</code></a>
 command that resets the FIFOs will return byte counts that indicate the FIFOs are empty.
    </li><li>
A FIFO reset command should not be sent while actively receiving or transmitting a packet,    as this may corrupt the index pointers into the FIFOs and result in loss of stored information.
    </li><li>
The FIFO:TX and FIFO:RX bits are self-clearing;    that is, there is no need to send the command twice     (e.g., with the reset bits set the first time, and cleared the second time). </li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">FIFO_INFO Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x15</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>FIFO</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">RX</td>
<td colspan="1">TX</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">FIFO_INFO Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>RX_FIFO_COUNT</b></td>
<td colspan="8">RX_FIFO_COUNT</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>TX_FIFO_SPACE</b></td>
<td colspan="8">TX_FIFO_SPACE</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-FIFO_INFO%3AFIFO">FIFO</a><ul>
<li><a name="arg-FIFO_INFO%3ARX">RX</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Resets the RX FIFO.
    </li><li>
 The RX FIFO mode specified in property <a href="#field-GLOBAL_CONFIG%3AFIFO_MODE">GLOBAL_CONFIG:FIFO_MODE</a>
 will be effective after reset.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">FALSE</td><td>0</td><td align="left">
<ul><li>
Do not reset the RX data FIFO.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TRUE</td><td>1</td><td align="left">
<ul><li>
Reset the RX data FIFO.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-FIFO_INFO%3ATX">TX</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Resets the TX FIFO.
    </li><li>
 The TX FIFO mode specified in property <a href="#field-GLOBAL_CONFIG%3AFIFO_MODE">GLOBAL_CONFIG:FIFO_MODE</a>
 will be effective after reset.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">FALSE</td><td>0</td><td align="left">
<ul><li>
Do not reset the TX data FIFO.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TRUE</td><td>1</td><td align="left">
<ul><li>
Reset the TX data FIFO.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-FIFO_INFO%3ACTS">CTS</a><ul>
<li><a name="reply-FIFO_INFO%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FIFO_INFO%3ARX_FIFO_COUNT">RX_FIFO_COUNT</a><ul>
<li><a name="reply-FIFO_INFO%3ARX_FIFO_COUNT">RX_FIFO_COUNT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Returns the number of received bytes currently stored in the RX FIFO.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FIFO_INFO%3ATX_FIFO_SPACE">TX_FIFO_SPACE</a><ul>
<li><a name="reply-FIFO_INFO%3ATX_FIFO_SPACE">TX_FIFO_SPACE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Returns the number of empty bytes (i.e., space) currently available in the TX FIFO.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-WAIT_PROPERTY_PROCESSED">WAIT_PROPERTY_PROCESSED</a></h4>
<ul>
<li>Number: 0x1b</li>
<li>Summary: Holds CTS low until all property writes are processed.</li>
<li>Purpose:</li>
<ul><li>
This command may be used to ensure that a property write has been
              committed before other commands can be sent.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">WAIT_PROPERTY_PROCESSED Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x1b</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">WAIT_PROPERTY_PROCESSED Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-WAIT_PROPERTY_PROCESSED%3ACTS">CTS</a><ul>
<li><a name="reply-WAIT_PROPERTY_PROCESSED%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-GET_INT_STATUS">GET_INT_STATUS</a></h4>
<ul>
<li>Number: 0x20</li>
<li>Summary: Returns the interrupt status of ALL the possible interrupt events (both STATUS and PENDING).  Optionally, it may be used to clear latched (PENDING) interrupt events.</li>
<li>Purpose:</li>
<ul><li>
Returns the current interrupt status of ALL the possible interrupt events (both STATUS and PENDING) and optionally clears PENDING interrupts.</li><li>
STATUS indicates the current state of an internal interrupt event such as preamble/sync word detection, packet sent/received, etc.  For example, PREAMBLE_DETECT is low before detection of a valid preamble, but goes high when the preamble arrives and is successfully detected.  STATUS is cleared automatically upon termination or cessation of the corresponding internal interrupt event.</li><li>
PENDING simply latches the rising edge of the corresponding STATUS, and does not change until cleared by a <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 command (or <a href="#cmd-GET_CHIP_STATUS"><code>GET_CHIP_STATUS</code></a>
, <a href="#cmd-GET_PH_STATUS"><code>GET_PH_STATUS</code></a>
, <a href="#cmd-GET_MODEM_STATUS"><code>GET_MODEM_STATUS</code></a>
).  For example, PREAMBLE_DETECT_PEND is low before detection of a valid preamble, goes high with PREAMBLE_DETECT, and remains high until cleared.</li><li>
It is possible to poll for interrupts by reading the STATUS and PENDING response bytes, as they are always up-to-date.  Additionally, PENDING interrupts may generate a HW interrupt on the NIRQ output pin, if the interrupt is enabled via <a href="#prop-INT_CTL_ENABLE">INT_CTL_ENABLE</a>
, <a href="#prop-INT_CTL_PH_ENABLE">INT_CTL_PH_ENABLE</a>
, <a href="#prop-INT_CTL_MODEM_ENABLE">INT_CTL_MODEM_ENABLE</a>
, and <a href="#prop-INT_CTL_CHIP_ENABLE">INT_CTL_CHIP_ENABLE</a>
 properties.</li><li>
Sending the <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 command with NO input parameters results in clearing all of the PENDING interrupts.</li><li>
When PENDING interrupts are being cleared, the reply stream reflects their status prior to clearing.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">GET_INT_STATUS Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x20</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>PH_CLR_PEND</b></td>
<td colspan="1">FILTER_MATCH_PEND_CLR</td>
<td colspan="1">FILTER_MISS_PEND_CLR</td>
<td colspan="1">PACKET_SENT_PEND_CLR</td>
<td colspan="1">PACKET_RX_PEND_CLR</td>
<td colspan="1">CRC_ERROR_PEND_CLR</td>
<td colspan="1">ALT_CRC_ERROR_PEND_CLR</td>
<td colspan="1">TX_FIFO_ALMOST_EMPTY_PEND_CLR</td>
<td colspan="1">RX_FIFO_ALMOST_FULL_PEND_CLR</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>MODEM_CLR_PEND</b></td>
<td colspan="1">RSSI_LATCH_PEND_CLR</td>
<td colspan="1">POSTAMBLE_DETECT_PEND_CLR</td>
<td colspan="1">INVALID_SYNC_PEND_CLR</td>
<td colspan="1">RSSI_JUMP_PEND_CLR</td>
<td colspan="1">RSSI_PEND_CLR</td>
<td colspan="1">INVALID_PREAMBLE_PEND_CLR</td>
<td colspan="1">PREAMBLE_DETECT_PEND_CLR</td>
<td colspan="1">SYNC_DETECT_PEND_CLR</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>CHIP_CLR_PEND</b></td>
<td>0</td>
<td colspan="1">CAL_PEND_CLR</td>
<td colspan="1">FIFO_UNDERFLOW_OVERFLOW_ERROR_PEND_CLR</td>
<td colspan="1">STATE_CHANGE_PEND_CLR</td>
<td colspan="1">CMD_ERROR_PEND_CLR</td>
<td colspan="1">CHIP_READY_PEND_CLR</td>
<td colspan="1">LOW_BATT_PEND_CLR</td>
<td colspan="1">WUT_PEND_CLR</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">GET_INT_STATUS Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>INT_PEND</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CHIP_INT_PEND</td>
<td colspan="1">MODEM_INT_PEND</td>
<td colspan="1">PH_INT_PEND</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>INT_STATUS</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CHIP_INT_STATUS</td>
<td colspan="1">MODEM_INT_STATUS</td>
<td colspan="1">PH_INT_STATUS</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>PH_PEND</b></td>
<td colspan="1">FILTER_MATCH_PEND</td>
<td colspan="1">FILTER_MISS_PEND</td>
<td colspan="1">PACKET_SENT_PEND</td>
<td colspan="1">PACKET_RX_PEND</td>
<td colspan="1">CRC_ERROR_PEND</td>
<td colspan="1">ALT_CRC_ERROR_PEND</td>
<td colspan="1">TX_FIFO_ALMOST_EMPTY_PEND</td>
<td colspan="1">RX_FIFO_ALMOST_FULL_PEND</td>
</tr>
<tr><td>0x04</td>
<td rowspan="1"><b>PH_STATUS</b></td>
<td colspan="1">FILTER_MATCH</td>
<td colspan="1">FILTER_MISS</td>
<td colspan="1">PACKET_SENT</td>
<td colspan="1">PACKET_RX</td>
<td colspan="1">CRC_ERROR</td>
<td colspan="1">ALT_CRC_ERROR</td>
<td colspan="1">TX_FIFO_ALMOST_EMPTY</td>
<td colspan="1">RX_FIFO_ALMOST_FULL</td>
</tr>
<tr><td>0x05</td>
<td rowspan="1"><b>MODEM_PEND</b></td>
<td colspan="1">RSSI_LATCH_PEND</td>
<td colspan="1">POSTAMBLE_DETECT_PEND</td>
<td colspan="1">INVALID_SYNC_PEND</td>
<td colspan="1">RSSI_JUMP_PEND</td>
<td colspan="1">RSSI_PEND</td>
<td colspan="1">INVALID_PREAMBLE_PEND</td>
<td colspan="1">PREAMBLE_DETECT_PEND</td>
<td colspan="1">SYNC_DETECT_PEND</td>
</tr>
<tr><td>0x06</td>
<td rowspan="1"><b>MODEM_STATUS</b></td>
<td colspan="1">RSSI_LATCH</td>
<td colspan="1">POSTAMBLE_DETECT</td>
<td colspan="1">INVALID_SYNC</td>
<td colspan="1">RSSI_JUMP</td>
<td colspan="1">RSSI</td>
<td colspan="1">INVALID_PREAMBLE</td>
<td colspan="1">PREAMBLE_DETECT</td>
<td colspan="1">SYNC_DETECT</td>
</tr>
<tr><td>0x07</td>
<td rowspan="1"><b>CHIP_PEND</b></td>
<td>0</td>
<td colspan="1">CAL_PEND</td>
<td colspan="1">FIFO_UNDERFLOW_OVERFLOW_ERROR_PEND</td>
<td colspan="1">STATE_CHANGE_PEND</td>
<td colspan="1">CMD_ERROR_PEND</td>
<td colspan="1">CHIP_READY_PEND</td>
<td colspan="1">LOW_BATT_PEND</td>
<td colspan="1">WUT_PEND</td>
</tr>
<tr><td>0x08</td>
<td rowspan="1"><b>CHIP_STATUS</b></td>
<td>0</td>
<td colspan="1">CAL</td>
<td colspan="1">FIFO_UNDERFLOW_OVERFLOW_ERROR</td>
<td colspan="1">STATE_CHANGE</td>
<td colspan="1">CMD_ERROR</td>
<td colspan="1">CHIP_READY</td>
<td colspan="1">LOW_BATT</td>
<td colspan="1">WUT</td>
</tr>
<tr><td>0x09</td>
<td rowspan="1"><b>INFO_FLAGS</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CAL_TYPE</td>
<td colspan="1">SYNC_TRIGGER</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-GET_INT_STATUS%3APH_CLR_PEND">PH_CLR_PEND</a><ul>
<li><a name="arg-GET_INT_STATUS%3AFILTER_MATCH_PEND_CLR">FILTER_MATCH_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending FILTER_MATCH interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3AFILTER_MISS_PEND_CLR">FILTER_MISS_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending FILTER_MISS interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3APACKET_SENT_PEND_CLR">PACKET_SENT_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending PACKET_SENT interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3APACKET_RX_PEND_CLR">PACKET_RX_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending PACKET_RX interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3ACRC_ERROR_PEND_CLR">CRC_ERROR_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending CRC_ERROR interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3AALT_CRC_ERROR_PEND_CLR">ALT_CRC_ERROR_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending ALT_CRC_ERROR interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3ATX_FIFO_ALMOST_EMPTY_PEND_CLR">TX_FIFO_ALMOST_EMPTY_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending TX_FIFO_ALMOST_EMPTY interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3ARX_FIFO_ALMOST_FULL_PEND_CLR">RX_FIFO_ALMOST_FULL_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RX_FIFO_ALMOST_FULL interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-GET_INT_STATUS%3AMODEM_CLR_PEND">MODEM_CLR_PEND</a><ul>
<li><a name="arg-GET_INT_STATUS%3ARSSI_LATCH_PEND_CLR">RSSI_LATCH_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RSSI_LATCH interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3APOSTAMBLE_DETECT_PEND_CLR">POSTAMBLE_DETECT_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending POSTAMBLE_DETECT interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3AINVALID_SYNC_PEND_CLR">INVALID_SYNC_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending INVALID_SYNC interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3ARSSI_JUMP_PEND_CLR">RSSI_JUMP_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RSSI_JUMP interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3ARSSI_PEND_CLR">RSSI_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RSSI interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3AINVALID_PREAMBLE_PEND_CLR">INVALID_PREAMBLE_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending INVALID_PREAMBLE interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3APREAMBLE_DETECT_PEND_CLR">PREAMBLE_DETECT_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending PREAMBLE_DETECT interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3ASYNC_DETECT_PEND_CLR">SYNC_DETECT_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending SYNC_DETECT interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-GET_INT_STATUS%3ACHIP_CLR_PEND">CHIP_CLR_PEND</a><ul>
<li><a name="arg-GET_INT_STATUS%3ACAL_PEND_CLR">CAL_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending CAL interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3AFIFO_UNDERFLOW_OVERFLOW_ERROR_PEND_CLR">FIFO_UNDERFLOW_OVERFLOW_ERROR_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending FIFO_UNDERFLOW_OVERFLOW_ERROR interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3ASTATE_CHANGE_PEND_CLR">STATE_CHANGE_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending STATE_CHANGE interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3ACMD_ERROR_PEND_CLR">CMD_ERROR_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending CMD_ERROR interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3ACHIP_READY_PEND_CLR">CHIP_READY_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending CHIP_READY interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3ALOW_BATT_PEND_CLR">LOW_BATT_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending LOW_BATT interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_INT_STATUS%3AWUT_PEND_CLR">WUT_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending WUT interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-GET_INT_STATUS%3ACTS">CTS</a><ul>
<li><a name="reply-GET_INT_STATUS%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_INT_STATUS%3AINT_PEND">INT_PEND</a><ul>
<li><a name="reply-GET_INT_STATUS%3ACHIP_INT_PEND">CHIP_INT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, an enabled CHIP_PEND bit is set indicating an interrupt is pending. See the <a href="#reply-GET_INT_STATUS%3ACHIP_STATUS">GET_INT_STATUS:CHIP_STATUS</a>
 field for the triggering events within the Chip Status Interrupt group.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3AMODEM_INT_PEND">MODEM_INT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, an enabled MODEM_PEND bit is set indicating an interrupt is pending. See the <a href="#reply-GET_INT_STATUS%3AMODEM_STATUS">GET_INT_STATUS:MODEM_STATUS</a>
 field for the triggering events within the Modem Interrupt group.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3APH_INT_PEND">PH_INT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, an enabled PH_PEND bit is set indicating an interrupt is pending. See the <a href="#reply-GET_INT_STATUS%3APH_STATUS">GET_INT_STATUS:PH_STATUS</a>
 field for the triggering events within the Packet Handler Interrupt group.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_INT_STATUS%3AINT_STATUS">INT_STATUS</a><ul>
<li><a name="reply-GET_INT_STATUS%3ACHIP_INT_STATUS">CHIP_INT_STATUS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, the Chip Status Interrupt group has an interrupt pending. See the <a href="#reply-GET_INT_STATUS%3ACHIP_STATUS">GET_INT_STATUS:CHIP_STATUS</a>
 field for the triggering events within the Chip Status Interrupt group.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3AMODEM_INT_STATUS">MODEM_INT_STATUS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, the Modem Interrupt group has an interrupt pending. See the <a href="#reply-GET_INT_STATUS%3AMODEM_STATUS">GET_INT_STATUS:MODEM_STATUS</a>
 field for the triggering events within the Modem Interrupt group.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3APH_INT_STATUS">PH_INT_STATUS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, the Packet Handler Interrupt group has an interrupt pending. See the <a href="#reply-GET_INT_STATUS%3APH_STATUS">GET_INT_STATUS:PH_STATUS</a>
 field for the triggering events within the Packet Handler Interrupt group.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_INT_STATUS%3APH_PEND">PH_PEND</a><ul>
<li><a name="reply-GET_INT_STATUS%3AFILTER_MATCH_PEND">FILTER_MATCH_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the FILTER_MATCH status bit has been detected and therefore a FILTER_MATCH interrupt is pending.  See associated FILTER_MATCH status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3AFILTER_MISS_PEND">FILTER_MISS_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the FILTER_MISS status bit has been detected and therefore a FILTER_MISS interrupt is pending.  See associated FILTER_MISS status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3APACKET_SENT_PEND">PACKET_SENT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the PACKET_SENT status bit has been detected and therefore a PACKET_SENT interrupt is pending.  See associated PACKET_SENT status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3APACKET_RX_PEND">PACKET_RX_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the PACKET_RX status bit has been detected and therefore a PACKET_RX interrupt is pending.  See associated PACKET_RX status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ACRC_ERROR_PEND">CRC_ERROR_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the CRC_ERROR status bit has been detected and therefore a CRC_ERROR interrupt is pending.  See associated CRC_ERROR status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3AALT_CRC_ERROR_PEND">ALT_CRC_ERROR_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the ALT_CRC_ERROR status bit has been detected and therefore a ALT_CRC_ERROR interrupt is pending.  See associated ALT_CRC_ERROR status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ATX_FIFO_ALMOST_EMPTY_PEND">TX_FIFO_ALMOST_EMPTY_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the TX_FIFO_ALMOST_EMPTY status bit has been detected and therefore a TX_FIFO_ALMOST_EMPTY interrupt is pending.  See associated TX_FIFO_ALMOST_EMPTY status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ARX_FIFO_ALMOST_FULL_PEND">RX_FIFO_ALMOST_FULL_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RX_FIFO_ALMOST_FULL status bit has been detected and therefore a RX_FIFO_ALMOST_FULL interrupt is pending.  See associated RX_FIFO_ALMOST_FULL status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_INT_STATUS%3APH_STATUS">PH_STATUS</a><ul>
<li><a name="reply-GET_INT_STATUS%3AFILTER_MATCH">FILTER_MATCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate the incoming packet matched filter.  Cleared upon entry into RX state, or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3AFILTER_MISS">FILTER_MISS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate the incoming packet was discarded because filter did not match.  Cleared upon entry into RX state, or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3APACKET_SENT">PACKET_SENT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate that data bytes in the TX FIFO were transmitted successfully.  Cleared upon entry into TX state.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3APACKET_RX">PACKET_RX</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate that the expected number of data bytes have been successfully received and placed in the RX FIFO.  All enabled Packet Handler functions (e.g., CRC check, Filter Matching) must be successfully completed in order to generate a PACKET_RX interrupt.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ACRC_ERROR">CRC_ERROR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate that the received CRC checksum byte(s) do not match the calculated CRC checksum value.  Cleared upon entry into RX state or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3AALT_CRC_ERROR">ALT_CRC_ERROR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate that the received CRC checksum byte(s) do not match the calculated alternate CRC checksum value. For the difference between the two CRC engines (CRC, ALT_CRC), see <a href="#prop-PKT_CRC_CONFIG">PKT_CRC_CONFIG</a>
 property.  Cleared upon entry into RX state or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ATX_FIFO_ALMOST_EMPTY">TX_FIFO_ALMOST_EMPTY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate that the amount of space in the TX FIFO is equal to or greater than the <a href="#prop-PKT_TX_THRESHOLD">PKT_TX_THRESHOLD</a>
 value. This interrupt may be used to signal the host MCU to store more data bytes into the TX FIFO,    thus providing a means for handling packets with lengths greater than the size of the TX FIFO (i.e., 64 bytes, or 129 bytes in shared FIFO mode). Cleared if the amount of space in the TX FIFO is more than the <a href="#prop-PKT_TX_THRESHOLD">PKT_TX_THRESHOLD</a>
 value. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ARX_FIFO_ALMOST_FULL">RX_FIFO_ALMOST_FULL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate that the number of bytes stored in the RX FIFO is equal to or greater than the <a href="#prop-PKT_RX_THRESHOLD">PKT_RX_THRESHOLD</a>
 value. This interrupt may be used to signal the host MCU to read more data bytes from the RX FIFO,    thus providing a means for handling packets with lengths greater than the size of the RX FIFO (i.e., 64 bytes, or 129 bytes in shared FIFO mode). Cleared if the amount of data in the RX FIFO is less than the <a href="#prop-PKT_RX_THRESHOLD">PKT_RX_THRESHOLD</a>
 value. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_INT_STATUS%3AMODEM_PEND">MODEM_PEND</a><ul>
<li><a name="reply-GET_INT_STATUS%3ARSSI_LATCH_PEND">RSSI_LATCH_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RSSI_LATCH status bit has been detected and therefore a RSSI_LATCH interrupt is pending.  See associated RSSI_LATCH status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3APOSTAMBLE_DETECT_PEND">POSTAMBLE_DETECT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the POSTAMBLE_DETECT status bit has been detected and therefore a POSTAMBLE_DETECT interrupt is pending.  See associated POSTAMBLE_DETECT status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3AINVALID_SYNC_PEND">INVALID_SYNC_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the INVALID_SYNC status bit has been detected and therefore a INVALID_SYNC interrupt is pending.  See associated INVALID_SYNC status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ARSSI_JUMP_PEND">RSSI_JUMP_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RSSI_JUMP status bit has been detected and therefore a RSSI_JUMP interrupt is pending.  See associated RSSI_JUMP status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ARSSI_PEND">RSSI_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RSSI status bit has been detected and therefore a RSSI interrupt is pending.  See associated RSSI status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3AINVALID_PREAMBLE_PEND">INVALID_PREAMBLE_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the INVALID_PREAMBLE status bit has been detected and therefore a INVALID_PREAMBLE interrupt is pending.  See associated INVALID_PREAMBLE status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3APREAMBLE_DETECT_PEND">PREAMBLE_DETECT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the PREAMBLE_DETECT status bit has been detected and therefore a PREAMBLE_DETECT interrupt is pending.  See associated PREAMBLE_DETECT status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ASYNC_DETECT_PEND">SYNC_DETECT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the SYNC_DETECT status bit has been detected and therefore a SYNC_DETECT interrupt is pending.  See associated SYNC_DETECT status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_INT_STATUS%3AMODEM_STATUS">MODEM_STATUS</a><ul>
<li><a name="reply-GET_INT_STATUS%3ARSSI_LATCH">RSSI_LATCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set if the latched RSSI value (defined in <a href="#prop-MODEM_RSSI_CONTROL">MODEM_RSSI_CONTROL</a>
 has exceeded the threshold value defined in the <a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a>
 property.  Cleared upon entry into RX state or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3APOSTAMBLE_DETECT">POSTAMBLE_DETECT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set if 1-4 bytes of received data matches the pattern of bits defined in the POSTAMBLE_PATTERN_XX properties.  Postamble detection must also be enabled in the <a href="#prop-PREAMBLE_POSTAMBLE_CONFIG">PREAMBLE_POSTAMBLE_CONFIG</a>
 property.  Cleared upon entry into RX, or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3AINVALID_SYNC">INVALID_SYNC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Self clearing signal that pulses high when a valid Sync Word (matching the pattern of bits defined in the SYNC_BITS_XX properties)    was not detected within the allowed search timeout period.      If configured to receive a standard preamble, the search timeout period is Sync Word Length + 4bits.      If configured to receive a non-standard preamble, the search timeout period is defined by the <a href="#prop-PREAMBLE_TX_LENGTH">PREAMBLE_TX_LENGTH</a>
 property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ARSSI_JUMP">RSSI_JUMP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Self clearing signal that pulses high when the Current RSSI value jumps by more than the threshold value defined in the <a href="#prop-MODEM_RSSI_JUMP_THRESH">MODEM_RSSI_JUMP_THRESH</a>
 property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ARSSI">RSSI</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set if the current RSSI value has exceeded the threshold value defined in the <a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a>
 property.Cleared upon entry into RX state or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3AINVALID_PREAMBLE">INVALID_PREAMBLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Self clearing signal that pulses high indicating that one of the following has occurred:     a) a valid Preamble was not detected within the allowed search timeout period, or     b) the Latched RSSI value is below the <a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a>
 value and the chip has been enabled to check for this condition.     The search timeout period for Preamble is configured in <a href="#prop-PREAMBLE_CONFIG_STD_2">PREAMBLE_CONFIG_STD_2</a>
,     while the CHECK_THRESH_AT_LATCH function is configured in <a href="#prop-MODEM_RSSI_CONTROL">MODEM_RSSI_CONTROL</a>
.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3APREAMBLE_DETECT">PREAMBLE_DETECT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set when a pattern of bits was received that matched the expected Preamble pattern.  If configured to receive a standard preamble, the expected pattern of bits is '...010101...' with a threshold length defined in <a href="#prop-PREAMBLE_CONFIG_STD_1">PREAMBLE_CONFIG_STD_1</a>
.  If configured to receive a non-standard preamble, the expected pattern of bits is defined by the PREAMBLE_PATTERN_XX and the <a href="#prop-PREAMBLE_CONFIG_NSTD">PREAMBLE_CONFIG_NSTD</a>
 properties. Cleared when SYNC is detected, upon entering RX state, or RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ASYNC_DETECT">SYNC_DETECT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set when the received Sync Word pattern matched the pattern of bits defined in the <a href="#prop-SYNC_BITS">SYNC_BITS</a>
 property. If <a href="#field-SYNC_CONFIG2%3ADUAL_SYNC_EN">SYNC_CONFIG2:DUAL_SYNC_EN</a>
 is enabled, the pattern in <a href="#prop-SYNC_BITS2">SYNC_BITS2</a>
 is also used to match.  Cleared when a packet is received (valid or invalid), upon entry into RX state, or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_INT_STATUS%3ACHIP_PEND">CHIP_PEND</a><ul>
<li><a name="reply-GET_INT_STATUS%3ACAL_PEND">CAL_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the CAL status bit has been detected and therefore a CAL interrupt is pending.  See associated CAL status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3AFIFO_UNDERFLOW_OVERFLOW_ERROR_PEND">FIFO_UNDERFLOW_OVERFLOW_ERROR_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the FIFO_UNDERFLOW_OVERFLOW_ERROR status bit has been detected and therefore a FIFO_UNDERFLOW_OVERFLOW_ERROR interrupt is pending.  See associated FIFO_UNDERFLOW_OVERFLOW_ERROR status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ASTATE_CHANGE_PEND">STATE_CHANGE_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the STATE_CHANGE status bit has been detected and therefore a STATE_CHANGE interrupt is pending.  See associated STATE_CHANGE status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ACMD_ERROR_PEND">CMD_ERROR_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the CMD_ERROR status bit has been detected and therefore a CMD_ERROR interrupt is pending.  See associated CMD_ERROR status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ACHIP_READY_PEND">CHIP_READY_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the CHIP_READY status bit has been detected and therefore a CHIP_READY interrupt is pending.  See associated CHIP_READY status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ALOW_BATT_PEND">LOW_BATT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the LOW_BATT status bit has been detected and therefore a LOW_BATT interrupt is pending.  See associated LOW_BATT status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3AWUT_PEND">WUT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the WUT status bit has been detected and therefore a WUT interrupt is pending.  See associated WUT status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_INT_STATUS%3ACHIP_STATUS">CHIP_STATUS</a><ul>
<li><a name="reply-GET_INT_STATUS%3ACAL">CAL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Self clearing signal that pulses high to indicate a RC32K calibration event is pending. If this occurs, the RC32K oscillator will be calibrated on the next transition to Sleep/Standby state.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3AFIFO_UNDERFLOW_OVERFLOW_ERROR">FIFO_UNDERFLOW_OVERFLOW_ERROR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate that the number of received or transmitted bytes exceeds the size of the RX or TX FIFO, respectively (i.e., 64 bytes for each FIFO, or 129 bytes when sharing the FIFO).  Upon such an underflow/overflow event, the FIFO(s) will need to be reset.  Cleared by issuing a <a href="#cmd-FIFO_INFO"><code>FIFO_INFO</code></a>
 command to reset the FIFOs.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ASTATE_CHANGE">STATE_CHANGE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate a successful transition from one state to another operating state.  Cleared when a state transition is in progress.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ACMD_ERROR">CMD_ERROR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Self clearing signal that pulses high to indicate an error has occurred in the processing of a command. For example, an incorrect command/property ID is sent, or an attempt was made to write a property that is outside of the given property group.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ACHIP_READY">CHIP_READY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate the chip (upon completion of the POWER_UP sequence) has reached the state where it is ready to accept commands, or when the IR calibration process is completed.  Cleared when the chip is shutdown or when IR calibration has begun.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ALOW_BATT">LOW_BATT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate the battery voltage is below the threshold set by <a href="#prop-GLOBAL_LOW_BATT_THRESH">GLOBAL_LOW_BATT_THRESH</a>
.  Cleared to indicate the battery voltage is above the threshold set by <a href="#prop-GLOBAL_LOW_BATT_THRESH">GLOBAL_LOW_BATT_THRESH</a>
.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3AWUT">WUT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Self clearing signal that pulses high to indicate the WUT (Wake-up timer) has expired.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_INT_STATUS%3AINFO_FLAGS">INFO_FLAGS</a><ul>
<li><a name="reply-GET_INT_STATUS%3ACAL_TYPE">CAL_TYPE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Defines which calibration is required.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">OFFLINE_CAL</td><td>0</td><td align="left">
<ul><li>
Offline calibration.</li></ul>
</td></tr>
<tr valign="top"><td align="left">OFFLINE2_CAL</td><td>1</td><td align="left">
<ul><li>
Offline2 calibration.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="reply-GET_INT_STATUS%3ASYNC_TRIGGER">SYNC_TRIGGER</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Defines which sync word triggered the sync detect. This value is only valid whenever <a href="#field-SYNC_CONFIG2%3ADUAL_SYNC_EN">SYNC_CONFIG2:DUAL_SYNC_EN</a>
 is enabled.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SYNC_1</td><td>0</td><td align="left">
<ul><li>
Sync Word 1 triggered sync detected.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SYNC_2</td><td>1</td><td align="left">
<ul><li>
Sync Word 2 triggered sync detected.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-REQUEST_DEVICE_STATE">REQUEST_DEVICE_STATE</a></h4>
<ul>
<li>Number: 0x33</li>
<li>Summary: Request current device state and channel.</li>
<li>Purpose:</li>
<ul><li>
This command returns information regarding the current operating state and tuned frequency channel of the device.
    </li><li>
Returning the current channel number is often useful in automatic frequency hopping applications, to determine the frequency on which the device found a valid signal.
    </li><li>
It is not possible for this command to return a device state value indicating the chip is in SLEEP or STANDBY mode,    as the very act of sending an SPI command while the chip is in SLEEP or STANDBY mode assures that it wakes into SPI_ACTIVE mode.
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">REQUEST_DEVICE_STATE Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x33</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">REQUEST_DEVICE_STATE Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>CURR_STATE</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="4">MAIN_STATE</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>CURRENT_CHANNEL</b></td>
<td colspan="8">CURRENT_CHANNEL</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-REQUEST_DEVICE_STATE%3ACTS">CTS</a><ul>
<li><a name="reply-REQUEST_DEVICE_STATE%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-REQUEST_DEVICE_STATE%3ACURR_STATE">CURR_STATE</a><ul>
<li><a name="reply-REQUEST_DEVICE_STATE%3AMAIN_STATE">MAIN_STATE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Returns the current operating state of the device.  Please refer to the published datasheet for more details regarding these operational modes.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SLEEP</td><td>1</td><td align="left">
<ul><li>
(Not Applicable)</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPI_ACTIVE</td><td>2</td><td align="left">
<ul><li>
SPI_ACTIVE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">READY</td><td>3</td><td align="left">
<ul><li>
READY state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">READY2</td><td>4</td><td align="left">
<ul><li>
Another enumeration for READY state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_TUNE</td><td>5</td><td align="left">
<ul><li>
TX_TUNE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_TUNE</td><td>6</td><td align="left">
<ul><li>
RX_TUNE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX</td><td>7</td><td align="left">
<ul><li>
TX state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX</td><td>8</td><td align="left">
<ul><li>
RX state.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="reply-REQUEST_DEVICE_STATE%3ACURRENT_CHANNEL">CURRENT_CHANNEL</a><ul>
<li><a name="reply-REQUEST_DEVICE_STATE%3ACURRENT_CHANNEL">CURRENT_CHANNEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Returns the current tuned channel.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-CHANGE_STATE">CHANGE_STATE</a></h4>
<ul>
<li>Number: 0x34</li>
<li>Summary: Manually switch the chip to a desired operating state.</li>
<li>Purpose:</li>
<ul><li>
The chip normally manages the required steps in transitioning between operating states automatically.     For example, transmission of a packet may require:  waking the chip from SLEEP mode, enabling the Xtal Oscillator (READY mode),    calibrating the VCO and tuning the PLL Synthesizer (TX_TUNE mode), enabling the PA and transmission of the packet (TX mode),    and returning to an IDLE state.    This sequencing is normally handled by the internal state machine.
    </li><li>
This command provides for manually switching to a desired operating state.
    </li><li>
This command may be used to enter TX or RX mode, if desired.      However, those modes of operation typically require specification of additional parameters    (e.g., channel number, number of packet bytes, etc.) prior to switching mode.    For this reason, separate START_TX and START_RX commands are provided that essentially accomplish the CHANGE_STATE = TX or RX functionality,    while simultaneously passing the required parameter bytes. </li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">CHANGE_STATE Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x34</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>NEXT_STATE1</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="4">NEW_STATE</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">CHANGE_STATE Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-CHANGE_STATE%3ANEXT_STATE1">NEXT_STATE1</a><ul>
<li><a name="arg-CHANGE_STATE%3ANEW_STATE">NEW_STATE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Operating state to switch to immediately.     Please refer to the published datasheet for more details regarding these operational modes.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NOCHANGE</td><td>0</td><td align="left">
<ul><li>
No change, remain in current state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SLEEP</td><td>1</td><td align="left">
<ul><li>
SLEEP or STANDBY state, according to the mode of operation of the 32K R-C Osc selected                           by <a href="#field-GLOBAL_CLK_CFG%3ACLK_32K_SEL">GLOBAL_CLK_CFG:CLK_32K_SEL</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPI_ACTIVE</td><td>2</td><td align="left">
<ul><li>
SPI_ACTIVE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">READY</td><td>3</td><td align="left">
<ul><li>
READY state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">READY2</td><td>4</td><td align="left">
<ul><li>
Another enumeration for READY state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_TUNE</td><td>5</td><td align="left">
<ul><li>
TX_TUNE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_TUNE</td><td>6</td><td align="left">
<ul><li>
RX_TUNE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX</td><td>7</td><td align="left">
<ul><li>
TX state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX</td><td>8</td><td align="left">
<ul><li>
RX state.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-CHANGE_STATE%3ACTS">CTS</a><ul>
<li><a name="reply-CHANGE_STATE%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-OFFLINE_RECAL">OFFLINE_RECAL</a></h4>
<ul>
<li>Number: 0x38</li>
<li>Summary: Switches to high temp or low temp settings and recalibrate blocks.</li>
<li>Purpose:</li>
<ul><li>
</li><li>
This command adjusts the digital regulator, clock generator and feedback divider settings to handle temperatures above 85C. Whenever the host chip detects temperature change above 85C, this command should be sent with <a href="#arg-OFFLINE_RECAL%3ACAL_CTRL">OFFLINE_RECAL:CAL_CTRL</a>
 with HIGH_TEMP sent.
    </li><li>
This command can be used to kick off calibration events to adjust to temperature changes.
    </li><li>
This command will force the chip out of RX or TX states, placing the chip back in READY when calibration is complete.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">OFFLINE_RECAL Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x38</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>CAL_CTRL</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">OFFLINE_CAL</td>
<td colspan="1">TEMP</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>VTR_CAL_ENABLE</b></td>
<td colspan="8">VTR_CAL_ENABLE</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>CAL_ENABLE</b></td>
<td colspan="8">CAL_ENABLE</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">OFFLINE_RECAL Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-OFFLINE_RECAL%3ACAL_CTRL">CAL_CTRL</a><ul>
<li><a name="arg-OFFLINE_RECAL%3AOFFLINE_CAL">OFFLINE_CAL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Define which offline calibration to perform.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">OFFLINE_CAL</td><td>0</td><td align="left">
<ul><li>
Perform an offline cal.</li></ul>
</td></tr>
<tr valign="top"><td align="left">OFFLINE2_CAL</td><td>1</td><td align="left">
<ul><li>
Perform an offline2 cal.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-OFFLINE_RECAL%3ATEMP">TEMP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Configure the chip for high temp/low temp settings. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">LOW_TEMP</td><td>0</td><td align="left">
<ul><li>
Configure the part for -40 to 85C operation.</li></ul>
</td></tr>
<tr valign="top"><td align="left">HIGH_TEMP</td><td>1</td><td align="left">
<ul><li>
Configure the part for -40 to 135C operation</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="arg-OFFLINE_RECAL%3AVTR_CAL_ENABLE">VTR_CAL_ENABLE</a><ul>
<li><a name="arg-OFFLINE_RECAL%3AVTR_CAL_ENABLE">VTR_CAL_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If non-zero, selects which VTR calibrations to run, matching bit definitions with <a href="#prop-OTP_VARS_CAL_ENABLE_VTR">OTP_VARS_CAL_ENABLE_VTR</a>
, otherwise this property controls which calibrations are run directly.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-OFFLINE_RECAL%3ACAL_ENABLE">CAL_ENABLE</a><ul>
<li><a name="arg-OFFLINE_RECAL%3ACAL_ENABLE">CAL_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If non-zero, selects which VTR calibrations to run, matching bit definitions with <a href="#prop-OTP_VARS_CAL_ENABLE">OTP_VARS_CAL_ENABLE</a>
, otherwise this property controls which calibrations are run directly.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-OFFLINE_RECAL%3ACTS">CTS</a><ul>
<li><a name="reply-OFFLINE_RECAL%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-READ_CMD_BUFF">READ_CMD_BUFF</a></h4>
<ul>
<li>Number: 0x44</li>
<li>Summary: Used to read CTS and the command response.</li>
<li>Purpose:</li>
<ul><li>
Processing of API commands is handled by the command handler in the chip.     A subsequent command may not be sent until the chip has completed processing of the first command.     The chip indicates the ability to receive another command and the availability of response data by issuing a Clear To Send (CTS) signal;    it is necessary for the host MCU to poll the chip for this CTS signal.     The CTS signal may be polled via SPI command, or monitored on a GPIO line or as an interrupt on the nIRQ pin.
    </li><li>
This command is used to poll the CTS signal via the SPI bus.     The NSEL line should be pulled low, followed by sending the READ_CMD_BUFF command on SDI.    While NSEL remains asserted low, an additional eight clock pulses are sent on SCLK and the CTS response byte is read on SDO.    If the CTS response byte is not 0xFF, the host MCU should pull NSEL high and repeat the polling procedure.
    </li><li>
If the CTS response byte is 0xFF, the host MCU should keep NSEL asserted low and provide additional clock    cycles on SCLK to read out as many response bytes (on SDO) as necessary.     The host MCU should pull NSEL high upon completion of reading the response stream.
    </li><li>
A primary function of this command is to determine when CTS goes high, and thus by definition this command may be sent while CTS is low.     This command itself does not cause CTS to go low.
    </li><li>
Attempting to read response bytes from the command buffer while CTS is not 0xFF will return invalid results.     The response bytes are valid only if CTS = 0xFF.
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">READ_CMD_BUFF Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x44</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">READ_CMD_BUFF Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-READ_CMD_BUFF%3ACTS">CTS</a><ul>
<li><a name="reply-READ_CMD_BUFF%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-FRR_A_READ">FRR_A_READ</a></h4>
<ul>
<li>Number: 0x50</li>
<li>Summary: Reads the fast response registers (FRR) starting with FRR_A.</li>
<li>Purpose:</li>
<ul><li>
The chip provides four Fast Response Registers (FRR) that may be read immediately without the need to monitor and check CTS, thus improving the speed at which the contents may be retrieved.
    </li><li>
The FRR registers may be read in a burst fashion through the FRR_X_READ commands.     After the initial 16 clock cycles, each additional eight clock cycles will clock out the contents of the next fast response register in a circular fashion.    Example:  If the <a href="#cmd-FRR_A_READ"><code>FRR_A_READ</code></a>
 command is issued, the registers will be read in the order A-B-C-D,    while if the <a href="#cmd-FRR_B_READ"><code>FRR_B_READ</code></a>
 command is issued, the registers will be read in the order B-C-D-A, etc.
    </li><li>
This command does not cause CTS to go low, and can be sent and the reply read while CTS is low.     The command ID should be clocked in on SDI then the reply should be clocked out on SDO without deasserting NSEL.
    </li><li>
The FRR_CTL_X_MODE properties are used to select the specific parameter values that will be returned by the FRR_X_READ commands.     Please refer to the text description for FRR_CTL_X_MODE for more details regarding selection of the parameter(s) held within the FRR registers.
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">FRR_A_READ Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x50</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">FRR_A_READ Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>FRR_A_VALUE</b></td>
<td colspan="8">FRR_A_VALUE</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>FRR_B_VALUE</b></td>
<td colspan="8">FRR_B_VALUE</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>FRR_C_VALUE</b></td>
<td colspan="8">FRR_C_VALUE</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>FRR_D_VALUE</b></td>
<td colspan="8">FRR_D_VALUE</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-FRR_A_READ%3AFRR_A_VALUE">FRR_A_VALUE</a><ul>
<li><a name="reply-FRR_A_READ%3AFRR_A_VALUE">FRR_A_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value in Fast Response Register A.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FRR_A_READ%3AFRR_B_VALUE">FRR_B_VALUE</a><ul>
<li><a name="reply-FRR_A_READ%3AFRR_B_VALUE">FRR_B_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value in Fast Response Register B.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FRR_A_READ%3AFRR_C_VALUE">FRR_C_VALUE</a><ul>
<li><a name="reply-FRR_A_READ%3AFRR_C_VALUE">FRR_C_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value in Fast Response Register C.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FRR_A_READ%3AFRR_D_VALUE">FRR_D_VALUE</a><ul>
<li><a name="reply-FRR_A_READ%3AFRR_D_VALUE">FRR_D_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value in Fast Response Register D.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-FRR_B_READ">FRR_B_READ</a></h4>
<ul>
<li>Number: 0x51</li>
<li>Summary: Reads the fast response registers (FRR) starting with FRR_B.</li>
<li>Purpose:</li>
<ul><li>
The chip provides four Fast Response Registers (FRR) that may be read immediately without the need to monitor and check CTS, thus improving the speed at which the contents may be retrieved.
    </li><li>
The FRR registers may be read in a burst fashion through the FRR_X_READ commands.     After the initial 16 clock cycles, each additional eight clock cycles will clock out the contents of the next fast response register in a circular fashion.    Example:  If the <a href="#cmd-FRR_A_READ"><code>FRR_A_READ</code></a>
 command is issued, the registers will be read in the order A-B-C-D,    while if the <a href="#cmd-FRR_B_READ"><code>FRR_B_READ</code></a>
 command is issued, the registers will be read in the order B-C-D-A, etc.
    </li><li>
This command does not cause CTS to go low, and can be sent and the reply read while CTS is low.     The command ID should be clocked in on SDI then the reply should be clocked out on SDO without deasserting NSEL.
    </li><li>
The FRR_CTL_X_MODE properties are used to select the specific parameter values that will be returned by the FRR_X_READ commands.     Please refer to the text description for FRR_CTL_X_MODE for more details regarding selection of the parameter(s) held within the FRR registers.
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">FRR_B_READ Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x51</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">FRR_B_READ Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>FRR_B_VALUE</b></td>
<td colspan="8">FRR_B_VALUE</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>FRR_C_VALUE</b></td>
<td colspan="8">FRR_C_VALUE</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>FRR_D_VALUE</b></td>
<td colspan="8">FRR_D_VALUE</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>FRR_A_VALUE</b></td>
<td colspan="8">FRR_A_VALUE</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-FRR_B_READ%3AFRR_B_VALUE">FRR_B_VALUE</a><ul>
<li><a name="reply-FRR_B_READ%3AFRR_B_VALUE">FRR_B_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value in Fast Response Register B.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FRR_B_READ%3AFRR_C_VALUE">FRR_C_VALUE</a><ul>
<li><a name="reply-FRR_B_READ%3AFRR_C_VALUE">FRR_C_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value in Fast Response Register C.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FRR_B_READ%3AFRR_D_VALUE">FRR_D_VALUE</a><ul>
<li><a name="reply-FRR_B_READ%3AFRR_D_VALUE">FRR_D_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value in Fast Response Register D.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FRR_B_READ%3AFRR_A_VALUE">FRR_A_VALUE</a><ul>
<li><a name="reply-FRR_B_READ%3AFRR_A_VALUE">FRR_A_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value in Fast Response Register A.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-FRR_C_READ">FRR_C_READ</a></h4>
<ul>
<li>Number: 0x53</li>
<li>Summary: Reads the fast response registers (FRR) starting with FRR_C.</li>
<li>Purpose:</li>
<ul><li>
The chip provides four Fast Response Registers (FRR) that may be read immediately without the need to monitor and check CTS, thus improving the speed at which the contents may be retrieved.
    </li><li>
The FRR registers may be read in a burst fashion through the FRR_X_READ commands.     After the initial 16 clock cycles, each additional eight clock cycles will clock out the contents of the next fast response register in a circular fashion.    Example:  If the <a href="#cmd-FRR_A_READ"><code>FRR_A_READ</code></a>
 command is issued, the registers will be read in the order A-B-C-D,    while if the <a href="#cmd-FRR_B_READ"><code>FRR_B_READ</code></a>
 command is issued, the registers will be read in the order B-C-D-A, etc.
    </li><li>
This command does not cause CTS to go low, and can be sent and the reply read while CTS is low.     The command ID should be clocked in on SDI then the reply should be clocked out on SDO without deasserting NSEL.
    </li><li>
The FRR_CTL_X_MODE properties are used to select the specific parameter values that will be returned by the FRR_X_READ commands.     Please refer to the text description for FRR_CTL_X_MODE for more details regarding selection of the parameter(s) held within the FRR registers.
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">FRR_C_READ Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x53</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">FRR_C_READ Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>FRR_C_VALUE</b></td>
<td colspan="8">FRR_C_VALUE</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>FRR_D_VALUE</b></td>
<td colspan="8">FRR_D_VALUE</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>FRR_A_VALUE</b></td>
<td colspan="8">FRR_A_VALUE</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>FRR_B_VALUE</b></td>
<td colspan="8">FRR_B_VALUE</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-FRR_C_READ%3AFRR_C_VALUE">FRR_C_VALUE</a><ul>
<li><a name="reply-FRR_C_READ%3AFRR_C_VALUE">FRR_C_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value in Fast Response Register C.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FRR_C_READ%3AFRR_D_VALUE">FRR_D_VALUE</a><ul>
<li><a name="reply-FRR_C_READ%3AFRR_D_VALUE">FRR_D_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value in Fast Response Register D.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FRR_C_READ%3AFRR_A_VALUE">FRR_A_VALUE</a><ul>
<li><a name="reply-FRR_C_READ%3AFRR_A_VALUE">FRR_A_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value in Fast Response Register A.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FRR_C_READ%3AFRR_B_VALUE">FRR_B_VALUE</a><ul>
<li><a name="reply-FRR_C_READ%3AFRR_B_VALUE">FRR_B_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value in Fast Response Register B.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-FRR_D_READ">FRR_D_READ</a></h4>
<ul>
<li>Number: 0x57</li>
<li>Summary: Reads the fast response registers (FRR) starting with FRR_D.</li>
<li>Purpose:</li>
<ul><li>
The chip provides four Fast Response Registers (FRR) that may be read immediately without the need to monitor and check CTS, thus improving the speed at which the contents may be retrieved.
    </li><li>
The FRR registers may be read in a burst fashion through the FRR_X_READ commands.     After the initial 16 clock cycles, each additional eight clock cycles will clock out the contents of the next fast response register in a circular fashion.    Example:  If the <a href="#cmd-FRR_A_READ"><code>FRR_A_READ</code></a>
 command is issued, the registers will be read in the order A-B-C-D,    while if the <a href="#cmd-FRR_B_READ"><code>FRR_B_READ</code></a>
 command is issued, the registers will be read in the order B-C-D-A, etc.
    </li><li>
This command does not cause CTS to go low, and can be sent and the reply read while CTS is low.     The command ID should be clocked in on SDI then the reply should be clocked out on SDO without deasserting NSEL.
    </li><li>
The FRR_CTL_X_MODE properties are used to select the specific parameter values that will be returned by the FRR_X_READ commands.     Please refer to the text description for FRR_CTL_X_MODE for more details regarding selection of the parameter(s) held within the FRR registers.
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">FRR_D_READ Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x57</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">FRR_D_READ Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>FRR_D_VALUE</b></td>
<td colspan="8">FRR_D_VALUE</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>FRR_A_VALUE</b></td>
<td colspan="8">FRR_A_VALUE</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>FRR_B_VALUE</b></td>
<td colspan="8">FRR_B_VALUE</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>FRR_C_VALUE</b></td>
<td colspan="8">FRR_C_VALUE</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-FRR_D_READ%3AFRR_D_VALUE">FRR_D_VALUE</a><ul>
<li><a name="reply-FRR_D_READ%3AFRR_D_VALUE">FRR_D_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value in Fast Response Register D.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FRR_D_READ%3AFRR_A_VALUE">FRR_A_VALUE</a><ul>
<li><a name="reply-FRR_D_READ%3AFRR_A_VALUE">FRR_A_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value in Fast Response Register A.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FRR_D_READ%3AFRR_B_VALUE">FRR_B_VALUE</a><ul>
<li><a name="reply-FRR_D_READ%3AFRR_B_VALUE">FRR_B_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value in Fast Response Register B.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-FRR_D_READ%3AFRR_C_VALUE">FRR_C_VALUE</a><ul>
<li><a name="reply-FRR_D_READ%3AFRR_C_VALUE">FRR_C_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value in Fast Response Register C.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-AGC_OVERRIDE">AGC_OVERRIDE</a></h4>
<ul>
<li>Number: 0xd0</li>
<li>Summary: Override the AGC and manually control the gain of the RX chain.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for Automatic Gain Control (AGC) in RX mode.    This algorithm adjusts the gain of the RX chain to provide optimal reception of the signal under all amplitude conditions.
    </li><li>
This command is used to disable the AGC algorithm, and to provide for manual control of the two adjustable gain circuit blocks (i.e., the LNA and PGA).
    </li><li>
The recommended operating mode of the chip is with the AGC algorithm enabled (default setting);    manual gain control is provided primarily to support chip diagnostics or special user applications.     Additionally, the reported value of RSSI may change significantly in manual gain control mode,     as the chip internally calculates RSSI based upon the AGC settings and not the MGC settings.
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">AGC_OVERRIDE Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0xd0</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>AGC_OVERRIDE</b></td>
<td colspan="1">DIS_PGA_AGC</td>
<td colspan="3">PGA_GAIN_CFG</td>
<td colspan="1">DIS_LNA_AGC</td>
<td colspan="3">LNA_GAIN_CFG</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">AGC_OVERRIDE Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-AGC_OVERRIDE%3AAGC_OVERRIDE">AGC_OVERRIDE</a><ul>
<li><a name="arg-AGC_OVERRIDE%3ADIS_PGA_AGC">DIS_PGA_AGC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enable/disable bit for control of the PGA gain by the hardware AGC circuitry.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Use hardware AGC to control the PGA gain.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Disable hardware AGC  control of the PGA, and manually set the PGA gain according to the PGA_GAIN_CFG parameter.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-AGC_OVERRIDE%3APGA_GAIN_CFG">PGA_GAIN_CFG</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the gain setting of the PGA, when in manual gain control mode (i.e., the DIS_PGA_AGC bit is set).
    </li><li>
The coding of this field is a form of two's complement, such that mid-range PGA gain is obtained for PGA_GAIN_CFG = 0x0.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Set PGA gain = 6dB.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Set PGA gain = 9dB.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
Set PGA gain = 12dB. (maximum)</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_6</td><td>6</td><td align="left">
<ul><li>
Set PGA gain = 0dB. (minimum)</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_7</td><td>7</td><td align="left">
<ul><li>
Set PGA gain = 3dB.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-AGC_OVERRIDE%3ADIS_LNA_AGC">DIS_LNA_AGC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enable/disable bit for control of the LNA gain by the hardware AGC circuitry.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Use hardware AGC to control the LNA gain.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Disable hardware AGC control of the LNA, and manually set the LNA gain according to the LNA_GAIN_CFG parameter. </li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-AGC_OVERRIDE%3ALNA_GAIN_CFG">LNA_GAIN_CFG</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the gain setting of the LNA, when in manual gain control mode (i.e., the DIS_LNA_AGC bit is set).
    </li><li>
The coding of this field is inverted, such that maximum LNA gain is obtained for LNA_GAIN_CFG = 0x0 and minimum gain is obtained for LNA_GAIN_CFG = 0x7.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">MAXIMUM</td><td>0</td><td align="left">
<ul><li>
Set LNA gain = maximum.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Set LNA gain = maximum - 3dB.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
Set LNA gain = maximum - 6dB.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
Set LNA gain = maximum - 9dB.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_4</td><td>4</td><td align="left">
<ul><li>
Set LNA gain = maximum - 12dB.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_5</td><td>5</td><td align="left">
<ul><li>
Set LNA gain = maximum - 15dB.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_6</td><td>6</td><td align="left">
<ul><li>
Set LNA gain = maximum - 18dB.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_7</td><td>7</td><td align="left">
<ul><li>
Set LNA gain = maximum - 21dB.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-AGC_OVERRIDE%3ACTS">CTS</a><ul>
<li><a name="reply-AGC_OVERRIDE%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="cset-IR_CAL_COMMANDS">IR_CAL_COMMANDS</a></h3>
<h4><a name="cmd-IRCAL">IRCAL</a></h4>
<ul>
<li>Number: 0x17</li>
<li>Summary: Image rejection calibration.</li>
<li>Purpose:</li>
<ul><li>
Performs image rejection calibration.  Completion can be monitored by polling CTS or waiting for CHIP_READY interrupt source.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">IRCAL Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x17</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>SEARCHING_STEP_SIZE</b></td>
<td>0</td>
<td colspan="1">INITIAL_PH_AMP</td>
<td colspan="2">FINE_STEP_SIZE</td>
<td colspan="4">COARSE_STEP_SIZE</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>SEARCHING_RSSI_AVG</b></td>
<td colspan="1">STEP_BY_STEP</td>
<td colspan="1">SKIP_INIT_SEARCH_STAT</td>
<td colspan="2">RSSI_FINE_AVG</td>
<td>0</td>
<td colspan="1">SKIP_CAL</td>
<td colspan="2">RSSI_COARSE_AVG</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>RX_CHAIN_SETTING1</b></td>
<td colspan="1">EN_HRMNIC_GEN</td>
<td colspan="1">IRCLKDIV</td>
<td colspan="2">RF_SOURCE_PWR</td>
<td colspan="1">CLOSE_SHUNT_SWITCH</td>
<td colspan="3">PGA_GAIN</td>
</tr>
<tr><td>0x04</td>
<td rowspan="1"><b>RX_CHAIN_SETTING2</b></td>
<td colspan="4">RSSI_READ_DELAY</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">ADC_HIGH_GAIN</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">IRCAL Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>CAL_STATE</b></td>
<td colspan="8">CAL_STATE</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>RSSI</b></td>
<td colspan="8">RSSI</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>DIR_CH</b></td>
<td colspan="8">DIR_CH</td>
</tr>
<tr><td>0x04</td>
<td rowspan="1"><b>LAST_RSSI</b></td>
<td colspan="8">LAST_RSSI</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-IRCAL%3ASEARCHING_STEP_SIZE">SEARCHING_STEP_SIZE</a><ul>
<li><a name="arg-IRCAL%3AINITIAL_PH_AMP">INITIAL_PH_AMP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Initial ph and amp value when start IR calibration.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Use zero for phase and amplitude values as starting values.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>0</td><td align="left">
<ul><li>
Use previous calibration values as starting values.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IRCAL%3AFINE_STEP_SIZE">FINE_STEP_SIZE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Step size of fine stepping.  Writing a value of 0 will skip fine stepping.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="arg-IRCAL%3ACOARSE_STEP_SIZE">COARSE_STEP_SIZE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Step Size of coarse stepping.  Writing a value of 0 will skip coarse stepping.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-IRCAL%3ASEARCHING_RSSI_AVG">SEARCHING_RSSI_AVG</a><ul>
<li><a name="arg-IRCAL%3ASTEP_BY_STEP">STEP_BY_STEP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Whether only do one step searching. If we do only one step searching, then we don't revert the parameters when the API call is finished. If we calibrate IR step-by-step, the calibration state will be automatically changed, please refer the return state.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do automatic searching.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Only search one step.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IRCAL%3ASKIP_INIT_SEARCH_STAT">SKIP_INIT_SEARCH_STAT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Whether initialize the searching process(clear the saved information when step-by-step searching)</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Start a new search.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Continue to search.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IRCAL%3ARSSI_FINE_AVG">RSSI_FINE_AVG</a>
<dl><dt>Description:</dt><dd>
<ul><li>
How many measurements(2^avg) per RSSI measurement while fine stepping.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
1 measurement.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
2 measurements.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
4 measurements.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
8 measurements.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IRCAL%3ASKIP_CAL">SKIP_CAL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Skip calibration and skip reverting parameters, only configure the parameters for IR cal.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
do calibration and then revert parameters.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
skip calibration and reverting parameters.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IRCAL%3ARSSI_COARSE_AVG">RSSI_COARSE_AVG</a>
<dl><dt>Description:</dt><dd>
<ul><li>
How many measurements(2^avg) per RSSI measurement while coarse stepping.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
1 measurement.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
2 measurements.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
4 measurements.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
8 measurements.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="arg-IRCAL%3ARX_CHAIN_SETTING1">RX_CHAIN_SETTING1</a><ul>
<li><a name="arg-IRCAL%3AEN_HRMNIC_GEN">EN_HRMNIC_GEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enable harmonic generator.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Not enable.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IRCAL%3AIRCLKDIV">IRCLKDIV</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set irclkdiv.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Set to nominal gain.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Harmonics at N x 30 MHz.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IRCAL%3ARF_SOURCE_PWR">RF_SOURCE_PWR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Power of internal generator(Default 3).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
smallest.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
small.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
big.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
biggest.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IRCAL%3ACLOSE_SHUNT_SWITCH">CLOSE_SHUNT_SWITCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Close shunt switch.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Open LNA input shunt switch.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Close Open LNA input shunt switch.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IRCAL%3APGA_GAIN">PGA_GAIN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set PGA Gain.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
6 dB.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
9 dB.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
12 dB.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
6 dB.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_4</td><td>4</td><td align="left">
<ul><li>
6 dB.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_5</td><td>5</td><td align="left">
<ul><li>
6 dB.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_6</td><td>6</td><td align="left">
<ul><li>
0 dB.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_7</td><td>7</td><td align="left">
<ul><li>
3 dB.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="arg-IRCAL%3ARX_CHAIN_SETTING2">RX_CHAIN_SETTING2</a><ul>
<li><a name="arg-IRCAL%3ARSSI_READ_DELAY">RSSI_READ_DELAY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
How many bits clock delay before read RSSI when calibration. Delay = (2 + RSSI_READ_DLEAY)*bit_clock).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
2 + 0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
2 + 1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>15</td><td align="left">
<ul><li>
2 + 15.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IRCAL%3AADC_HIGH_GAIN">ADC_HIGH_GAIN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set ADC to high gain.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Set to nominal gain.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Set to high gain.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-IRCAL%3ACTS">CTS</a><ul>
<li><a name="reply-IRCAL%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IRCAL%3ACAL_STATE">CAL_STATE</a><ul>
<li><a name="reply-IRCAL%3ACAL_STATE">CAL_STATE</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Not in proc.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
PH fine stepping.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
AMP fine stepping.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>4</td><td align="left">
<ul><li>
PH coarse stepping.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_4</td><td>8</td><td align="left">
<ul><li>
AMP coarse stepping.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="reply-IRCAL%3ARSSI">RSSI</a><ul>
<li><a name="reply-IRCAL%3ARSSI">RSSI</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Current value of register RSSI. Usually the RSSI value is the RSSI of current AMP/PH. If (DIRECT_CHANGE = 1) or (CAL_STATE is different to previous value), then this means the search direction is changed, now the RSSI is the value before change direction. If it is this condition the RSSI of current value should be ready out by sfr_read.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IRCAL%3ADIR_CH">DIR_CH</a><ul>
<li><a name="reply-IRCAL%3ADIR_CH">DIR_CH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Whether search direction changed.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IRCAL%3ALAST_RSSI">LAST_RSSI</a><ul>
<li><a name="reply-IRCAL%3ALAST_RSSI">LAST_RSSI</a>
<dl><dt>Description:</dt><dd>
<ul><li>
New for ROM3, return the final RSSI value after IR calibration.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-IRCAL_MANUAL">IRCAL_MANUAL</a></h4>
<ul>
<li>Number: 0x1a</li>
<li>Summary: Image rejection calibration.</li>
<li>Purpose:</li>
<ul><li>
Forces a specific value for IR calibration, and reads back calibration values from previous calibrations.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">IRCAL_MANUAL Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x1a</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>IRCAL_AMP</b></td>
<td colspan="1">IRCAL_AMP_SKIP</td>
<td>0</td>
<td colspan="1">IRCAL_AMP_SIGN</td>
<td colspan="5">IRCAL_AMP_MAG</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>IRCAL_PH</b></td>
<td colspan="1">IRCAL_PH_SKIP</td>
<td>0</td>
<td colspan="1">IRCAL_PH_SIGN</td>
<td colspan="5">IRCAL_PH_MAG</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">IRCAL_MANUAL Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>IRCAL_AMP_REPLY</b></td>
<td>0</td>
<td>0</td>
<td colspan="1">IRCAL_AMP_SIGN</td>
<td colspan="5">IRCAL_AMP_MAG</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>IRCAL_PH_REPLY</b></td>
<td>0</td>
<td>0</td>
<td colspan="1">IRCAL_PH_SIGN</td>
<td colspan="5">IRCAL_AMP_PH</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-IRCAL_MANUAL%3AIRCAL_AMP">IRCAL_AMP</a><ul>
<li><a name="arg-IRCAL_MANUAL%3AIRCAL_AMP_SKIP">IRCAL_AMP_SKIP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Select whether or not the associated calibration value is applied.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">APPLY</td><td>0</td><td align="left">
<ul><li>
Apply amplitude calibration value.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SKIP</td><td>1</td><td align="left">
<ul><li>
Do not apply amplitude calibration value.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IRCAL_MANUAL%3AIRCAL_AMP_SIGN">IRCAL_AMP_SIGN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Select whether or not the amplitude calibration value is applied.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">POS</td><td>0</td><td align="left">
<ul><li>
Positive calibration value.</li></ul>
</td></tr>
<tr valign="top"><td align="left">NEG</td><td>1</td><td align="left">
<ul><li>
Negative calibration value.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IRCAL_MANUAL%3AIRCAL_AMP_MAG">IRCAL_AMP_MAG</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Magnitude of amplitude correction.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-IRCAL_MANUAL%3AIRCAL_PH">IRCAL_PH</a><ul>
<li><a name="arg-IRCAL_MANUAL%3AIRCAL_PH_SKIP">IRCAL_PH_SKIP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Select whether or not the associated calibration value is applied.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">APPLY</td><td>0</td><td align="left">
<ul><li>
Apply phase calibration value.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SKIP</td><td>1</td><td align="left">
<ul><li>
Do not apply phase calibration value.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IRCAL_MANUAL%3AIRCAL_PH_SIGN">IRCAL_PH_SIGN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Select whether or not the phase calibration value is applied.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">POS</td><td>0</td><td align="left">
<ul><li>
Positive calibration value.</li></ul>
</td></tr>
<tr valign="top"><td align="left">NEG</td><td>1</td><td align="left">
<ul><li>
Negative calibration value.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IRCAL_MANUAL%3AIRCAL_PH_MAG">IRCAL_PH_MAG</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Magnitude of phase correction.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-IRCAL_MANUAL%3ACTS">CTS</a><ul>
<li><a name="reply-IRCAL_MANUAL%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IRCAL_MANUAL%3AIRCAL_AMP_REPLY">IRCAL_AMP_REPLY</a><ul>
<li><a name="reply-IRCAL_MANUAL%3AIRCAL_AMP_SIGN">IRCAL_AMP_SIGN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Select whether or not the amplitude calibration value is applied.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">POS</td><td>0</td><td align="left">
<ul><li>
Positive calibration value.</li></ul>
</td></tr>
<tr valign="top"><td align="left">NEG</td><td>1</td><td align="left">
<ul><li>
Negative calibration value.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="reply-IRCAL_MANUAL%3AIRCAL_AMP_MAG">IRCAL_AMP_MAG</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Magnitude of amplitude correction.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IRCAL_MANUAL%3AIRCAL_PH_REPLY">IRCAL_PH_REPLY</a><ul>
<li><a name="reply-IRCAL_MANUAL%3AIRCAL_PH_SIGN">IRCAL_PH_SIGN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Select whether or not the phase calibration value is applied.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">POS</td><td>0</td><td align="left">
<ul><li>
Positive calibration value.</li></ul>
</td></tr>
<tr valign="top"><td align="left">NEG</td><td>1</td><td align="left">
<ul><li>
Negative calibration value.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="reply-IRCAL_MANUAL%3AIRCAL_AMP_PH">IRCAL_AMP_PH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Magnitude of phase correction.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="cset-TX_COMMANDS">TX_COMMANDS</a></h3>
<h4><a name="cmd-START_TX">START_TX</a></h4>
<ul>
<li>Number: 0x31</li>
<li>Summary: Switches to TX state and starts transmission of a packet.</li>
<li>Purpose:</li>
<ul><li>
This command switches the chip to TX state and begins transmission of a packet.    Depending upon the value of the START parameter, the start of transmission may be delayed until a certain condition is met.
    </li><li>
Several optional parameters may be passed with this command.     If these parameter values are not sent, their previously configured values remain in use.    The parameter values are retained while in SLEEP mode, and thus only need to be written when they change.
    </li><li>
The chip may be configured to automatically enter a desired operational state after transmission of the packet.
    </li><li>
The chip will not return CTS high until the chip has entered the TX state.
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">START_TX Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x31</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>CHANNEL</b></td>
<td colspan="8">CHANNEL</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>CONDITION</b></td>
<td colspan="4">TXCOMPLETE_STATE</td>
<td colspan="1">UPDATE</td>
<td colspan="1">RETRANSMIT</td>
<td colspan="2">START</td>
</tr>
<tr><td>0x03</td>
<td rowspan="2"><b>TX_LEN</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="5">TX_LEN[12:8]</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">TX_LEN[7:0]</td>
</tr>
<tr><td>0x05</td>
<td rowspan="1"><b>TX_DELAY</b></td>
<td colspan="8">TX_DELAY</td>
</tr>
<tr><td>0x06</td>
<td rowspan="1"><b>NUM_REPEAT</b></td>
<td colspan="8">NUM_REPEAT</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">START_TX Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-START_TX%3ACHANNEL">CHANNEL</a><ul>
<li><a name="arg-START_TX%3ACHANNEL">CHANNEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the channel number on which to transmit.     Please refer to FREQ_CONTROL_CHANNEL_STEP_SIZE for more details regarding the channelized approach to frequency tuning of the chip.
    </li><li>
If the CHANNEL parameter byte is not passed with the command, the chip will tune to the last channel specified in either a START_TX or START_RX command;    the internal variable that retains the CHANNEL value is shared by these two commands. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
<li><a name="arg-START_TX%3ACONDITION">CONDITION</a><ul>
<li><a name="arg-START_TX%3ATXCOMPLETE_STATE">TXCOMPLETE_STATE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This parameter selects the desired operational state of the chip to automatically enter upon completion of the packet transmission.
    </li><li>
If this parameter is not passed with the command, the chip continues to use the previously configured value.     If no value has been previously configured (i.e., upon POWER_UP), the default value of 3 = READY state is used. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NOCHANGE</td><td>0</td><td align="left">
<ul><li>
Do not change from previously sent TXCOMPLETE_STATE. (No Change does not have the effect of remaining in TX mode.)</li></ul>
</td></tr>
<tr valign="top"><td align="left">SLEEP</td><td>1</td><td align="left">
<ul><li>
SLEEP or STANDBY state, according to the mode of operotion of the 32K R-C Osc selected by <a href="#field-GLOBAL_CLK_CFG%3ACLK_32K_SEL">GLOBAL_CLK_CFG:CLK_32K_SEL</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPI_ACTIVE</td><td>2</td><td align="left">
<ul><li>
SPI ACTIVE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">READY</td><td>3</td><td align="left">
<ul><li>
READY state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">READY2</td><td>4</td><td align="left">
<ul><li>
Another enumeration for READY state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_TUNE</td><td>5</td><td align="left">
<ul><li>
TX_TUNE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_TUNE</td><td>6</td><td align="left">
<ul><li>
RX_TUNE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RESERVED</td><td>7</td><td align="left">
<ul><li>
Reserved, do not use.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX</td><td>8</td><td align="left">
<ul><li>
RX state.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-START_TX%3AUPDATE">UPDATE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the condition upon which transmission will start.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">UPDATE</td><td>1</td><td align="left">
<ul><li>
Update TX parameters (to be used by a subsequent packet) but do not enter TX mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">USE</td><td>0</td><td align="left">
<ul><li>
Use TX parameters to enter TX mode.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-START_TX%3ARETRANSMIT">RETRANSMIT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether the current packet will simply be a retransmission of the previous packet, or whether the current packet will transmit new data from the TX FIFO.
    </li><li>
In the event of a retransmission, new (additional) data should not be written to the TX FIFO prior to the retransmission.
    </li><li>
The RETRANSMIT bit should be set prior to sending the first packet, as well as on all subsequent retransmissions.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Send data that has been written to the TX FIFO.  If the TX FIFO is empty, a FIFO underflow interrupt will occur.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Send last packet again.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-START_TX%3ASTART">START</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the condition upon which transmission will start.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">IMMEDIATE</td><td>0</td><td align="left">
<ul><li>
Start TX immediately.</li></ul>
</td></tr>
<tr valign="top"><td align="left">WUT</td><td>1</td><td align="left">
<ul><li>
Start TX upon expiration of the Wake-Up Timer.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="arg-START_TX%3ATX_LEN">TX_LEN</a><ul>
<li><a name="arg-START_TX%3ATX_LEN">TX_LEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Specifies the number of bytes to transmit in the data field(s) of the packet.
    </li><li>
If this field is non-zero, the packet will be transmitted with TX_LEN number of data bytes,    using the data field configuration options (e.g., CRC, data whitening, Manchester coding, etc.) of only PKT_FIELD_1_X.    The Payload length is limited to 8191 bytes in this scenario.
    </li><li>
If this field is zero, the number of data bytes to be transmitted is specified by the value(s) of the PKT_FIELD_X_LENGTH properties.     The Payload length is limited to 5 x 8191 = 40955 bytes in this scenario (as each of the five data fields may be configured for a length of 8191 bytes).    This approach is necessary if field-specific processing is desired (e.g., data whitening on one field but not another,    Manchester coding on one field but not another, etc).
    </li><li>
The TX_LEN parameter should still be passed even if the RETRANSMIT bit is set.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1fff</dd></dl>
</li>
</ul></li>
<li><a name="arg-START_TX%3ATX_DELAY">TX_DELAY</a><ul>
<li><a name="arg-START_TX%3ATX_DELAY">TX_DELAY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Specifies a time delay (in sec) between transmissions of packets, in the event another transmission is scheduled.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x80</dd></dl>
</li>
</ul></li>
<li><a name="arg-START_TX%3ANUM_REPEAT">NUM_REPEAT</a><ul>
<li><a name="arg-START_TX%3ANUM_REPEAT">NUM_REPEAT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Specifies the number of times to repeat the packet. Packet cannot be longer than the fifo. If preamble and sync are required, those bytes should be put into the fifo and preamble/sync transmission disabled in the packet handler.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-START_TX%3ACTS">CTS</a><ul>
<li><a name="reply-START_TX%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-TX_HOP">TX_HOP</a></h4>
<ul>
<li>Number: 0x37</li>
<li>Summary: Hop to a new frequency while in TX.</li>
<li>Purpose:</li>
<ul><li>
While in TX state this will ramp down the PA, Retune the PLL, and ramp the PA back up.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">TX_HOP Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x37</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>INTE</b></td>
<td colspan="8">INTE</td>
</tr>
<tr><td>0x02</td>
<td rowspan="3"><b>FRAC</b></td>
<td>0</td>
<td colspan="7">FRAC[22:16]</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">FRAC[15:8]</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">FRAC[7:0]</td>
</tr>
<tr><td>0x05</td>
<td rowspan="2"><b>VCO_CNT</b></td>
<td colspan="8">VCO_CNT[15:8]</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">VCO_CNT[7:0]</td>
</tr>
<tr><td>0x07</td>
<td rowspan="2"><b>PLL_SETTLE_TIME</b></td>
<td colspan="8">PLL_SETTLE_TIME[15:8]</td>
</tr>
<tr><td>0x08</td>
<td colspan="8">PLL_SETTLE_TIME[7:0]</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">TX_HOP Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-TX_HOP%3AINTE">INTE</a><ul>
<li><a name="arg-TX_HOP%3AINTE">INTE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
INTE register value.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
<li><a name="arg-TX_HOP%3AFRAC">FRAC</a><ul>
<li><a name="arg-TX_HOP%3AFRAC">FRAC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
FRAC register value.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7fffff</dd></dl>
</li>
</ul></li>
<li><a name="arg-TX_HOP%3AVCO_CNT">VCO_CNT</a><ul>
<li><a name="arg-TX_HOP%3AVCO_CNT">VCO_CNT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
VCO_CNT register value.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xffff</dd></dl>
</li>
</ul></li>
<li><a name="arg-TX_HOP%3APLL_SETTLE_TIME">PLL_SETTLE_TIME</a><ul>
<li><a name="arg-TX_HOP%3APLL_SETTLE_TIME">PLL_SETTLE_TIME</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Delay in us to leave PA ramped down.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
<dl><dt>Min:</dt><dd>0x32</dd></dl>
<dl><dt>Max:</dt><dd>0x80</dd></dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-TX_HOP%3ACTS">CTS</a><ul>
<li><a name="reply-TX_HOP%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-WRITE_TX_FIFO">WRITE_TX_FIFO</a></h4>
<ul>
<li>Number: 0x66</li>
<li>Summary: Writes data byte(s) to the TX FIFO.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for two separate 64-byte FIFO memories for the purpose of storing transmit and receive data.     (When the <a href="#field-GLOBAL_CONFIG%3AFIFO_MODE">GLOBAL_CONFIG:FIFO_MODE</a>
 bit is set, these two FIFOs are combined into a single 129-byte shared FIFO.)</li><li>
This command is used to write data byte(s) into the TX FIFO.     The WRITE_TX_FIFO command should be clocked in on SDI (followed by the data byte(s) to be written) without deasserting NSEL.     If you write more data bytes than the TX FIFO can hold it will generate a FIFO Overflow interrupt event.
    </li><li>
This command does not cause CTS to go low, and can be sent while CTS is low.     This command has no response to be read and thus there is no need to monitor CTS after sending this command.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">WRITE_TX_FIFO Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x66</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">WRITE_TX_FIFO Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
</ul>
</li>
</ul>
<hr />
<h3><a name="cset-RX_COMMANDS">RX_COMMANDS</a></h3>
<h4><a name="cmd-PACKET_INFO">PACKET_INFO</a></h4>
<ul>
<li>Number: 0x16</li>
<li>Summary: Returns information about the length of the variable field in the last packet received, and (optionally) overrides field length. </li>
<li>Purpose:</li>
<ul><li>
The chip provides the ability for receiving packets in which one of the Payload field(s) is variable in length,    with its length specified by received byte(s) embedded within a prior fixed-length field.    This command may be used to retrieve the value of the length byte(s) (i.e., return the length of the variable length field).     Please refer to the text descriptions for <a href="#prop-PKT_LEN">PKT_LEN</a>
 and <a href="#prop-PKT_LEN_FIELD_SOURCE">PKT_LEN_FIELD_SOURCE</a>
 for more details regarding reception of a variable length packet.
    </li><li>
The value returned by this command describes the length of only the variable length field pointed to by the <a href="#field-PKT_LEN%3ADST_FIELD">PKT_LEN:DST_FIELD</a>
 parameter.     This value may not be the same as the total length of the Payload, as the Payload may consist of several fixed-length fields in addition to the variable-length field.    If no previous variable-length packet has been received, the return value will be 0.
    </li><li>
The LENGTH[15:0] response value is cleared upon entry into RX mode;    therefore, the <a href="#cmd-PACKET_INFO"><code>PACKET_INFO</code></a>
 command should be sent after reception of a valid packet and prior to re-entering RX mode,     else the response value will always be zero.
    </li><li>
This command may be issued with five optional arguments.     If these arguments follow, their values are used to override the packet length value that was originally    configured by issuing the <a href="#cmd-START_RX"><code>START_RX</code></a>
 command with a non-zero RX_LEN value,     or by programming the PKT_RX_FIELD_X_LENGTH properties.
    </li><li>
This feature is provided to support variable-length packet functionality in applications    where the length value cannot be extracted by the chip itself (due to special encoding, e.g., 3-of-6 encoding).      In such an application, all data fields are defined as fixed-length fields; the host MCU decodes the received length byte(s)    in the first field and subsequently issues the <a href="#cmd-PACKET_INFO"><code>PACKET_INFO</code></a>
 command during reception of the RX packet to modify the "fixed" length of a subsequent field.     Please contact Silicon Labs Support for assistance with this functionality.
    </li><li>
 In 802.15.4g receive mode, the FCS byte length embedded in the FHR is included to inform the host of the number of FCS bytes in the FIFO following the MAC Payload.    If FCS is 0, 2 is added to the return length; if FCS is 1, 4 is added to the return length. </li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">PACKET_INFO Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x16</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>FIELD_NUMBER</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="5">FIELD_NUM</td>
</tr>
<tr><td>0x02</td>
<td rowspan="2"><b>LEN</b></td>
<td colspan="8">LEN[15:8]</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">LEN[7:0]</td>
</tr>
<tr><td>0x04</td>
<td rowspan="2"><b>LEN_DIFF</b></td>
<td colspan="8">LEN_DIFF[15:8]</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">LEN_DIFF[7:0]</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">PACKET_INFO Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="2"><b>LENGTH</b></td>
<td colspan="8">LENGTH[15:8]</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">LENGTH[7:0]</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-PACKET_INFO%3AFIELD_NUMBER">FIELD_NUMBER</a><ul>
<li><a name="arg-PACKET_INFO%3AFIELD_NUM">FIELD_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the data field whose length will be modified per the LEN[15:0] and LEN_DIFF[15:0] parameters.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not override the length of any data fields.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Override the programmed value of PKT_FIELD_1_LENGTH, or the value of RX_LEN in the START_RX command.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
Override the programmed value of PKT_FIELD_2_LENGTH. </li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>4</td><td align="left">
<ul><li>
Override the programmed value of PKT_FIELD_3_LENGTH. </li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_4</td><td>8</td><td align="left">
<ul><li>
Override the programmed value of PKT_FIELD_4_LENGTH. </li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_5</td><td>16</td><td align="left">
<ul><li>
Override the programmed value of PKT_FIELD_5_LENGTH. </li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="arg-PACKET_INFO%3ALEN">LEN</a><ul>
<li><a name="arg-PACKET_INFO%3ALEN">LEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the new length (in bytes) of the data field specified by the FIELD_NUM parameter.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
<dl><dt>Min:</dt><dd>0x1</dd></dl>
<dl><dt>Max:</dt><dd>0x1fff</dd></dl>
</li>
</ul></li>
<li><a name="arg-PACKET_INFO%3ALEN_DIFF">LEN_DIFF</a><ul>
<li><a name="arg-PACKET_INFO%3ALEN_DIFF">LEN_DIFF</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Specifies the difference (in bytes) between the new length value     (specified in LEN[15:0]) and the original length value     (specified in the corresponding PKT_FIELD_X_LENGTH property, or passed in the START_RX:RX_LEN parameter).
    </li><li>
This is a signed 16-bit value, with a positive value indicating an increase in field length and a negative value indicating a decrease in field length.
    </li><li>
Passing the LEN_DIFF parameter as part of the <a href="#cmd-PACKET_INFO"><code>PACKET_INFO</code></a>
 command improves the speed with which the chip can process the requested change in packet length    (compared with the chip internally performing that computation). </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S16</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-8000</dd></dl>
<dl><dt>Max:</dt><dd>0x7fff</dd></dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-PACKET_INFO%3ACTS">CTS</a><ul>
<li><a name="reply-PACKET_INFO%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-PACKET_INFO%3ALENGTH">LENGTH</a><ul>
<li><a name="reply-PACKET_INFO%3ALENGTH">LENGTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Returns the variable length field value, extracted from the last received variable-length packet</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-GET_MODEM_STATUS">GET_MODEM_STATUS</a></h4>
<ul>
<li>Number: 0x22</li>
<li>Summary: Returns the interrupt status of the Modem Interrupt Group (both STATUS and PENDING).  Optionally, it may be used to clear latched (PENDING) interrupt events.</li>
<li>Purpose:</li>
<ul><li>
Returns the current interrupt status of Modem interrupt events (both STATUS and PENDING) and optionally clears PENDING interrupts.</li><li>
Please refer to the <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 command for more details regarding the difference between STATUS and PENDING interrupts.</li><li>
Sending the <a href="#cmd-GET_MODEM_STATUS"><code>GET_MODEM_STATUS</code></a>
 command with NO input parameter results in clearing all of the PENDING interrupts.</li><li>
When PENDING interrupts are being cleared, the reply stream reflects their status prior to clearing.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">GET_MODEM_STATUS Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x22</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>MODEM_CLR_PEND</b></td>
<td colspan="1">RSSI_LATCH_PEND_CLR</td>
<td colspan="1">POSTAMBLE_DETECT_PEND_CLR</td>
<td colspan="1">INVALID_SYNC_PEND_CLR</td>
<td colspan="1">RSSI_JUMP_PEND_CLR</td>
<td colspan="1">RSSI_PEND_CLR</td>
<td colspan="1">INVALID_PREAMBLE_PEND_CLR</td>
<td colspan="1">PREAMBLE_DETECT_PEND_CLR</td>
<td colspan="1">SYNC_DETECT_PEND_CLR</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">GET_MODEM_STATUS Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>MODEM_PEND</b></td>
<td colspan="1">RSSI_LATCH_PEND</td>
<td colspan="1">POSTAMBLE_DETECT_PEND</td>
<td colspan="1">INVALID_SYNC_PEND</td>
<td colspan="1">RSSI_JUMP_PEND</td>
<td colspan="1">RSSI_PEND</td>
<td colspan="1">INVALID_PREAMBLE_PEND</td>
<td colspan="1">PREAMBLE_DETECT_PEND</td>
<td colspan="1">SYNC_DETECT_PEND</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>MODEM_STATUS</b></td>
<td colspan="1">RSSI_LATCH</td>
<td colspan="1">POSTAMBLE_DETECT</td>
<td colspan="1">INVALID_SYNC</td>
<td colspan="1">RSSI_JUMP</td>
<td colspan="1">RSSI</td>
<td colspan="1">INVALID_PREAMBLE</td>
<td colspan="1">PREAMBLE_DETECT</td>
<td colspan="1">SYNC_DETECT</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>CURR_RSSI</b></td>
<td colspan="8">CURR_RSSI</td>
</tr>
<tr><td>0x04</td>
<td rowspan="1"><b>LATCH_RSSI</b></td>
<td colspan="8">LATCH_RSSI</td>
</tr>
<tr><td>0x05</td>
<td rowspan="1"><b>ANT1_RSSI</b></td>
<td colspan="8">ANT1_RSSI</td>
</tr>
<tr><td>0x06</td>
<td rowspan="1"><b>ANT2_RSSI</b></td>
<td colspan="8">ANT2_RSSI</td>
</tr>
<tr><td>0x07</td>
<td rowspan="2"><b>AFC_FREQ_OFFSET</b></td>
<td colspan="8">AFC_FREQ_OFFSET[15:8]</td>
</tr>
<tr><td>0x08</td>
<td colspan="8">AFC_FREQ_OFFSET[7:0]</td>
</tr>
<tr><td>0x09</td>
<td rowspan="1"><b>INFO_FLAGS</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">SYNC_TRIGGER</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-GET_MODEM_STATUS%3AMODEM_CLR_PEND">MODEM_CLR_PEND</a><ul>
<li><a name="arg-GET_MODEM_STATUS%3ARSSI_LATCH_PEND_CLR">RSSI_LATCH_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RSSI_LATCH interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_MODEM_STATUS%3APOSTAMBLE_DETECT_PEND_CLR">POSTAMBLE_DETECT_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending POSTAMBLE_DETECT interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_MODEM_STATUS%3AINVALID_SYNC_PEND_CLR">INVALID_SYNC_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending INVALID_SYNC interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_MODEM_STATUS%3ARSSI_JUMP_PEND_CLR">RSSI_JUMP_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RSSI_JUMP interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_MODEM_STATUS%3ARSSI_PEND_CLR">RSSI_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RSSI interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_MODEM_STATUS%3AINVALID_PREAMBLE_PEND_CLR">INVALID_PREAMBLE_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending INVALID_PREAMBLE interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_MODEM_STATUS%3APREAMBLE_DETECT_PEND_CLR">PREAMBLE_DETECT_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending PREAMBLE_DETECT interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_MODEM_STATUS%3ASYNC_DETECT_PEND_CLR">SYNC_DETECT_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending SYNC_DETECT interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-GET_MODEM_STATUS%3ACTS">CTS</a><ul>
<li><a name="reply-GET_MODEM_STATUS%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_MODEM_STATUS%3AMODEM_PEND">MODEM_PEND</a><ul>
<li><a name="reply-GET_MODEM_STATUS%3ARSSI_LATCH_PEND">RSSI_LATCH_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RSSI_LATCH status bit has been detected and therefore a RSSI_LATCH interrupt is pending.  See associated RSSI_LATCH status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_MODEM_STATUS%3APOSTAMBLE_DETECT_PEND">POSTAMBLE_DETECT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the POSTAMBLE_DETECT status bit has been detected and therefore a POSTAMBLE_DETECT interrupt is pending.  See associated POSTAMBLE_DETECT status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_MODEM_STATUS%3AINVALID_SYNC_PEND">INVALID_SYNC_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the INVALID_SYNC status bit has been detected and therefore a INVALID_SYNC interrupt is pending.  See associated INVALID_SYNC status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_MODEM_STATUS%3ARSSI_JUMP_PEND">RSSI_JUMP_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RSSI_JUMP status bit has been detected and therefore a RSSI_JUMP interrupt is pending.  See associated RSSI_JUMP status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_MODEM_STATUS%3ARSSI_PEND">RSSI_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RSSI status bit has been detected and therefore a RSSI interrupt is pending.  See associated RSSI status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_MODEM_STATUS%3AINVALID_PREAMBLE_PEND">INVALID_PREAMBLE_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the INVALID_PREAMBLE status bit has been detected and therefore a INVALID_PREAMBLE interrupt is pending.  See associated INVALID_PREAMBLE status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_MODEM_STATUS%3APREAMBLE_DETECT_PEND">PREAMBLE_DETECT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the PREAMBLE_DETECT status bit has been detected and therefore a PREAMBLE_DETECT interrupt is pending.  See associated PREAMBLE_DETECT status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_MODEM_STATUS%3ASYNC_DETECT_PEND">SYNC_DETECT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the SYNC_DETECT status bit has been detected and therefore a SYNC_DETECT interrupt is pending.  See associated SYNC_DETECT status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_MODEM_STATUS%3AMODEM_STATUS">MODEM_STATUS</a><ul>
<li><a name="reply-GET_MODEM_STATUS%3ARSSI_LATCH">RSSI_LATCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set if the latched RSSI value (defined in <a href="#prop-MODEM_RSSI_CONTROL">MODEM_RSSI_CONTROL</a>
 has exceeded the threshold value defined in the <a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a>
 property.  Cleared upon entry into RX state or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_MODEM_STATUS%3APOSTAMBLE_DETECT">POSTAMBLE_DETECT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set if 1-4 bytes of received data matches the pattern of bits defined in the POSTAMBLE_PATTERN_XX properties.  Postamble detection must also be enabled in the <a href="#prop-PREAMBLE_POSTAMBLE_CONFIG">PREAMBLE_POSTAMBLE_CONFIG</a>
 property.  Cleared upon entry into RX, or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_MODEM_STATUS%3AINVALID_SYNC">INVALID_SYNC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Self clearing signal that pulses high when a valid Sync Word (matching the pattern of bits defined in the SYNC_BITS_XX properties)    was not detected within the allowed search timeout period.      If configured to receive a standard preamble, the search timeout period is Sync Word Length + 4bits.      If configured to receive a non-standard preamble, the search timeout period is defined by the <a href="#prop-PREAMBLE_TX_LENGTH">PREAMBLE_TX_LENGTH</a>
 property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_MODEM_STATUS%3ARSSI_JUMP">RSSI_JUMP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Self clearing signal that pulses high when the Current RSSI value jumps by more than the threshold value defined in the <a href="#prop-MODEM_RSSI_JUMP_THRESH">MODEM_RSSI_JUMP_THRESH</a>
 property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_MODEM_STATUS%3ARSSI">RSSI</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set if the current RSSI value has exceeded the threshold value defined in the <a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a>
 property.Cleared upon entry into RX state or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_MODEM_STATUS%3AINVALID_PREAMBLE">INVALID_PREAMBLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Self clearing signal that pulses high indicating that one of the following has occurred:     a) a valid Preamble was not detected within the allowed search timeout period, or     b) the Latched RSSI value is below the <a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a>
 value and the chip has been enabled to check for this condition.     The search timeout period for Preamble is configured in <a href="#prop-PREAMBLE_CONFIG_STD_2">PREAMBLE_CONFIG_STD_2</a>
,     while the CHECK_THRESH_AT_LATCH function is configured in <a href="#prop-MODEM_RSSI_CONTROL">MODEM_RSSI_CONTROL</a>
.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_MODEM_STATUS%3APREAMBLE_DETECT">PREAMBLE_DETECT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set when a pattern of bits was received that matched the expected Preamble pattern.  If configured to receive a standard preamble, the expected pattern of bits is '...010101...' with a threshold length defined in <a href="#prop-PREAMBLE_CONFIG_STD_1">PREAMBLE_CONFIG_STD_1</a>
.  If configured to receive a non-standard preamble, the expected pattern of bits is defined by the PREAMBLE_PATTERN_XX and the <a href="#prop-PREAMBLE_CONFIG_NSTD">PREAMBLE_CONFIG_NSTD</a>
 properties. Cleared when SYNC is detected, upon entering RX state, or RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_MODEM_STATUS%3ASYNC_DETECT">SYNC_DETECT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set when the received Sync Word pattern matched the pattern of bits defined in the <a href="#prop-SYNC_BITS">SYNC_BITS</a>
 property. If <a href="#field-SYNC_CONFIG2%3ADUAL_SYNC_EN">SYNC_CONFIG2:DUAL_SYNC_EN</a>
 is enabled, the pattern in <a href="#prop-SYNC_BITS2">SYNC_BITS2</a>
 is also used to match.  Cleared when a packet is received (valid or invalid), upon entry into RX state, or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_MODEM_STATUS%3ACURR_RSSI">CURR_RSSI</a><ul>
<li><a name="reply-GET_MODEM_STATUS%3ACURR_RSSI">CURR_RSSI</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Current RSSI reading from the modem.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_MODEM_STATUS%3ALATCH_RSSI">LATCH_RSSI</a><ul>
<li><a name="reply-GET_MODEM_STATUS%3ALATCH_RSSI">LATCH_RSSI</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Latched RSSI reading from the modem as configured by <a href="#prop-MODEM_RSSI_CONTROL">MODEM_RSSI_CONTROL</a>
.  Reset to 0 upon entering RX mode or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_MODEM_STATUS%3AANT1_RSSI">ANT1_RSSI</a><ul>
<li><a name="reply-GET_MODEM_STATUS%3AANT1_RSSI">ANT1_RSSI</a>
<dl><dt>Description:</dt><dd>
<ul><li>
RSSI of ANT1 during evaluation of the antenna diversity algorithm. The RSSI value is latched during Preamble evaluation and is available for reading only after detection of Sync Word.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_MODEM_STATUS%3AANT2_RSSI">ANT2_RSSI</a><ul>
<li><a name="reply-GET_MODEM_STATUS%3AANT2_RSSI">ANT2_RSSI</a>
<dl><dt>Description:</dt><dd>
<ul><li>
RSSI of ANT2 during evaluation of the antenna diversity algorithm. The RSSI value is latched during Preamble evaluation and is available for reading only after detection of Sync Word.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_MODEM_STATUS%3AAFC_FREQ_OFFSET">AFC_FREQ_OFFSET</a><ul>
<li><a name="reply-GET_MODEM_STATUS%3AAFC_FREQ_OFFSET">AFC_FREQ_OFFSET</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The AFC value that is generated by the PLL AFC feedback loop during receive mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_MODEM_STATUS%3AINFO_FLAGS">INFO_FLAGS</a><ul>
<li><a name="reply-GET_MODEM_STATUS%3ASYNC_TRIGGER">SYNC_TRIGGER</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Defines which sync word triggered the sync detect.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SYNC_1</td><td>0</td><td align="left">
<ul><li>
Sync Word 1 triggered sync detected.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SYNC_2</td><td>1</td><td align="left">
<ul><li>
Sync Word 2 triggered sync detected.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-START_RX">START_RX</a></h4>
<ul>
<li>Number: 0x32</li>
<li>Summary: Switches to RX state and starts reception of a packet.</li>
<li>Purpose:</li>
<ul><li>
This command switches the chip to RX state and begins reception of a packet.     Depending upon the value of the START parameter, the start of reception may be delayed until a certain condition is met.
    </li><li>
Several optional parameters may be passed with this command.     If these parameter values are not sent, their previously configured values remain in use.    The parameter values are retained while in SLEEP mode, and thus only need to be written when they change.
    </li><li>
The chip may be configured to automatically enter different operational states after reception of the packet, depending upon the success or failure of the packet reception.
    </li><li>
The chip will not return CTS high until the chip has entered the RX state.
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">START_RX Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x32</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>CHANNEL</b></td>
<td colspan="8">CHANNEL</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>CONDITION</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">UPDATE</td>
<td>0</td>
<td colspan="2">START</td>
</tr>
<tr><td>0x03</td>
<td rowspan="2"><b>RX_LEN</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="5">RX_LEN[12:8]</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">RX_LEN[7:0]</td>
</tr>
<tr><td>0x05</td>
<td rowspan="1"><b>NEXT_STATE1</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="4">RXTIMEOUT_STATE</td>
</tr>
<tr><td>0x06</td>
<td rowspan="1"><b>NEXT_STATE2</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="4">RXVALID_STATE</td>
</tr>
<tr><td>0x07</td>
<td rowspan="1"><b>NEXT_STATE3</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="4">RXINVALID_STATE</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">START_RX Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-START_RX%3ACHANNEL">CHANNEL</a><ul>
<li><a name="arg-START_RX%3ACHANNEL">CHANNEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the channel number on which to receive.     Please refer to <a href="#prop-FREQ_CONTROL_CHANNEL_STEP_SIZE">FREQ_CONTROL_CHANNEL_STEP_SIZE</a>
 for more details regarding the channelized approach to frequency tuning of the chip.
    </li><li>
If the CHANNEL parameter byte is not passed with the command, the chip will tune to the last channel specified in either a <a href="#cmd-START_TX"><code>START_TX</code></a>
 or <a href="#cmd-START_RX"><code>START_RX</code></a>
 command  ;    the internal variable that retains the CHANNEL value is shared by these two commands.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
<li><a name="arg-START_RX%3ACONDITION">CONDITION</a><ul>
<li><a name="arg-START_RX%3AUPDATE">UPDATE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the condition upon which reception will start.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">UPDATE</td><td>1</td><td align="left">
<ul><li>
Update RX parameters (to be used by a subsequent packet) but do not enter RX mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">USE</td><td>0</td><td align="left">
<ul><li>
Use RX parameters to enter RX mode.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-START_RX%3ASTART">START</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the condition upon which reception will start.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">IMMEDIATE</td><td>0</td><td align="left">
<ul><li>
Start RX immediately.</li></ul>
</td></tr>
<tr valign="top"><td align="left">WUT</td><td>1</td><td align="left">
<ul><li>
Start RX when wake up timer expires.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="arg-START_RX%3ARX_LEN">RX_LEN</a><ul>
<li><a name="arg-START_RX%3ARX_LEN">RX_LEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Specifies the number of bytes to receive in the data field(s) of the packet.
    </li><li>
If this field is non-zero, the packet will be received with RX_LEN number of data bytes,    using the data field configuration options (e.g., CRC, data whitening, Manchester coding, etc.) of only PKT_FIELD_1_X.    The Payload length is limited to 8191 bytes in this scenario.
    </li><li>
If this field is zero, the number of data bytes to be received is specified by the value(s) of the PKT_FIELD_X_LENGTH properties.     The Payload length is limited to 5 x 8191 = 40955 bytes in this scenario (as each of the five data fields may be configured for a length of 8191 bytes).     This approach is necessary if field-specific processing is desired (e.g., data whitening on one field but not another, Manchester coding on one field but not another, etc).
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1fff</dd></dl>
</li>
</ul></li>
<li><a name="arg-START_RX%3ANEXT_STATE1">NEXT_STATE1</a><ul>
<li><a name="arg-START_RX%3ARXTIMEOUT_STATE">RXTIMEOUT_STATE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This parameter selects the desired operational state of the chip to automatically enter upon timeout of Preamble detection.     Please refer to <a href="#prop-PREAMBLE_CONFIG_STD_2">PREAMBLE_CONFIG_STD_2</a>
 for details regarding configuration of Preamble detection timeout.
    </li><li>
If this parameter is not passed with the command, the chip continues to use the previously configured value.     If no value has been previously configured (i.e., upon POWER_UP), the default value of 0 = Remain in RX state is used.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NOCHANGE</td><td>0</td><td align="left">
<ul><li>
Remain in RX state if RXTIMEOUT occurs.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SLEEP</td><td>1</td><td align="left">
<ul><li>
SLEEP or STANDBY state, according to the mode of operation of the 32K R-C Osc selected by <a href="#field-GLOBAL_CLK_CFG%3ACLK_32K_SEL">GLOBAL_CLK_CFG:CLK_32K_SEL</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPI_ACTIVE</td><td>2</td><td align="left">
<ul><li>
SPI ACTIVE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">READY</td><td>3</td><td align="left">
<ul><li>
READY state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">READY2</td><td>4</td><td align="left">
<ul><li>
Another enumeration for READY state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_TUNE</td><td>5</td><td align="left">
<ul><li>
TX_TUNE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_TUNE</td><td>6</td><td align="left">
<ul><li>
RX_TUNE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX</td><td>7</td><td align="left">
<ul><li>
TX state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX</td><td>8</td><td align="left">
<ul><li>
RX state (briefly exit and re-enter RX state to re-arm for acquisition of another packet).</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_IDLE</td><td>9</td><td align="left">
<ul><li>
RX_IDLE state.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="arg-START_RX%3ANEXT_STATE2">NEXT_STATE2</a><ul>
<li><a name="arg-START_RX%3ARXVALID_STATE">RXVALID_STATE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This parameter selects the desired operational state of the chip to automatically enter upon reception of a valid packet.    A packet is considered valid if the CRC check passes, and if the MATCH byte check is verified (if enabled).     If neither CRC nor MATCH functionality is enabled, a packet is considered valid when the specified number of bytes are received.
    </li><li>
If this parameter is not passed with the command, the chip continues to use the previously configured value.     If no value has been previously configured (i.e., upon POWER_UP), the default value of 3 = READY state is used.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">REMAIN</td><td>0</td><td align="left">
<ul><li>
Remain in RX state (but do not re-arm to acquire another packet).</li></ul>
</td></tr>
<tr valign="top"><td align="left">SLEEP</td><td>1</td><td align="left">
<ul><li>
SLEEP or STANDBY state, according to the mode of operotion of the 32K R-C Osc selected by <a href="#field-GLOBAL_CLK_CFG%3ACLK_32K_SEL">GLOBAL_CLK_CFG:CLK_32K_SEL</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPI_ACTIVE</td><td>2</td><td align="left">
<ul><li>
SPI ACTIVE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">READY</td><td>3</td><td align="left">
<ul><li>
READY state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">READY2</td><td>4</td><td align="left">
<ul><li>
Another enumeration for READY state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_TUNE</td><td>5</td><td align="left">
<ul><li>
TX_TUNE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_TUNE</td><td>6</td><td align="left">
<ul><li>
RX_TUNE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX</td><td>7</td><td align="left">
<ul><li>
TX state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX</td><td>8</td><td align="left">
<ul><li>
RX state (briefly exit and re-enter RX state to re-arm for acquisition of another packet).</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="arg-START_RX%3ANEXT_STATE3">NEXT_STATE3</a><ul>
<li><a name="arg-START_RX%3ARXINVALID_STATE">RXINVALID_STATE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This parameter selects the desired operational state of the chip to automatically enter upon reception of an invalid packet.     A packet is considered invalid if the CRC check fails or if the MATCH byte check fails (if enabled).
    </li><li>
If this parameter is not passed with the command, the chip continues to use the previously configured value.    If no value has been previously configured (i.e., upon POWER_UP), the default value of 3 = READY state is used. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">REMAIN</td><td>0</td><td align="left">
<ul><li>
Remain in RX state (but do not re-arm to acquire another packet).</li></ul>
</td></tr>
<tr valign="top"><td align="left">SLEEP</td><td>1</td><td align="left">
<ul><li>
SLEEP or STANDBY state, according to the mode of operotion of the 32K R-C Osc selected by <a href="#field-GLOBAL_CLK_CFG%3ACLK_32K_SEL">GLOBAL_CLK_CFG:CLK_32K_SEL</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPI_ACTIVE</td><td>2</td><td align="left">
<ul><li>
SPI ACTIVE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">READY</td><td>3</td><td align="left">
<ul><li>
READY state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">READY2</td><td>4</td><td align="left">
<ul><li>
Another enumeration for READY state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_TUNE</td><td>5</td><td align="left">
<ul><li>
TX_TUNE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_TUNE</td><td>6</td><td align="left">
<ul><li>
RX_TUNE state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX</td><td>7</td><td align="left">
<ul><li>
TX state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX</td><td>8</td><td align="left">
<ul><li>
RX state (briefly exit and re-enter RX state to re-arm for acquisition of another packet).</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-START_RX%3ACTS">CTS</a><ul>
<li><a name="reply-START_RX%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-RX_HOP">RX_HOP</a></h4>
<ul>
<li>Number: 0x36</li>
<li>Summary: Manually hop to a new frequency while in RX mode. </li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.     However, the user may desire to retain control of RX hopping within the host MCU    (e.g., when hopping on conditions that are not supported by the built-in automatic hopping functionality).
    </li><li>
This command provides for "manual" frequency hopping;    that is, quickly tuning to a new RX frequency upon request by the host MCU     (as compared to automatically hopping when certain RX conditions are met).
    </li><li>
By directly passing the frequency tuning parameters (INTE, FRAC, and VCO_CNT) with the command,     certain internal computational steps are avoided and the tuning speed of the hop is improved     (compared to simply re-issuing a <a href="#cmd-START_RX"><code>START_RX</code></a>
 command with the new desired channel number).     The values entered for these parameters should describe the desired RX channel center frequency (i.e., not the shifted RX LO frequency).
    </li><li>
Any arbitrary frequency (within the same band) may be tuned with this command;    there is no requirement for the frequencies to fall on increments of a given channel spacing.      However, the same output divider setting (as set in the <a href="#prop-MODEM_CLKGEN_BAND">MODEM_CLKGEN_BAND</a>
 property) is used for all frequencies,    and thus the tuned frequencies may not span across an output divider band break.
    </li><li>
This command is typically issued while already in RX mode    and will cause the chip to hop to the frequency specified by the parameters and start searching for a Preamble.
    </li><li>
The VCO_CNT parameter is required to support calibration of the VCO at each tuned frequency.     This is normally a parameter that is internally calculated by the chip;     however, that internal computation requires time and thus hop speed may be improved by pre-calculating and passing this parameter from the host MCU.      Please contact Silicon Labs Support for assistance with calculation of the VCO_CNT values. </li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">RX_HOP Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x36</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>INTE</b></td>
<td colspan="8">INTE</td>
</tr>
<tr><td>0x02</td>
<td rowspan="3"><b>FRAC</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="4">FRAC[19:16]</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">FRAC[15:8]</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">FRAC[7:0]</td>
</tr>
<tr><td>0x05</td>
<td rowspan="2"><b>VCO_CNT</b></td>
<td colspan="8">VCO_CNT[15:8]</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">VCO_CNT[7:0]</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">RX_HOP Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-RX_HOP%3AINTE">INTE</a><ul>
<li><a name="arg-RX_HOP%3AINTE">INTE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This parameter defines the integer portion of the total divide number for the Fractional-N PLL Synthesizer.
    </li><li>
Please refer to the text description for <a href="#prop-FREQ_CONTROL_INTE">FREQ_CONTROL_INTE</a>
 for more details regarding frequency calculation.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
<li><a name="arg-RX_HOP%3AFRAC">FRAC</a><ul>
<li><a name="arg-RX_HOP%3AFRAC">FRAC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This parameter defines the fractional portion of the total divide number for the Fractional-N PLL Synthesizer.
    </li><li>
Please refer to the text description for <a href="#prop-FREQ_CONTROL_INTE">FREQ_CONTROL_INTE</a>
 for more details regarding frequency calculation.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x80000</dd></dl>
<dl><dt>Max:</dt><dd>0xfffff</dd></dl>
</li>
</ul></li>
<li><a name="arg-RX_HOP%3AVCO_CNT">VCO_CNT</a><ul>
<li><a name="arg-RX_HOP%3AVCO_CNT">VCO_CNT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This parameter defines the target count required by the VCO Calibration algorithm.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-RX_HOP%3ACTS">CTS</a><ul>
<li><a name="reply-RX_HOP%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-READ_RX_FIFO">READ_RX_FIFO</a></h4>
<ul>
<li>Number: 0x77</li>
<li>Summary: Reads data byte(s) from the RX FIFO.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for two separate 64-byte FIFO memories for the purpose of storing transmit and receive data.     (When the <a href="#field-GLOBAL_CONFIG%3AFIFO_MODE">GLOBAL_CONFIG:FIFO_MODE</a>
 bit is set, these two FIFOs are combined into a single 129-byte shared FIFO.)</li><li>
This command is used to read data byte(s) from the RX FIFO.     The READ_RX_FIFO command should be clocked in on SDI and the reply should be clocked out on SDO without deasserting NSEL.    If you read more data bytes than the RX FIFO contains it will generate a FIFO Underflow interrupt event.
    </li><li>
This command does not cause CTS to go low, and can be sent while CTS is low.     This command has no response to be read and thus there is no need to monitor CTS after sending this command.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">READ_RX_FIFO Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x77</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">READ_RX_FIFO Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
</ul>
</li>
</ul>
<hr />
<h3><a name="cset-ADVANCED_COMMANDS">ADVANCED_COMMANDS</a></h3>
<h4><a name="cmd-GET_ADC_READING">GET_ADC_READING</a></h4>
<ul>
<li>Number: 0x14</li>
<li>Summary: Performs conversions using the Auxiliary ADC and returns the results of those conversions.</li>
<li>Purpose:</li>
<ul><li>
The chip provides an Auxiliary Analog-to-Digital Converter (ADC) for the purpose    of measuring various analog parameters and returning their values in digital form.     The ADC utilizes a Successive Approximation Register (SAR) architecture and achieves 11-bit resolution,    with a 9-bit Effective Number of Bits (ENOB).
    </li><li>
The ADC may be configured to measure the internal battery voltage, an internal temperature sensor,    or an external voltage applied to a selected GPIO pin.     More than one type of measurement may be enabled at the same time;    the conversions will be performed sequentially and all converted values returned.
    </li><li>
The ADC is capable of converting any battery voltage within the chip's operating supply voltage range of 1.8VDC to 3.6VDC.
    </li><li>
The GPIO pin carrying the external voltage to be measured is selected by the ADC_GPIO_PIN parameter,    and must also be configured as an input pin or tri-state pin (through the GPIO_PIN_CFG command).
    </li><li>
The voltage on the selected GPIO pin may be internally attenuated prior to conversion, thus effectively extending the range of voltages which may be converted.     The attenuation factor is configurable through the GPIO_ATT parameter.</li></ul>
<li>Comments (internal):</li>
<ul><li>
 The chip returns values for the slope and intercept of the TEMP_degC-vs-TEMP_ADC equation.     These values are not calculated by the chip, but simply return the corresponding values    (stored in OTP variable space) as part of the GET_ADC_READING reply stream.     In this fashion, the OTP_VARS_AUXADC_TEMP_SLOPE and OTP_VARS_AUXADC_TEMP_INTERCEPT parameters provides a means for factory calibration of the temperature sensor performance, if desired.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">GET_ADC_READING Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x14</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>ADC_EN</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">TEMPERATURE_EN</td>
<td colspan="1">BATTERY_VOLTAGE_EN</td>
<td colspan="1">ADC_GPIO_EN</td>
<td colspan="2">ADC_GPIO_PIN</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>ADC_CFG</b></td>
<td colspan="4">UDTIME</td>
<td colspan="4">GPIO_ATT</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">GET_ADC_READING Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="2"><b>GPIO_ADC</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="3">GPIO_ADC[10:8]</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">GPIO_ADC[7:0]</td>
</tr>
<tr><td>0x03</td>
<td rowspan="2"><b>BATTERY_ADC</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="3">BATTERY_ADC[10:8]</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">BATTERY_ADC[7:0]</td>
</tr>
<tr><td>0x05</td>
<td rowspan="2"><b>TEMP_ADC</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="3">TEMP_ADC[10:8]</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">TEMP_ADC[7:0]</td>
</tr>
<tr><td>0x07</td>
<td rowspan="1"><b>TEMP_SLOPE</b></td>
<td colspan="8">TEMP_SLOPE</td>
</tr>
<tr><td>0x08</td>
<td rowspan="1"><b>TEMP_INTERCEPT</b></td>
<td colspan="8">TEMP_INTERCEPT</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-GET_ADC_READING%3AADC_EN">ADC_EN</a><ul>
<li><a name="arg-GET_ADC_READING%3ATEMPERATURE_EN">TEMPERATURE_EN</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not perform ADC conversion of the temperature.  The reply value in TEMP_ADC will always be 0x000.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Perform ADC conversion of the temperature.     The reply value in TEMP_ADC will be TEMP(degC) = (899/4096)*TEMP_ADC - 293.</li></ul>
Comments: 
<ul><li>
Perform ADC conversion of the temperature.     The reply value in TEMP_ADC will be TEMP(degC) = ((800 + TEMP_SLOPE)/4096) * TEMP_ADC - (TEMP_INTERCEPT/2 + 256),    where TEMP_SLOPE and TEMP_INTERCEPT are defined in the OTP variable space (and also returned in the GET_ADC_READING reply stream).</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-GET_ADC_READING%3ABATTERY_VOLTAGE_EN">BATTERY_VOLTAGE_EN</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not perform ADC conversion of the battery voltage.  The reply value in BATTERY_ADC will always be 0x000.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Perform ADC conversion of the battery voltage.  The reply value in BATTERY_ADC will be VBAT(V) = 3*BATTERY_ADC/1280.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-GET_ADC_READING%3AADC_GPIO_EN">ADC_GPIO_EN</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not perform ADC conversion of the voltage applied to the selected GPIO pin.  The reply value in GPIO_ADC will always be 0x000. </li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Perform ADC conversion of the voltage applied to the selected GPIO pin.     The reply value in GPIO_ADC will be VGPIO(V) = GPIO_ADC/GPIO_ADC_DIV,     where GPIO_ADC_DIV is an attenuation factor defined by the selection of the GPIO_ATT parameter. </li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-GET_ADC_READING%3AADC_GPIO_PIN">ADC_GPIO_PIN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Select the GPIO pin on which to perform conversion of an externally applied voltage.
    </li><li>
The selected GPIO pin must also be configured as an input pin or tri-state pin (through use of the GPIO_PIN_CFG command).
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
The voltage on GPIO0 will be converted by the ADC. </li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
The voltage on GPIO1 will be converted by the ADC. </li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
The voltage on GPIO2 will be converted by the ADC. </li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
The voltage on GPIO3 will be converted by the ADC. </li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="arg-GET_ADC_READING%3AADC_CFG">ADC_CFG</a><ul>
<li><a name="arg-GET_ADC_READING%3AUDTIME">UDTIME</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the rate of ADC conversion, where ADC_RATE = SYS_CLK / 12 / 2^(UDTIME + 1).      Selecting shorter conversion times (i.e., faster conversion rates)     will result in lower ADC resolution and longer conversion times will result in higher ADC resolution.
    </li><li>
An ADC conversion rate of 305 Hz (UDTIME = 0xC) to 1.22 kHz (UDTIME = 0xA) is recommended.
    </li><li>
If the ADC_CFG parameter byte is not sent, or is set ADC_CFG = 0x00,     the UDTIME parameter will assume a default value of 0xC = 305 Hz ADC conversion rate     (for nominal SYS_CLK = 30 MHz).
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="arg-GET_ADC_READING%3AGPIO_ATT">GPIO_ATT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the attenuation factor to be internally applied to the voltage on the GPIO pin, prior to conversion by the ADC.    This effectively extends the range of voltages which may be converted.
    </li><li>
If the ADC_CFG parameter byte is not sent, or is set ADC_CFG = 0x00, the GPIO_ATT parameter will assume a default value of 0x5 = 0 to 3.2V range.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">0P8</td><td>0</td><td align="left">
<ul><li>
ADC measurement range is 0 to 0.8 V.  GPIO_ADC_DIV = 2560.</li></ul>
</td></tr>
<tr valign="top"><td align="left">1P6</td><td>4</td><td align="left">
<ul><li>
ADC measurement range is 0 to 1.6 V.  GPIO_ADC_DIV = 1280.</li></ul>
</td></tr>
<tr valign="top"><td align="left">3P2</td><td>5</td><td align="left">
<ul><li>
ADC measurement range is 0 to 3.2 V.  GPIO_ADC_DIV = 640.</li></ul>
</td></tr>
<tr valign="top"><td align="left">2P4</td><td>8</td><td align="left">
<ul><li>
ADC measurement range is 0 to 2.4 V.  GPIO_ADC_DIV = 853.33.</li></ul>
</td></tr>
<tr valign="top"><td align="left">3P6</td><td>9</td><td align="left">
<ul><li>
ADC measurement range is 0 to 3.6 V.  GPIO_ADC_DIV = 426.66.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-GET_ADC_READING%3ACTS">CTS</a><ul>
<li><a name="reply-GET_ADC_READING%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_ADC_READING%3AGPIO_ADC">GPIO_ADC</a><ul>
<li><a name="reply-GET_ADC_READING%3AGPIO_ADC">GPIO_ADC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Returns the voltage on the selected GPIO pin, as converted by the Auxiliary ADC.
    </li><li>
The reply value will be VGPIO(V) = GPIO_ADC/GPIO_ADC_DIV, where GPIO_ADC_DIV is an attenuation factor defined by the selection of the GPIO_ATT parameter. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_ADC_READING%3ABATTERY_ADC">BATTERY_ADC</a><ul>
<li><a name="reply-GET_ADC_READING%3ABATTERY_ADC">BATTERY_ADC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Returns the battery voltage, as converted by the Auxiliary ADC.
    </li><li>
The reply value will be VBAT(V) = 3*BATTERY_ADC/1280. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_ADC_READING%3ATEMP_ADC">TEMP_ADC</a><ul>
<li><a name="reply-GET_ADC_READING%3ATEMP_ADC">TEMP_ADC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Returns the temperature, as converted by the Auxiliary ADC.The reply value will be TEMP(degC) = (899/4096)*TEMP_ADC - 293. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_ADC_READING%3ATEMP_SLOPE">TEMP_SLOPE</a><ul>
<li><a name="reply-GET_ADC_READING%3ATEMP_SLOPE">TEMP_SLOPE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Slope in the equation that relates the converted TEMP_ADC value to the corresponding temperature (i.e., TEMP_degC = SLOPE*TEMP_ADC + INTERCEPT).
    </li><li>
The TEMP_SLOPE value returned in the reply stream for GET_ADC_READING is defined by an OTP variable     (OTP_VARS_AUXADC_TEMP_SLOPE) and thus provides for factory calibration of the temperature sensor performance, if desired. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_ADC_READING%3ATEMP_INTERCEPT">TEMP_INTERCEPT</a><ul>
<li><a name="reply-GET_ADC_READING%3ATEMP_INTERCEPT">TEMP_INTERCEPT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Intercept in the equation that relates the converted TEMP_ADC value to the corresponding temperature (i.e., TEMP_degC = SLOPE*TEMP_ADC + INTERCEPT).
    </li><li>
The TEMP_INTERCEPT value returned in the reply stream for GET_ADC_READING is defined by an OTP variable (OTP_VARS_AUXADC_TEMP_INTERCEPT)    and thus provides for factory calibration of the temperature sensor performance, if desired. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-PROTOCOL_CFG">PROTOCOL_CFG</a></h4>
<ul>
<li>Number: 0x18</li>
<li>Summary: Sets the chip up for specified protocol.</li>
<li>Purpose:</li>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">PROTOCOL_CFG Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x18</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>PROTOCOL</b></td>
<td colspan="8">PROTOCOL</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">PROTOCOL_CFG Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-PROTOCOL_CFG%3APROTOCOL">PROTOCOL</a><ul>
<li><a name="arg-PROTOCOL_CFG%3APROTOCOL">PROTOCOL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects which protocol to configure the chip for.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">GENERIC</td><td>0</td><td align="left">
<ul><li>
Packet format is generic, no dynamic reprogramming of packet handler properties.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154G</td><td>1</td><td align="left">
<ul><li>
Packet format is IEEE802.15.4g compliant. The following properties are overriden: PKT_CRC_CONFIG, CRC_ENDIAN/BIT_ORDER in PKT_CONFG1 for TX and RX, PKT_FIELD_1_CRC_CONFIG for RX. Other applicable properties in the packet handler group still need to be programmed. Field 1 should have the length of 16 bits to contain the PHR with PKT_LEN_FIELD_SOURCE set to 1 for RX. PSDU field shall use Field 2 with variable length. Field 2 length should be set to the maximum allowed including the anticipated FCS length. It is anticipated that the FCS will be calculated by the host and transmitted over the air.  PHR and FCS will be put in the FIFO for the host to retrieve and check. Therefore, CRC shouldn't be enabled.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-PROTOCOL_CFG%3ACTS">CTS</a><ul>
<li><a name="reply-PROTOCOL_CFG%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-GET_PH_STATUS">GET_PH_STATUS</a></h4>
<ul>
<li>Number: 0x21</li>
<li>Summary: Returns the interrupt status of the Packet Handler Interrupt Group (both STATUS and PENDING).  Optionally, it may be used to clear latched (PENDING) interrupt events.</li>
<li>Purpose:</li>
<ul><li>
Returns the current interrupt status of Packet Handler interrupt events (both STATUS and PENDING) and optionally clears PENDING interrupts.</li><li>
Please refer to the <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 command for more details regarding the difference between STATUS and PENDING interrupts.</li><li>
Sending the <a href="#cmd-GET_PH_STATUS"><code>GET_PH_STATUS</code></a>
 command with NO input parameter results in clearing all of the PENDING interrupts.</li><li>
When PENDING interrupts are being cleared, the reply stream reflects their status prior to clearing.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">GET_PH_STATUS Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x21</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>PH_CLR_PEND</b></td>
<td colspan="1">FILTER_MATCH_PEND_CLR</td>
<td colspan="1">FILTER_MISS_PEND_CLR</td>
<td colspan="1">PACKET_SENT_PEND_CLR</td>
<td colspan="1">PACKET_RX_PEND_CLR</td>
<td colspan="1">CRC_ERROR_PEND_CLR</td>
<td colspan="1">ALT_CRC_ERROR_PEND_CLR</td>
<td colspan="1">TX_FIFO_ALMOST_EMPTY_PEND_CLR</td>
<td colspan="1">RX_FIFO_ALMOST_FULL_PEND_CLR</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">GET_PH_STATUS Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>PH_PEND</b></td>
<td colspan="1">FILTER_MATCH_PEND</td>
<td colspan="1">FILTER_MISS_PEND</td>
<td colspan="1">PACKET_SENT_PEND</td>
<td colspan="1">PACKET_RX_PEND</td>
<td colspan="1">CRC_ERROR_PEND</td>
<td colspan="1">ALT_CRC_ERROR_PEND</td>
<td colspan="1">TX_FIFO_ALMOST_EMPTY_PEND</td>
<td colspan="1">RX_FIFO_ALMOST_FULL_PEND</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>PH_STATUS</b></td>
<td colspan="1">FILTER_MATCH</td>
<td colspan="1">FILTER_MISS</td>
<td colspan="1">PACKET_SENT</td>
<td colspan="1">PACKET_RX</td>
<td colspan="1">CRC_ERROR</td>
<td colspan="1">ALT_CRC_ERROR</td>
<td colspan="1">TX_FIFO_ALMOST_EMPTY</td>
<td colspan="1">RX_FIFO_ALMOST_FULL</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-GET_PH_STATUS%3APH_CLR_PEND">PH_CLR_PEND</a><ul>
<li><a name="arg-GET_PH_STATUS%3AFILTER_MATCH_PEND_CLR">FILTER_MATCH_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending FILTER_MATCH interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_PH_STATUS%3AFILTER_MISS_PEND_CLR">FILTER_MISS_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending FILTER_MISS interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_PH_STATUS%3APACKET_SENT_PEND_CLR">PACKET_SENT_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending PACKET_SENT interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_PH_STATUS%3APACKET_RX_PEND_CLR">PACKET_RX_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending PACKET_RX interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_PH_STATUS%3ACRC_ERROR_PEND_CLR">CRC_ERROR_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending CRC_ERROR interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_PH_STATUS%3AALT_CRC_ERROR_PEND_CLR">ALT_CRC_ERROR_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending ALT_CRC_ERROR interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_PH_STATUS%3ATX_FIFO_ALMOST_EMPTY_PEND_CLR">TX_FIFO_ALMOST_EMPTY_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending TX_FIFO_ALMOST_EMPTY interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_PH_STATUS%3ARX_FIFO_ALMOST_FULL_PEND_CLR">RX_FIFO_ALMOST_FULL_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RX_FIFO_ALMOST_FULL interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-GET_PH_STATUS%3ACTS">CTS</a><ul>
<li><a name="reply-GET_PH_STATUS%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_PH_STATUS%3APH_PEND">PH_PEND</a><ul>
<li><a name="reply-GET_PH_STATUS%3AFILTER_MATCH_PEND">FILTER_MATCH_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the FILTER_MATCH status bit has been detected and therefore a FILTER_MATCH interrupt is pending.  See associated FILTER_MATCH status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_PH_STATUS%3AFILTER_MISS_PEND">FILTER_MISS_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the FILTER_MISS status bit has been detected and therefore a FILTER_MISS interrupt is pending.  See associated FILTER_MISS status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_PH_STATUS%3APACKET_SENT_PEND">PACKET_SENT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the PACKET_SENT status bit has been detected and therefore a PACKET_SENT interrupt is pending.  See associated PACKET_SENT status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_PH_STATUS%3APACKET_RX_PEND">PACKET_RX_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the PACKET_RX status bit has been detected and therefore a PACKET_RX interrupt is pending.  See associated PACKET_RX status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_PH_STATUS%3ACRC_ERROR_PEND">CRC_ERROR_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the CRC_ERROR status bit has been detected and therefore a CRC_ERROR interrupt is pending.  See associated CRC_ERROR status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_PH_STATUS%3AALT_CRC_ERROR_PEND">ALT_CRC_ERROR_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the ALT_CRC_ERROR status bit has been detected and therefore a ALT_CRC_ERROR interrupt is pending.  See associated ALT_CRC_ERROR status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_PH_STATUS%3ATX_FIFO_ALMOST_EMPTY_PEND">TX_FIFO_ALMOST_EMPTY_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the TX_FIFO_ALMOST_EMPTY status bit has been detected and therefore a TX_FIFO_ALMOST_EMPTY interrupt is pending.  See associated TX_FIFO_ALMOST_EMPTY status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_PH_STATUS%3ARX_FIFO_ALMOST_FULL_PEND">RX_FIFO_ALMOST_FULL_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RX_FIFO_ALMOST_FULL status bit has been detected and therefore a RX_FIFO_ALMOST_FULL interrupt is pending.  See associated RX_FIFO_ALMOST_FULL status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_PH_STATUS%3APH_STATUS">PH_STATUS</a><ul>
<li><a name="reply-GET_PH_STATUS%3AFILTER_MATCH">FILTER_MATCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate the incoming packet matched filter.  Cleared upon entry into RX state, or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_PH_STATUS%3AFILTER_MISS">FILTER_MISS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate the incoming packet was discarded because filter did not match.  Cleared upon entry into RX state, or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_PH_STATUS%3APACKET_SENT">PACKET_SENT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate that data bytes in the TX FIFO were transmitted successfully.  Cleared upon entry into TX state.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_PH_STATUS%3APACKET_RX">PACKET_RX</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate that the expected number of data bytes have been successfully received and placed in the RX FIFO.  All enabled Packet Handler functions (e.g., CRC check, Filter Matching) must be successfully completed in order to generate a PACKET_RX interrupt.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_PH_STATUS%3ACRC_ERROR">CRC_ERROR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate that the received CRC checksum byte(s) do not match the calculated CRC checksum value.  Cleared upon entry into RX state or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_PH_STATUS%3AALT_CRC_ERROR">ALT_CRC_ERROR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate that the received CRC checksum byte(s) do not match the calculated alternate CRC checksum value. For the difference between the two CRC engines (CRC, ALT_CRC), see <a href="#prop-PKT_CRC_CONFIG">PKT_CRC_CONFIG</a>
 property.  Cleared upon entry into RX state or if RX is restarted.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_PH_STATUS%3ATX_FIFO_ALMOST_EMPTY">TX_FIFO_ALMOST_EMPTY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate that the amount of space in the TX FIFO is equal to or greater than the <a href="#prop-PKT_TX_THRESHOLD">PKT_TX_THRESHOLD</a>
 value. This interrupt may be used to signal the host MCU to store more data bytes into the TX FIFO,    thus providing a means for handling packets with lengths greater than the size of the TX FIFO (i.e., 64 bytes, or 129 bytes in shared FIFO mode). Cleared if the amount of space in the TX FIFO is more than the <a href="#prop-PKT_TX_THRESHOLD">PKT_TX_THRESHOLD</a>
 value. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_PH_STATUS%3ARX_FIFO_ALMOST_FULL">RX_FIFO_ALMOST_FULL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate that the number of bytes stored in the RX FIFO is equal to or greater than the <a href="#prop-PKT_RX_THRESHOLD">PKT_RX_THRESHOLD</a>
 value. This interrupt may be used to signal the host MCU to read more data bytes from the RX FIFO,    thus providing a means for handling packets with lengths greater than the size of the RX FIFO (i.e., 64 bytes, or 129 bytes in shared FIFO mode). Cleared if the amount of data in the RX FIFO is less than the <a href="#prop-PKT_RX_THRESHOLD">PKT_RX_THRESHOLD</a>
 value. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-GET_CHIP_STATUS">GET_CHIP_STATUS</a></h4>
<ul>
<li>Number: 0x23</li>
<li>Summary: Returns the interrupt status of the Chip Interrupt Group (both STATUS and PENDING).  Optionally, it may be used to clear latched (PENDING) interrupt events.</li>
<li>Purpose:</li>
<ul><li>
Returns the current interrupt status of Chip interrupt events (both STATUS and PENDING) and optionally clears PENDING interrupts.               </li><li>
Please refer to the <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 command for more details regarding the difference between STATUS and PENDING interrupts.               </li><li>
Sending the <a href="#cmd-GET_CHIP_STATUS"><code>GET_CHIP_STATUS</code></a>
 command with NO input parameter results in clearing all of the PENDING interrupts.               </li><li>
When PENDING interrupts are being cleared, the reply stream reflects their status prior to clearing.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">GET_CHIP_STATUS Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x23</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>CHIP_CLR_PEND</b></td>
<td>0</td>
<td colspan="1">CAL_PEND_CLR</td>
<td colspan="1">FIFO_UNDERFLOW_OVERFLOW_ERROR_PEND_CLR</td>
<td colspan="1">STATE_CHANGE_PEND_CLR</td>
<td colspan="1">CMD_ERROR_PEND_CLR</td>
<td colspan="1">CHIP_READY_PEND_CLR</td>
<td colspan="1">LOW_BATT_PEND_CLR</td>
<td colspan="1">WUT_PEND_CLR</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">GET_CHIP_STATUS Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>CHIP_PEND</b></td>
<td>0</td>
<td colspan="1">CAL_PEND</td>
<td colspan="1">FIFO_UNDERFLOW_OVERFLOW_ERROR_PEND</td>
<td colspan="1">STATE_CHANGE_PEND</td>
<td colspan="1">CMD_ERROR_PEND</td>
<td colspan="1">CHIP_READY_PEND</td>
<td colspan="1">LOW_BATT_PEND</td>
<td colspan="1">WUT_PEND</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>CHIP_STATUS</b></td>
<td>0</td>
<td colspan="1">CAL</td>
<td colspan="1">FIFO_UNDERFLOW_OVERFLOW_ERROR</td>
<td colspan="1">STATE_CHANGE</td>
<td colspan="1">CMD_ERROR</td>
<td colspan="1">CHIP_READY</td>
<td colspan="1">LOW_BATT</td>
<td colspan="1">WUT</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>CMD_ERR_STATUS</b></td>
<td colspan="8">CMD_ERR_STATUS</td>
</tr>
<tr><td>0x04</td>
<td rowspan="1"><b>CMD_ERR_CMD_ID</b></td>
<td colspan="8">CMD_ERR_CMD_ID</td>
</tr>
<tr><td>0x05</td>
<td rowspan="1"><b>INFO_FLAGS</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CAL_TYPE</td>
<td>0</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-GET_CHIP_STATUS%3ACHIP_CLR_PEND">CHIP_CLR_PEND</a><ul>
<li><a name="arg-GET_CHIP_STATUS%3ACAL_PEND_CLR">CAL_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending CAL interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_CHIP_STATUS%3AFIFO_UNDERFLOW_OVERFLOW_ERROR_PEND_CLR">FIFO_UNDERFLOW_OVERFLOW_ERROR_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending FIFO_UNDERFLOW_OVERFLOW_ERROR interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_CHIP_STATUS%3ASTATE_CHANGE_PEND_CLR">STATE_CHANGE_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending STATE_CHANGE interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_CHIP_STATUS%3ACMD_ERROR_PEND_CLR">CMD_ERROR_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending CMD_ERROR interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_CHIP_STATUS%3ACHIP_READY_PEND_CLR">CHIP_READY_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending CHIP_READY interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_CHIP_STATUS%3ALOW_BATT_PEND_CLR">LOW_BATT_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending LOW_BATT interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-GET_CHIP_STATUS%3AWUT_PEND_CLR">WUT_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending WUT interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-GET_CHIP_STATUS%3ACTS">CTS</a><ul>
<li><a name="reply-GET_CHIP_STATUS%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_CHIP_STATUS%3ACHIP_PEND">CHIP_PEND</a><ul>
<li><a name="reply-GET_CHIP_STATUS%3ACAL_PEND">CAL_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the CAL status bit has been detected and therefore a CAL interrupt is pending.  See associated CAL status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_CHIP_STATUS%3AFIFO_UNDERFLOW_OVERFLOW_ERROR_PEND">FIFO_UNDERFLOW_OVERFLOW_ERROR_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the FIFO_UNDERFLOW_OVERFLOW_ERROR status bit has been detected and therefore a FIFO_UNDERFLOW_OVERFLOW_ERROR interrupt is pending.  See associated FIFO_UNDERFLOW_OVERFLOW_ERROR status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_CHIP_STATUS%3ASTATE_CHANGE_PEND">STATE_CHANGE_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the STATE_CHANGE status bit has been detected and therefore a STATE_CHANGE interrupt is pending.  See associated STATE_CHANGE status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_CHIP_STATUS%3ACMD_ERROR_PEND">CMD_ERROR_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the CMD_ERROR status bit has been detected and therefore a CMD_ERROR interrupt is pending.  See associated CMD_ERROR status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_CHIP_STATUS%3ACHIP_READY_PEND">CHIP_READY_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the CHIP_READY status bit has been detected and therefore a CHIP_READY interrupt is pending.  See associated CHIP_READY status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_CHIP_STATUS%3ALOW_BATT_PEND">LOW_BATT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the LOW_BATT status bit has been detected and therefore a LOW_BATT interrupt is pending.  See associated LOW_BATT status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_CHIP_STATUS%3AWUT_PEND">WUT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the WUT status bit has been detected and therefore a WUT interrupt is pending.  See associated WUT status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_CHIP_STATUS%3ACHIP_STATUS">CHIP_STATUS</a><ul>
<li><a name="reply-GET_CHIP_STATUS%3ACAL">CAL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Self clearing signal that pulses high to indicate a RC32K calibration event is pending. If this occurs, the RC32K oscillator will be calibrated on the next transition to Sleep/Standby state.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_CHIP_STATUS%3AFIFO_UNDERFLOW_OVERFLOW_ERROR">FIFO_UNDERFLOW_OVERFLOW_ERROR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate that the number of received or transmitted bytes exceeds the size of the RX or TX FIFO, respectively (i.e., 64 bytes for each FIFO, or 129 bytes when sharing the FIFO).  Upon such an underflow/overflow event, the FIFO(s) will need to be reset.  Cleared by issuing a <a href="#cmd-FIFO_INFO"><code>FIFO_INFO</code></a>
 command to reset the FIFOs.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_CHIP_STATUS%3ASTATE_CHANGE">STATE_CHANGE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate a successful transition from one state to another operating state.  Cleared when a state transition is in progress.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_CHIP_STATUS%3ACMD_ERROR">CMD_ERROR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Self clearing signal that pulses high to indicate an error has occurred in the processing of a command. For example, an incorrect command/property ID is sent, or an attempt was made to write a property that is outside of the given property group.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_CHIP_STATUS%3ACHIP_READY">CHIP_READY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate the chip (upon completion of the POWER_UP sequence) has reached the state where it is ready to accept commands, or when the IR calibration process is completed.  Cleared when the chip is shutdown or when IR calibration has begun.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_CHIP_STATUS%3ALOW_BATT">LOW_BATT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate the battery voltage is below the threshold set by <a href="#prop-GLOBAL_LOW_BATT_THRESH">GLOBAL_LOW_BATT_THRESH</a>
.  Cleared to indicate the battery voltage is above the threshold set by <a href="#prop-GLOBAL_LOW_BATT_THRESH">GLOBAL_LOW_BATT_THRESH</a>
.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-GET_CHIP_STATUS%3AWUT">WUT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Self clearing signal that pulses high to indicate the WUT (Wake-up timer) has expired.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_CHIP_STATUS%3ACMD_ERR_STATUS">CMD_ERR_STATUS</a><ul>
<li><a name="reply-GET_CHIP_STATUS%3ACMD_ERR_STATUS">CMD_ERR_STATUS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Last command error cause.  Only valid if CMD_ERROR status bit is set.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">CMD_ERROR_NONE</td><td>0</td><td align="left">
<ul><li>
No error.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CMD_ERROR_BAD_COMMAND</td><td>16</td><td align="left">
<ul><li>
Bad command issued.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CMD_ERROR_BAD_ARG</td><td>17</td><td align="left">
<ul><li>
Argment(s) in issued command were invalid.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CMD_ERROR_COMMAND_BUSY</td><td>18</td><td align="left">
<ul><li>
Command was issued before previous command was completed.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CMD_ERROR_INVALID_STATE</td><td>19</td><td align="left">
<ul><li>
Command issued was not allowed while in the current device state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CMD_ERROR_BAD_NVM</td><td>32</td><td align="left">
<ul><li>
Bad NVM detected.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CMD_ERROR_BAD_PATCH</td><td>48</td><td align="left">
<ul><li>
Bad patch detected.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CMD_ERROR_BAD_BOOTMODE</td><td>49</td><td align="left">
<ul><li>
Invalid bootmode supplied.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CMD_ERROR_BAD_PROPERTY</td><td>64</td><td align="left">
<ul><li>
Bad Property ID was provided.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CMD_ERROR_INTERNAL_PH_FIFO</td><td>240</td><td align="left">
<ul><li>
Occurs when the internal packet handler FIFOs underflow or overflow.  Can be caused by a user FIFO underflow on TX or the firmware not keeping up with the datarate.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="reply-GET_CHIP_STATUS%3ACMD_ERR_CMD_ID">CMD_ERR_CMD_ID</a><ul>
<li><a name="reply-GET_CHIP_STATUS%3ACMD_ERR_CMD_ID">CMD_ERR_CMD_ID</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Command ID that was being proccessed at the time of the last command error.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
</dl>
</li>
</ul></li>
<li><a name="reply-GET_CHIP_STATUS%3AINFO_FLAGS">INFO_FLAGS</a><ul>
<li><a name="reply-GET_CHIP_STATUS%3ACAL_TYPE">CAL_TYPE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Defines which calibration is required.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">OFFLINE_CAL</td><td>0</td><td align="left">
<ul><li>
Offline calibration.</li></ul>
</td></tr>
<tr valign="top"><td align="left">OFFLINE2_CAL</td><td>1</td><td align="left">
<ul><li>
Offline2 calibration.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="cset-IE154_COMMANDS">IE154_COMMANDS</a></h3>
<h4><a name="cmd-IE154_START_TX">IE154_START_TX</a></h4>
<ul>
<li>Number: 0x80</li>
<li>Summary: INTERNAL STATUS: Implemented. Transitions to complete and fail states not fully tested
                           Needs argument (cca backoff time) clean-up
                        Starts transmission using 802.15.4 parameters</li>
<li>Purpose:</li>
<ul><li>
INTERNAL STATUS: Implemented. Transitions to complete and fail states not fully tested
                           Needs argument (cca backoff time) clean-up
                        Starts transmission using 802.15.4 parameters.</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented. Transitions to complete and fail states not fully tested
                           Needs argument (cca backoff time) clean-up
                        </li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_START_TX Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x80</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>OPTIONS</b></td>
<td>0</td>
<td colspan="1">WAIT_FOR_ACK</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="3">NUM_CCA_CHECKS</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>NETWORK_INDEX</b></td>
<td colspan="8">NETWORK_INDEX</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>NEXT_MODE</b></td>
<td colspan="4">TX_FAIL_MODE</td>
<td colspan="4">TX_COMPLETE_MODE</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_START_TX Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-IE154_START_TX%3AOPTIONS">OPTIONS</a><ul>
<li><a name="arg-IE154_START_TX%3AWAIT_FOR_ACK">WAIT_FOR_ACK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Wait for acknowledge after transmission</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DONT_WAIT</td><td>0</td><td align="left">
<ul><li>
Don't wait for Acknowledge after transmission</li></ul>
</td></tr>
<tr valign="top"><td align="left">WAIT</td><td>1</td><td align="left">
<ul><li>
Wait for Acknowledge after transmission</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IE154_START_TX%3ANUM_CCA_CHECKS">NUM_CCA_CHECKS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Number of backoff periods used on CSMA-CA </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x5</dd></dl>
</li>
</ul></li>
<li><a name="arg-IE154_START_TX%3ANETWORK_INDEX">NETWORK_INDEX</a><ul>
<li><a name="arg-IE154_START_TX%3ANETWORK_INDEX">NETWORK_INDEX</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Network index, used to specify transmit parameters like channel and power</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x3</dd></dl>
</li>
</ul></li>
<li><a name="arg-IE154_START_TX%3ANEXT_MODE">NEXT_MODE</a><ul>
<li><a name="arg-IE154_START_TX%3ATX_FAIL_MODE">TX_FAIL_MODE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Next mode if operation fails</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SLEEP</td><td>1</td><td align="left">
<ul><li>
Switch to sleep mode</li></ul>
</td></tr>
<tr valign="top"><td align="left">IDLE</td><td>2</td><td align="left">
<ul><li>
Switch to idle mode</li></ul>
</td></tr>
<tr valign="top"><td align="left">LISTEN</td><td>3</td><td align="left">
<ul><li>
Switch to listen mode</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IE154_START_TX%3ATX_COMPLETE_MODE">TX_COMPLETE_MODE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Next mode if operation succeeds</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SLEEP</td><td>1</td><td align="left">
<ul><li>
Switch to sleep mode</li></ul>
</td></tr>
<tr valign="top"><td align="left">IDLE</td><td>2</td><td align="left">
<ul><li>
Switch to idle mode</li></ul>
</td></tr>
<tr valign="top"><td align="left">LISTEN</td><td>3</td><td align="left">
<ul><li>
Switch to listen mode</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-IE154_START_TX%3ACTS">CTS</a><ul>
<li><a name="reply-IE154_START_TX%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-IE154_START_RX">IE154_START_RX</a></h4>
<ul>
<li>Number: 0x81</li>
<li>Summary: INTERNAL STATUS: Implemented. Need to test transitions to "rx_complete" modes
                        Starts reception using 802.15.4 parameters</li>
<li>Purpose:</li>
<ul><li>
INTERNAL STATUS: Implemented. Need to test transitions to "rx_complete" modes
                        Starts reception using 802.15.4 parameters.</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented. Need to test transitions to "rx_complete" modes
                        </li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_START_RX Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x81</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>CHANNEL</b></td>
<td colspan="8">CHANNEL</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>NEXT_MODE</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="4">RX_COMPLETE_MODE</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_START_RX Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-IE154_START_RX%3ACHANNEL">CHANNEL</a><ul>
<li><a name="arg-IE154_START_RX%3ACHANNEL">CHANNEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Channel ID</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
<li><a name="arg-IE154_START_RX%3ANEXT_MODE">NEXT_MODE</a><ul>
<li><a name="arg-IE154_START_RX%3ARX_COMPLETE_MODE">RX_COMPLETE_MODE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Next mode if operation succeeds</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SLEEP</td><td>1</td><td align="left">
<ul><li>
Switch to sleep mode</li></ul>
</td></tr>
<tr valign="top"><td align="left">IDLE</td><td>2</td><td align="left">
<ul><li>
Switch to idle mode</li></ul>
</td></tr>
<tr valign="top"><td align="left">LISTEN</td><td>3</td><td align="left">
<ul><li>
Switch to RX mode</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-IE154_START_RX%3ACTS">CTS</a><ul>
<li><a name="reply-IE154_START_RX%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-IE154_GET_INT_STATUS">IE154_GET_INT_STATUS</a></h4>
<ul>
<li>Number: 0x82</li>
<li>Summary: INTERNAL STATUS: Implemented and tested
Obtains the status of the all operations </li>
<li>Purpose:</li>
<ul><li>
Obtains the status of all operations</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_GET_INT_STATUS Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x82</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>IE154_TX_CLR_PEND</b></td>
<td colspan="1">TX_ERROR_PEND_CLR</td>
<td colspan="1">TX_FIFO_ALMOST_EMPTY_PEND_CLR</td>
<td>0</td>
<td>0</td>
<td colspan="1">TX_ACK_RECEIVED_W_FP_PEND_CLR</td>
<td colspan="1">TX_ACK_RECEIVED_NO_FP_PEND_CLR</td>
<td colspan="1">TX_COMPLETE_PEND_CLR</td>
<td colspan="1">TX_SFD_SENT_PEND_CLR</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>IE154_RX_CLR_PEND</b></td>
<td colspan="1">RX_ERROR_PEND_CLR</td>
<td colspan="1">RX_FIFO_ALMOST_FULL_PEND_CLR</td>
<td>0</td>
<td>0</td>
<td colspan="1">RX_ACK_TX_COMPLETE_PEND_CLR</td>
<td colspan="1">RX_COMPLETE_PEND_CLR</td>
<td colspan="1">RX_SRC_ADDR_PEND_CLR</td>
<td colspan="1">RX_SFD_PEND_CLR</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>IE154_CHIP_CLR_PEND</b></td>
<td>0</td>
<td colspan="1">CAL_PEND_CLR</td>
<td colspan="1">FIFO_UNDERFLOW_OVERFLOW_ERROR_PEND_CLR</td>
<td colspan="1">STATE_CHANGE_PEND_CLR</td>
<td colspan="1">CMD_ERROR_PEND_CLR</td>
<td colspan="1">CHIP_READY_PEND_CLR</td>
<td colspan="1">LOW_BATT_PEND_CLR</td>
<td colspan="1">WUT_PEND_CLR</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_GET_INT_STATUS Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>IE154_INT_PEND</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CHIP_INT_PEND</td>
<td colspan="1">RX_MODE_INT_PEND</td>
<td colspan="1">TX_MODE_INT_PEND</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>IE154_INT_STATUS</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CHIP_INT_STATUS</td>
<td colspan="1">RX_MODE_INT_STATUS</td>
<td colspan="1">TX_MODE_INT_STATUS</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>IE154_TX_PEND</b></td>
<td colspan="1">TX_ERROR_PEND</td>
<td colspan="1">TX_FIFO_ALMOST_EMPTY_PEND</td>
<td>0</td>
<td>0</td>
<td colspan="1">TX_ACK_RECEIVED_W_FP_PEND</td>
<td colspan="1">TX_ACK_RECEIVED_NO_FP_PEND</td>
<td colspan="1">TX_COMPLETE_PEND</td>
<td colspan="1">TX_SFD_SENT_PEND</td>
</tr>
<tr><td>0x04</td>
<td rowspan="1"><b>IE154_TX_STATUS</b></td>
<td colspan="1">TX_ERROR</td>
<td colspan="1">TX_FIFO_ALMOST_EMPTY</td>
<td>0</td>
<td>0</td>
<td colspan="1">TX_ACK_RECEIVED_W_FP</td>
<td colspan="1">TX_ACK_RECEIVED_NO_FP</td>
<td colspan="1">TX_COMPLETE</td>
<td colspan="1">TX_SFD_SENT</td>
</tr>
<tr><td>0x05</td>
<td rowspan="1"><b>IE154_RX_PEND</b></td>
<td colspan="1">RX_ERROR_PEND</td>
<td colspan="1">RX_FIFO_ALMOST_FULL_PEND</td>
<td>0</td>
<td>0</td>
<td colspan="1">RX_ACK_TX_COMPLETE_PEND</td>
<td colspan="1">RX_COMPLETE_PEND</td>
<td colspan="1">RX_SRC_ADDR_PEND</td>
<td colspan="1">RX_SFD_PEND</td>
</tr>
<tr><td>0x06</td>
<td rowspan="1"><b>IE154_RX_STATUS</b></td>
<td colspan="1">RX_ERROR</td>
<td colspan="1">RX_FIFO_ALMOST_FULL</td>
<td>0</td>
<td>0</td>
<td colspan="1">RX_ACK_TX_COMPLETE</td>
<td colspan="1">RX_COMPLETE</td>
<td colspan="1">RX_SRC_ADDR</td>
<td colspan="1">RX_SFD</td>
</tr>
<tr><td>0x07</td>
<td rowspan="1"><b>IE154_CHIP_PEND</b></td>
<td>0</td>
<td colspan="1">CAL_PEND</td>
<td colspan="1">FIFO_UNDERFLOW_OVERFLOW_ERROR_PEND</td>
<td colspan="1">STATE_CHANGE_PEND</td>
<td colspan="1">CMD_ERROR_PEND</td>
<td colspan="1">CHIP_READY_PEND</td>
<td colspan="1">LOW_BATT_PEND</td>
<td colspan="1">WUT_PEND</td>
</tr>
<tr><td>0x08</td>
<td rowspan="1"><b>IE154_CHIP_STATUS</b></td>
<td>0</td>
<td colspan="1">CAL</td>
<td colspan="1">FIFO_UNDERFLOW_OVERFLOW_ERROR</td>
<td colspan="1">STATE_CHANGE</td>
<td colspan="1">CMD_ERROR</td>
<td colspan="1">CHIP_READY</td>
<td colspan="1">LOW_BATT</td>
<td colspan="1">WUT</td>
</tr>
<tr><td>0x09</td>
<td rowspan="1"><b>IE154_TX_ERR_STATUS</b></td>
<td colspan="1">TX_FIFO_UNDERFLOW</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">TX_CCA_CANCELLED</td>
<td colspan="1">TX_ABORTED</td>
<td colspan="1">TX_ACK_EXPIRED</td>
<td colspan="1">TX_CCA_FAIL</td>
</tr>
<tr><td>0x0a</td>
<td rowspan="1"><b>IE154_RX_ERR_STATUS</b></td>
<td colspan="1">RX_OVERFLOW</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">RX_ABORTED</td>
<td colspan="1">RX_ACK_TX_FAILED</td>
<td>0</td>
</tr>
<tr><td>0x0b</td>
<td rowspan="1"><b>TX_FIFO_SPACE</b></td>
<td colspan="8">TX_FIFO_SPACE</td>
</tr>
<tr><td>0x0c</td>
<td rowspan="1"><b>RX_FIFO_COUNT</b></td>
<td colspan="8">RX_FIFO_COUNT</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-IE154_GET_INT_STATUS%3AIE154_TX_CLR_PEND">IE154_TX_CLR_PEND</a><ul>
<li><a name="arg-IE154_GET_INT_STATUS%3ATX_ERROR_PEND_CLR">TX_ERROR_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending TX_ERROR interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_INT_STATUS%3ATX_FIFO_ALMOST_EMPTY_PEND_CLR">TX_FIFO_ALMOST_EMPTY_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending TX_FIFO_ALMOST_EMPTY interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_INT_STATUS%3ATX_ACK_RECEIVED_W_FP_PEND_CLR">TX_ACK_RECEIVED_W_FP_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending TX_ACK_RECEIVED_W_FP interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_INT_STATUS%3ATX_ACK_RECEIVED_NO_FP_PEND_CLR">TX_ACK_RECEIVED_NO_FP_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending TX_ACK_RECEIVED_NO_FP interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_INT_STATUS%3ATX_COMPLETE_PEND_CLR">TX_COMPLETE_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending TX_COMPLETE interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_INT_STATUS%3ATX_SFD_SENT_PEND_CLR">TX_SFD_SENT_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending TX_SFD_SENT interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-IE154_GET_INT_STATUS%3AIE154_RX_CLR_PEND">IE154_RX_CLR_PEND</a><ul>
<li><a name="arg-IE154_GET_INT_STATUS%3ARX_ERROR_PEND_CLR">RX_ERROR_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RX_ERROR interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_INT_STATUS%3ARX_FIFO_ALMOST_FULL_PEND_CLR">RX_FIFO_ALMOST_FULL_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RX_FIFO_ALMOST_FULL interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_INT_STATUS%3ARX_ACK_TX_COMPLETE_PEND_CLR">RX_ACK_TX_COMPLETE_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RX_ACK_TX_COMPLETE interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_INT_STATUS%3ARX_COMPLETE_PEND_CLR">RX_COMPLETE_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RX_COMPLETE interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_INT_STATUS%3ARX_SRC_ADDR_PEND_CLR">RX_SRC_ADDR_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RX_SRC_ADDR interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_INT_STATUS%3ARX_SFD_PEND_CLR">RX_SFD_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RX_SFD interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-IE154_GET_INT_STATUS%3AIE154_CHIP_CLR_PEND">IE154_CHIP_CLR_PEND</a><ul>
<li><a name="arg-IE154_GET_INT_STATUS%3ACAL_PEND_CLR">CAL_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending CAL interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_INT_STATUS%3AFIFO_UNDERFLOW_OVERFLOW_ERROR_PEND_CLR">FIFO_UNDERFLOW_OVERFLOW_ERROR_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending FIFO_UNDERFLOW_OVERFLOW_ERROR interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_INT_STATUS%3ASTATE_CHANGE_PEND_CLR">STATE_CHANGE_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending STATE_CHANGE interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_INT_STATUS%3ACMD_ERROR_PEND_CLR">CMD_ERROR_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending CMD_ERROR interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_INT_STATUS%3ACHIP_READY_PEND_CLR">CHIP_READY_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending CHIP_READY interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_INT_STATUS%3ALOW_BATT_PEND_CLR">LOW_BATT_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending LOW_BATT interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_INT_STATUS%3AWUT_PEND_CLR">WUT_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending WUT interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-IE154_GET_INT_STATUS%3ACTS">CTS</a><ul>
<li><a name="reply-IE154_GET_INT_STATUS%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_INT_STATUS%3AIE154_INT_PEND">IE154_INT_PEND</a><ul>
<li><a name="reply-IE154_GET_INT_STATUS%3ACHIP_INT_PEND">CHIP_INT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, an enabled CHIP_PEND bit is set indicating an interrupt is pending. See the <a href="#reply-GET_INT_STATUS%3ACHIP_STATUS">GET_INT_STATUS:CHIP_STATUS</a>
 field for the triggering events within the Chip Interrupt group.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_MODE_INT_PEND">RX_MODE_INT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, an enabled RX_MODE_PEND bit is set indicating an interrupt is pending. See the <a href="#reply-GET_INT_STATUS%3ARX_MODE_STATUS">GET_INT_STATUS:RX_MODE_STATUS</a>
 field for the triggering events within the RX Mode Interrupt group.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_MODE_INT_PEND">TX_MODE_INT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, an enabled TX_MODE_PEND bit is set indicating an interrupt is pending. See the <a href="#reply-GET_INT_STATUS%3ATX_MODE_STATUS">GET_INT_STATUS:TX_MODE_STATUS</a>
 field for the triggering events within the TX Mode Interrupt group.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_INT_STATUS%3AIE154_INT_STATUS">IE154_INT_STATUS</a><ul>
<li><a name="reply-IE154_GET_INT_STATUS%3ACHIP_INT_STATUS">CHIP_INT_STATUS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, the Chip Interrupt group has an interrupt pending. See the <a href="#reply-GET_INT_STATUS%3ACHIP_STATUS">GET_INT_STATUS:CHIP_STATUS</a>
 field for the triggering events within the Chip Interrupt group.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_MODE_INT_STATUS">RX_MODE_INT_STATUS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, the RX Mode Interrupt group has an interrupt pending. See the <a href="#reply-GET_INT_STATUS%3ARX_MODE_STATUS">GET_INT_STATUS:RX_MODE_STATUS</a>
 field for the triggering events within the RX Mode Interrupt group.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_MODE_INT_STATUS">TX_MODE_INT_STATUS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, the TX Mode Interrupt group has an interrupt pending. See the <a href="#reply-GET_INT_STATUS%3ATX_MODE_STATUS">GET_INT_STATUS:TX_MODE_STATUS</a>
 field for the triggering events within the TX Mode Interrupt group.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_INT_STATUS%3AIE154_TX_PEND">IE154_TX_PEND</a><ul>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_ERROR_PEND">TX_ERROR_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the TX_ERROR status bit has been detected and therefore a TX_ERROR interrupt is pending.  See associated TX_ERROR status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_FIFO_ALMOST_EMPTY_PEND">TX_FIFO_ALMOST_EMPTY_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the TX_FIFO_ALMOST_EMPTY status bit has been detected and therefore a TX_FIFO_ALMOST_EMPTY interrupt is pending.  See associated TX_FIFO_ALMOST_EMPTY status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_ACK_RECEIVED_W_FP_PEND">TX_ACK_RECEIVED_W_FP_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the TX_ACK_RECEIVED_W_FP status bit has been detected and therefore a TX_ACK_RECEIVED_W_FP interrupt is pending.  See associated TX_ACK_RECEIVED_W_FP status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_ACK_RECEIVED_NO_FP_PEND">TX_ACK_RECEIVED_NO_FP_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the TX_ACK_RECEIVED_NO_FP status bit has been detected and therefore a TX_ACK_RECEIVED_NO_FP interrupt is pending.  See associated TX_ACK_RECEIVED_NO_FP status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_COMPLETE_PEND">TX_COMPLETE_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the TX_COMPLETE status bit has been detected and therefore a TX_COMPLETE interrupt is pending.  See associated TX_COMPLETE status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_SFD_SENT_PEND">TX_SFD_SENT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the TX_SFD_SENT status bit has been detected and therefore a TX_SFD_SENT interrupt is pending.  See associated TX_SFD_SENT status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_INT_STATUS%3AIE154_TX_STATUS">IE154_TX_STATUS</a><ul>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_ERROR">TX_ERROR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
TX failed because the transmission was aborted</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_FIFO_ALMOST_EMPTY">TX_FIFO_ALMOST_EMPTY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
TX FIFO has dropped below threshold in 802.15.4g-2012 mode</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_ACK_RECEIVED_W_FP">TX_ACK_RECEIVED_W_FP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
TX expected ACK and ACK was received with the frame pending bit set</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_ACK_RECEIVED_NO_FP">TX_ACK_RECEIVED_NO_FP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
TX expected ACK and ACK was received without the frame pending bit set</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_COMPLETE">TX_COMPLETE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
TX completed. CRC bytes have been sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_SFD_SENT">TX_SFD_SENT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
TX SFD just sent (interrupt right after sending SFD)</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_INT_STATUS%3AIE154_RX_PEND">IE154_RX_PEND</a><ul>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_ERROR_PEND">RX_ERROR_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RX_ERROR status bit has been detected and therefore a RX_ERROR interrupt is pending.  See associated RX_ERROR status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_FIFO_ALMOST_FULL_PEND">RX_FIFO_ALMOST_FULL_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RX_FIFO_ALMOST_FULL status bit has been detected and therefore a RX_FIFO_ALMOST_FULL interrupt is pending.  See associated RX_FIFO_ALMOST_FULL status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_ACK_TX_COMPLETE_PEND">RX_ACK_TX_COMPLETE_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RX_ACK_TX_COMPLETE status bit has been detected and therefore a RX_ACK_TX_COMPLETE interrupt is pending.  See associated RX_ACK_TX_COMPLETE status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_COMPLETE_PEND">RX_COMPLETE_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RX_COMPLETE status bit has been detected and therefore a RX_COMPLETE interrupt is pending.  See associated RX_COMPLETE status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_SRC_ADDR_PEND">RX_SRC_ADDR_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RX_SRC_ADDR status bit has been detected and therefore a RX_SRC_ADDR interrupt is pending.  See associated RX_SRC_ADDR status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_SFD_PEND">RX_SFD_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RX_SFD status bit has been detected and therefore a RX_SFD interrupt is pending.  See associated RX_SFD status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_INT_STATUS%3AIE154_RX_STATUS">IE154_RX_STATUS</a><ul>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_ERROR">RX_ERROR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
An Rx error occurred. The specific error(s) can be found in the error status reply</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_FIFO_ALMOST_FULL">RX_FIFO_ALMOST_FULL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
RX FIFO has gone above threshold in 802.15.4g-2012 mode</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_ACK_TX_COMPLETE">RX_ACK_TX_COMPLETE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
ACK sent for RX - used to terminate data poll</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_COMPLETE">RX_COMPLETE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Packet fully received and CRC ok</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_SRC_ADDR">RX_SRC_ADDR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Source address has been received on filtered packet and optionally (per property above) TODO: ADD LINK packet requests ACK </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_SFD">RX_SFD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
SFD received on Rx packet (posted for all packets regardless of filtering)</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_INT_STATUS%3AIE154_CHIP_PEND">IE154_CHIP_PEND</a><ul>
<li><a name="reply-IE154_GET_INT_STATUS%3ACAL_PEND">CAL_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the CAL status bit has been detected and therefore a CAL interrupt is pending.  See associated CAL status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3AFIFO_UNDERFLOW_OVERFLOW_ERROR_PEND">FIFO_UNDERFLOW_OVERFLOW_ERROR_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the FIFO_UNDERFLOW_OVERFLOW_ERROR status bit has been detected and therefore a FIFO_UNDERFLOW_OVERFLOW_ERROR interrupt is pending.  See associated FIFO_UNDERFLOW_OVERFLOW_ERROR status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ASTATE_CHANGE_PEND">STATE_CHANGE_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the STATE_CHANGE status bit has been detected and therefore a STATE_CHANGE interrupt is pending.  See associated STATE_CHANGE status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ACMD_ERROR_PEND">CMD_ERROR_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the CMD_ERROR status bit has been detected and therefore a CMD_ERROR interrupt is pending.  See associated CMD_ERROR status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ACHIP_READY_PEND">CHIP_READY_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the CHIP_READY status bit has been detected and therefore a CHIP_READY interrupt is pending.  See associated CHIP_READY status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ALOW_BATT_PEND">LOW_BATT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the LOW_BATT status bit has been detected and therefore a LOW_BATT interrupt is pending.  See associated LOW_BATT status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3AWUT_PEND">WUT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the WUT status bit has been detected and therefore a WUT interrupt is pending.  See associated WUT status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_INT_STATUS%3AIE154_CHIP_STATUS">IE154_CHIP_STATUS</a><ul>
<li><a name="reply-IE154_GET_INT_STATUS%3ACAL">CAL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Self clearing signal that pulses high to indicate a RC32K calibration event is pending. If this occurs, the RC32K oscillator will be calibrated on the next transition to Sleep/Standby state.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3AFIFO_UNDERFLOW_OVERFLOW_ERROR">FIFO_UNDERFLOW_OVERFLOW_ERROR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate that the number of received or transmitted bytes exceeds the size of the RX or TX FIFO, respectively (i.e., 64 bytes for each FIFO, or 129 bytes when sharing the FIFO).  Upon such an underflow/overflow event, the FIFO(s) will need to be reset.  Cleared by issuing a <a href="#cmd-FIFO_INFO"><code>FIFO_INFO</code></a>
 command to reset the FIFOs.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ASTATE_CHANGE">STATE_CHANGE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate a successful transition from one state to another operating state.  Cleared when a state transition is in progress.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ACMD_ERROR">CMD_ERROR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Self clearing signal that pulses high to indicate an error has occurred in the processing of a command. For example, an incorrect command/property ID is sent, or an attempt was made to write a property that is outside of the given property group.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ACHIP_READY">CHIP_READY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate the chip (upon completion of the POWER_UP sequence) has reached the state where it is ready to accept commands, or when the IR calibration process is completed.  Cleared when the chip is shutdown or when IR calibration has begun.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ALOW_BATT">LOW_BATT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Set to indicate the battery voltage is below the threshold set by <a href="#prop-GLOBAL_LOW_BATT_THRESH">GLOBAL_LOW_BATT_THRESH</a>
.  Cleared to indicate the battery voltage is above the threshold set by <a href="#prop-GLOBAL_LOW_BATT_THRESH">GLOBAL_LOW_BATT_THRESH</a>
.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3AWUT">WUT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Self clearing signal that pulses high to indicate the WUT (Wake-up timer) has expired.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_INT_STATUS%3AIE154_TX_ERR_STATUS">IE154_TX_ERR_STATUS</a><ul>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_FIFO_UNDERFLOW">TX_FIFO_UNDERFLOW</a>
<dl><dt>Description:</dt><dd>
<ul><li>
A TX FIFO underflow occurred during the transmission of the packet</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_CCA_CANCELLED">TX_CCA_CANCELLED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
CCA for the transmit has been cancelled.  The fifo is untounched and the transmit operation is canceled.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_ABORTED">TX_ABORTED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Transmit of a packet has been aborted.  There is possibly a partial packet in the TX FIFO.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_ACK_EXPIRED">TX_ACK_EXPIRED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
TX expected ACK and ACK was not received on time</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_CCA_FAIL">TX_CCA_FAIL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
TX failed due to CCA check</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_INT_STATUS%3AIE154_RX_ERR_STATUS">IE154_RX_ERR_STATUS</a><ul>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_OVERFLOW">RX_OVERFLOW</a>
<dl><dt>Description:</dt><dd>
<ul><li>
RX FIFO overflow </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_ABORTED">RX_ABORTED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
RX packet was aborted.  There is possibly a partial packet in the fifo that should be discarded.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_ACK_TX_FAILED">RX_ACK_TX_FAILED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
ACK of RX failed to be sent due to some Tx error</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_FIFO_SPACE">TX_FIFO_SPACE</a><ul>
<li><a name="reply-IE154_GET_INT_STATUS%3ATX_FIFO_SPACE">TX_FIFO_SPACE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Amount of space currently available in transmit FIFO.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_FIFO_COUNT">RX_FIFO_COUNT</a><ul>
<li><a name="reply-IE154_GET_INT_STATUS%3ARX_FIFO_COUNT">RX_FIFO_COUNT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Number of bytes avaliable in the receive FIFO.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-IE154_GET_TX_STATUS">IE154_GET_TX_STATUS</a></h4>
<ul>
<li>Number: 0x83</li>
<li>Summary: INTERNAL STATUS: Implemented, not fully tested"
Obtains the status of the last Tx operation </li>
<li>Purpose:</li>
<ul><li>
INTERNAL STATUS: Implemented, not fully tested"
Obtains the status of the last Tx operation</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented, not fully tested"
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_GET_TX_STATUS Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x83</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>IE154_TX_CLR_PEND</b></td>
<td colspan="1">TX_ERROR_PEND_CLR</td>
<td colspan="1">TX_FIFO_ALMOST_EMPTY_PEND_CLR</td>
<td>0</td>
<td>0</td>
<td colspan="1">TX_ACK_RECEIVED_W_FP_PEND_CLR</td>
<td colspan="1">TX_ACK_RECEIVED_NO_FP_PEND_CLR</td>
<td colspan="1">TX_COMPLETE_PEND_CLR</td>
<td colspan="1">TX_SFD_SENT_PEND_CLR</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_GET_TX_STATUS Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>IE154_TX_PEND</b></td>
<td colspan="1">TX_ERROR_PEND</td>
<td colspan="1">TX_FIFO_ALMOST_EMPTY_PEND</td>
<td>0</td>
<td>0</td>
<td colspan="1">TX_ACK_RECEIVED_W_FP_PEND</td>
<td colspan="1">TX_ACK_RECEIVED_NO_FP_PEND</td>
<td colspan="1">TX_COMPLETE_PEND</td>
<td colspan="1">TX_SFD_SENT_PEND</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>IE154_TX_STATUS</b></td>
<td colspan="1">TX_ERROR</td>
<td colspan="1">TX_FIFO_ALMOST_EMPTY</td>
<td>0</td>
<td>0</td>
<td colspan="1">TX_ACK_RECEIVED_W_FP</td>
<td colspan="1">TX_ACK_RECEIVED_NO_FP</td>
<td colspan="1">TX_COMPLETE</td>
<td colspan="1">TX_SFD_SENT</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>IE154_TX_ERR_STATUS</b></td>
<td colspan="1">TX_FIFO_UNDERFLOW</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">TX_CCA_CANCELLED</td>
<td colspan="1">TX_ABORTED</td>
<td colspan="1">TX_ACK_EXPIRED</td>
<td colspan="1">TX_CCA_FAIL</td>
</tr>
<tr><td>0x04</td>
<td rowspan="1"><b>TX_FIFO_SPACE</b></td>
<td colspan="8">TX_FIFO_SPACE</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-IE154_GET_TX_STATUS%3AIE154_TX_CLR_PEND">IE154_TX_CLR_PEND</a><ul>
<li><a name="arg-IE154_GET_TX_STATUS%3ATX_ERROR_PEND_CLR">TX_ERROR_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending TX_ERROR interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_TX_STATUS%3ATX_FIFO_ALMOST_EMPTY_PEND_CLR">TX_FIFO_ALMOST_EMPTY_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending TX_FIFO_ALMOST_EMPTY interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_TX_STATUS%3ATX_ACK_RECEIVED_W_FP_PEND_CLR">TX_ACK_RECEIVED_W_FP_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending TX_ACK_RECEIVED_W_FP interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_TX_STATUS%3ATX_ACK_RECEIVED_NO_FP_PEND_CLR">TX_ACK_RECEIVED_NO_FP_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending TX_ACK_RECEIVED_NO_FP interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_TX_STATUS%3ATX_COMPLETE_PEND_CLR">TX_COMPLETE_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending TX_COMPLETE interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_TX_STATUS%3ATX_SFD_SENT_PEND_CLR">TX_SFD_SENT_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending TX_SFD_SENT interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-IE154_GET_TX_STATUS%3ACTS">CTS</a><ul>
<li><a name="reply-IE154_GET_TX_STATUS%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_TX_STATUS%3AIE154_TX_PEND">IE154_TX_PEND</a><ul>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_ERROR_PEND">TX_ERROR_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the TX_ERROR status bit has been detected and therefore a TX_ERROR interrupt is pending.  See associated TX_ERROR status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_FIFO_ALMOST_EMPTY_PEND">TX_FIFO_ALMOST_EMPTY_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the TX_FIFO_ALMOST_EMPTY status bit has been detected and therefore a TX_FIFO_ALMOST_EMPTY interrupt is pending.  See associated TX_FIFO_ALMOST_EMPTY status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_ACK_RECEIVED_W_FP_PEND">TX_ACK_RECEIVED_W_FP_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the TX_ACK_RECEIVED_W_FP status bit has been detected and therefore a TX_ACK_RECEIVED_W_FP interrupt is pending.  See associated TX_ACK_RECEIVED_W_FP status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_ACK_RECEIVED_NO_FP_PEND">TX_ACK_RECEIVED_NO_FP_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the TX_ACK_RECEIVED_NO_FP status bit has been detected and therefore a TX_ACK_RECEIVED_NO_FP interrupt is pending.  See associated TX_ACK_RECEIVED_NO_FP status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_COMPLETE_PEND">TX_COMPLETE_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the TX_COMPLETE status bit has been detected and therefore a TX_COMPLETE interrupt is pending.  See associated TX_COMPLETE status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_SFD_SENT_PEND">TX_SFD_SENT_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the TX_SFD_SENT status bit has been detected and therefore a TX_SFD_SENT interrupt is pending.  See associated TX_SFD_SENT status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_TX_STATUS%3AIE154_TX_STATUS">IE154_TX_STATUS</a><ul>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_ERROR">TX_ERROR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
TX failed because the transmission was aborted</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_FIFO_ALMOST_EMPTY">TX_FIFO_ALMOST_EMPTY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
TX FIFO has dropped below threshold in 802.15.4g-2012 mode</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_ACK_RECEIVED_W_FP">TX_ACK_RECEIVED_W_FP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
TX expected ACK and ACK was received with the frame pending bit set</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_ACK_RECEIVED_NO_FP">TX_ACK_RECEIVED_NO_FP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
TX expected ACK and ACK was received without the frame pending bit set</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_COMPLETE">TX_COMPLETE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
TX completed. CRC bytes have been sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_SFD_SENT">TX_SFD_SENT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
TX SFD just sent (interrupt right after sending SFD)</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_TX_STATUS%3AIE154_TX_ERR_STATUS">IE154_TX_ERR_STATUS</a><ul>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_FIFO_UNDERFLOW">TX_FIFO_UNDERFLOW</a>
<dl><dt>Description:</dt><dd>
<ul><li>
A TX FIFO underflow occurred during the transmission of the packet</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_CCA_CANCELLED">TX_CCA_CANCELLED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
CCA for the transmit has been cancelled.  The fifo is untounched and the transmit operation is canceled.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_ABORTED">TX_ABORTED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Transmit of a packet has been aborted.  There is possibly a partial packet in the TX FIFO.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_ACK_EXPIRED">TX_ACK_EXPIRED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
TX expected ACK and ACK was not received on time</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_CCA_FAIL">TX_CCA_FAIL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
TX failed due to CCA check</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_FIFO_SPACE">TX_FIFO_SPACE</a><ul>
<li><a name="reply-IE154_GET_TX_STATUS%3ATX_FIFO_SPACE">TX_FIFO_SPACE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Amount of space currently available in transmit FIFO.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-IE154_GET_RX_STATUS">IE154_GET_RX_STATUS</a></h4>
<ul>
<li>Number: 0x84</li>
<li>Summary: INTERNAL STATUS: Implemented, not fully testedObtains the status of the last Rx operation </li>
<li>Purpose:</li>
<ul><li>
INTERNAL STATUS: Implemented, not fully testedObtains the status of the last Rx operation</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented, not fully tested</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_GET_RX_STATUS Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x84</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>IE154_RX_CLR_PEND</b></td>
<td colspan="1">RX_ERROR_PEND_CLR</td>
<td colspan="1">RX_FIFO_ALMOST_FULL_PEND_CLR</td>
<td>0</td>
<td>0</td>
<td colspan="1">RX_ACK_TX_COMPLETE_PEND_CLR</td>
<td colspan="1">RX_COMPLETE_PEND_CLR</td>
<td colspan="1">RX_SRC_ADDR_PEND_CLR</td>
<td colspan="1">RX_SFD_PEND_CLR</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_GET_RX_STATUS Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>IE154_RX_PEND</b></td>
<td colspan="1">RX_ERROR_PEND</td>
<td colspan="1">RX_FIFO_ALMOST_FULL_PEND</td>
<td>0</td>
<td>0</td>
<td colspan="1">RX_ACK_TX_COMPLETE_PEND</td>
<td colspan="1">RX_COMPLETE_PEND</td>
<td colspan="1">RX_SRC_ADDR_PEND</td>
<td colspan="1">RX_SFD_PEND</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>IE154_RX_STATUS</b></td>
<td colspan="1">RX_ERROR</td>
<td colspan="1">RX_FIFO_ALMOST_FULL</td>
<td>0</td>
<td>0</td>
<td colspan="1">RX_ACK_TX_COMPLETE</td>
<td colspan="1">RX_COMPLETE</td>
<td colspan="1">RX_SRC_ADDR</td>
<td colspan="1">RX_SFD</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>IE154_RX_ERR_STATUS</b></td>
<td colspan="1">RX_OVERFLOW</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">RX_ABORTED</td>
<td colspan="1">RX_ACK_TX_FAILED</td>
<td>0</td>
</tr>
<tr><td>0x04</td>
<td rowspan="1"><b>RX_FIFO_COUNT</b></td>
<td colspan="8">RX_FIFO_COUNT</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-IE154_GET_RX_STATUS%3AIE154_RX_CLR_PEND">IE154_RX_CLR_PEND</a><ul>
<li><a name="arg-IE154_GET_RX_STATUS%3ARX_ERROR_PEND_CLR">RX_ERROR_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RX_ERROR interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_RX_STATUS%3ARX_FIFO_ALMOST_FULL_PEND_CLR">RX_FIFO_ALMOST_FULL_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RX_FIFO_ALMOST_FULL interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_RX_STATUS%3ARX_ACK_TX_COMPLETE_PEND_CLR">RX_ACK_TX_COMPLETE_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RX_ACK_TX_COMPLETE interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_RX_STATUS%3ARX_COMPLETE_PEND_CLR">RX_COMPLETE_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RX_COMPLETE interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_RX_STATUS%3ARX_SRC_ADDR_PEND_CLR">RX_SRC_ADDR_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RX_SRC_ADDR interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="arg-IE154_GET_RX_STATUS%3ARX_SFD_PEND_CLR">RX_SFD_PEND_CLR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If clear, clear any pending RX_SFD interrupt. If set, leave interrupt pending.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-IE154_GET_RX_STATUS%3ACTS">CTS</a><ul>
<li><a name="reply-IE154_GET_RX_STATUS%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_RX_STATUS%3AIE154_RX_PEND">IE154_RX_PEND</a><ul>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_ERROR_PEND">RX_ERROR_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RX_ERROR status bit has been detected and therefore a RX_ERROR interrupt is pending.  See associated RX_ERROR status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_FIFO_ALMOST_FULL_PEND">RX_FIFO_ALMOST_FULL_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RX_FIFO_ALMOST_FULL status bit has been detected and therefore a RX_FIFO_ALMOST_FULL interrupt is pending.  See associated RX_FIFO_ALMOST_FULL status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_ACK_TX_COMPLETE_PEND">RX_ACK_TX_COMPLETE_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RX_ACK_TX_COMPLETE status bit has been detected and therefore a RX_ACK_TX_COMPLETE interrupt is pending.  See associated RX_ACK_TX_COMPLETE status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_COMPLETE_PEND">RX_COMPLETE_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RX_COMPLETE status bit has been detected and therefore a RX_COMPLETE interrupt is pending.  See associated RX_COMPLETE status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_SRC_ADDR_PEND">RX_SRC_ADDR_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RX_SRC_ADDR status bit has been detected and therefore a RX_SRC_ADDR interrupt is pending.  See associated RX_SRC_ADDR status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_SFD_PEND">RX_SFD_PEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, a rising edge of the RX_SFD status bit has been detected and therefore a RX_SFD interrupt is pending.  See associated RX_SFD status bit for more details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_RX_STATUS%3AIE154_RX_STATUS">IE154_RX_STATUS</a><ul>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_ERROR">RX_ERROR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
An Rx error occurred. The specific error(s) can be found in the error status reply</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_FIFO_ALMOST_FULL">RX_FIFO_ALMOST_FULL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
RX FIFO has gone above threshold in 802.15.4g-2012 mode</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_ACK_TX_COMPLETE">RX_ACK_TX_COMPLETE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
ACK sent for RX - used to terminate data poll</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_COMPLETE">RX_COMPLETE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Packet fully received and CRC ok</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_SRC_ADDR">RX_SRC_ADDR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Source address has been received on filtered packet and optionally (per property above) TODO: ADD LINK packet requests ACK </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_SFD">RX_SFD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
SFD received on Rx packet (posted for all packets regardless of filtering)</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_RX_STATUS%3AIE154_RX_ERR_STATUS">IE154_RX_ERR_STATUS</a><ul>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_OVERFLOW">RX_OVERFLOW</a>
<dl><dt>Description:</dt><dd>
<ul><li>
RX FIFO overflow </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_ABORTED">RX_ABORTED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
RX packet was aborted.  There is possibly a partial packet in the fifo that should be discarded.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_ACK_TX_FAILED">RX_ACK_TX_FAILED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
ACK of RX failed to be sent due to some Tx error</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_FIFO_COUNT">RX_FIFO_COUNT</a><ul>
<li><a name="reply-IE154_GET_RX_STATUS%3ARX_FIFO_COUNT">RX_FIFO_COUNT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Number of bytes avaliable in the receive FIFO.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-IE154_OVERRIDE_NEXT_ACK">IE154_OVERRIDE_NEXT_ACK</a></h4>
<ul>
<li>Number: 0x85</li>
<li>Summary: Used to temporarily modify the behavior for the next ack sent</li>
<li>Purpose:</li>
<ul><li>
The settings for <a href="#field-IE154_RX_FLAGS%3AAUTO_ACK_DEFAULT_VALUE">IE154_RX_FLAGS:AUTO_ACK_DEFAULT_VALUE</a>
 and <a href="#field-IE154_RX_FLAGS%3AFRAME_PENDING_DEFAULT_VALUE">IE154_RX_FLAGS:FRAME_PENDING_DEFAULT_VALUE</a>
 are latched upon entering receive mode and     control the ability to automatically send an acknowledge as well as the value of the frame pending bit in that ack, respectively. When auto ack is disabled, either by default or using this     command, the value of frame pending does not matter as no ack is transmitted. This command is valid after packet reception begins until just before the ack goes out, or more specifically after     the source address in the incoming packet has been received until the beginning of preamble transmission for the outgoing ack. Ack behavior after this time are once again controlled by their     defaults in <a href="#prop-IE154_RX_FLAGS">IE154_RX_FLAGS</a>
.</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented, frame pending is tested, auto_ack disable is only partially tested so far.
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_OVERRIDE_NEXT_ACK Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x85</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>SEQUENCE_NUMBER</b></td>
<td colspan="8">SEQUENCE_NUMBER</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>NEXT</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">AUTO_ACK</td>
<td colspan="1">FRAME_PENDING</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_OVERRIDE_NEXT_ACK Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>STATUS</b></td>
<td colspan="8">STATUS</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>EXPECTED_SEQUENCE_NUMBER</b></td>
<td colspan="8">EXPECTED_SEQUENCE_NUMBER</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-IE154_OVERRIDE_NEXT_ACK%3ASEQUENCE_NUMBER">SEQUENCE_NUMBER</a><ul>
<li><a name="arg-IE154_OVERRIDE_NEXT_ACK%3ASEQUENCE_NUMBER">SEQUENCE_NUMBER</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The sequence number of the ack to control, which also matches the received packet being acknowledged.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-IE154_OVERRIDE_NEXT_ACK%3ANEXT">NEXT</a><ul>
<li><a name="arg-IE154_OVERRIDE_NEXT_ACK%3AAUTO_ACK">AUTO_ACK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Override <a href="#field-IE154_RX_FLAGS%3AAUTO_ACK_DEFAULT_VALUE">IE154_RX_FLAGS:AUTO_ACK_DEFAULT_VALUE</a>
.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ABORT</td><td>1</td><td align="left">
<ul><li>
Abort the automatic acknowledge, for this packet only.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-IE154_OVERRIDE_NEXT_ACK%3AFRAME_PENDING">FRAME_PENDING</a>
<dl><dt>Description:</dt><dd>
<ul><li>
New value of the frame pending bit to use in the Frame Control Field of the automatic acknowledge.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-IE154_OVERRIDE_NEXT_ACK%3ACTS">CTS</a><ul>
<li><a name="reply-IE154_OVERRIDE_NEXT_ACK%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_OVERRIDE_NEXT_ACK%3ASTATUS">STATUS</a><ul>
<li><a name="reply-IE154_OVERRIDE_NEXT_ACK%3ASTATUS">STATUS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
return status</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">STATUS_SUCCESS</td><td>0</td><td align="left">
<ul><li>
The operation completed successfully.</li></ul>
</td></tr>
<tr valign="top"><td align="left">STATUS_ACK_TIMING_INVALID</td><td>1</td><td align="left">
<ul><li>
Command issued at innappropriate time, either after the auto ACK has been sent or before starting to receive a valid packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">STATUS_SEQUENCE_NUMBER_INVALID</td><td>2</td><td align="left">
<ul><li>
Command issued at an appropriate time, but with the wrong sequence number.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_OVERRIDE_NEXT_ACK%3AEXPECTED_SEQUENCE_NUMBER">EXPECTED_SEQUENCE_NUMBER</a><ul>
<li><a name="reply-IE154_OVERRIDE_NEXT_ACK%3AEXPECTED_SEQUENCE_NUMBER">EXPECTED_SEQUENCE_NUMBER</a>
<dl><dt>Description:</dt><dd>
<ul><li>
either the current or most recently expected sequence number for this command, will match command argument with a return status of success </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-IE154_GET_MAC_TIMER">IE154_GET_MAC_TIMER</a></h4>
<ul>
<li>Number: 0x86</li>
<li>Summary: INTERNAL STATUS: Not implemented
Obtains the 24 bit MAC timer value from the radio</li>
<li>Purpose:</li>
<ul><li>
INTERNAL STATUS: Not implemented
Obtains the 24 bit MAC timer value from the radio</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Not implemented
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_GET_MAC_TIMER Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x86</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_GET_MAC_TIMER Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="3"><b>MAC_TIMER_VALUE</b></td>
<td colspan="8">MAC_TIMER[23:16]</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">MAC_TIMER[15:8]</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">MAC_TIMER[7:0]</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-IE154_GET_MAC_TIMER%3ACTS">CTS</a><ul>
<li><a name="reply-IE154_GET_MAC_TIMER%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_GET_MAC_TIMER%3AMAC_TIMER_VALUE">MAC_TIMER_VALUE</a><ul>
<li><a name="reply-IE154_GET_MAC_TIMER%3AMAC_TIMER">MAC_TIMER</a>
<dl><dt>Description:</dt><dd>
<ul><li>
24 bit value of the radio MAC timer, one tick per microsecond</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-IE154_START_ENERGY_DETECT">IE154_START_ENERGY_DETECT</a></h4>
<ul>
<li>Number: 0x87</li>
<li>Summary: Starts energy detect mode. Energy level is placed in FRR_LATCHED_RSSI</li>
<li>Purpose:</li>
<ul><li>
Starts a continuous reading of the average energy detected over the previous eight symbol periods</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Not implemented
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_START_ENERGY_DETECT Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x87</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>CONFIG</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="3">LATCH_POINT</td>
</tr>
<tr><td>0x02</td>
<td rowspan="1"><b>CHANNEL</b></td>
<td colspan="8">CHANNEL</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_START_ENERGY_DETECT Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-IE154_START_ENERGY_DETECT%3ACONFIG">CONFIG</a><ul>
<li><a name="arg-IE154_START_ENERGY_DETECT%3ALATCH_POINT">LATCH_POINT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Point at which to latch energy.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENERGY4</td><td>0</td><td align="left">
<ul><li>
Latches energy at 4*Tb after RX is enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENERGY8</td><td>1</td><td align="left">
<ul><li>
Latches energy at 8*Tb after RX is enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENERGY12</td><td>2</td><td align="left">
<ul><li>
Latches energy at 12*Tb after RX is enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENERGY16</td><td>3</td><td align="left">
<ul><li>
Latches energy at 16*Tb after RX is enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENERGY20</td><td>4</td><td align="left">
<ul><li>
Latches energy at 20*Tb after RX is enabled.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="arg-IE154_START_ENERGY_DETECT%3ACHANNEL">CHANNEL</a><ul>
<li><a name="arg-IE154_START_ENERGY_DETECT%3ACHANNEL">CHANNEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Channel to obtain energy</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-IE154_START_ENERGY_DETECT%3ACTS">CTS</a><ul>
<li><a name="reply-IE154_START_ENERGY_DETECT%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-IE154_IS_CHANNEL_CLEAR">IE154_IS_CHANNEL_CLEAR</a></h4>
<ul>
<li>Number: 0x89</li>
<li>Summary: INTERNAL STATUS: Not implemented
Returns the clear or busy status of the channel</li>
<li>Purpose:</li>
<ul><li>
INTERNAL STATUS: Not implemented
Return CLEAR if channel is clear, BUSY if channel is busy</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Not implemented
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_IS_CHANNEL_CLEAR Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x89</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>CHANNEL_STATUS</b></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CHANNEL_STATUS</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_IS_CHANNEL_CLEAR Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-IE154_IS_CHANNEL_CLEAR%3ACHANNEL_STATUS">CHANNEL_STATUS</a><ul>
<li><a name="arg-IE154_IS_CHANNEL_CLEAR%3ACHANNEL_STATUS">CHANNEL_STATUS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Indicates whether the current channel is clear or busy</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">BUSY</td><td>0</td><td align="left">
<ul><li>
Channel is busy</li></ul>
</td></tr>
<tr valign="top"><td align="left">CLEAR</td><td>1</td><td align="left">
<ul><li>
Channel is clear</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-IE154_IS_CHANNEL_CLEAR%3ACTS">CTS</a><ul>
<li><a name="reply-IE154_IS_CHANNEL_CLEAR%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-IE154_QUERY_MODE">IE154_QUERY_MODE</a></h4>
<ul>
<li>Number: 0x8a</li>
<li>Summary: Returns the current mode and phase of operation </li>
<li>Purpose:</li>
<ul><li>
Returns the current mode and phase of operation</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Not implemented. Need to complete, and probably merge, modes and phases
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_QUERY_MODE Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x8a</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_QUERY_MODE Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="2"><b>OPERATING_MODE_PHASE</b></td>
<td colspan="8">OPERATING_MODE_PHASE[15:8]</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">OPERATING_MODE_PHASE[7:0]</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>REM_CCA_ATTEMPTS</b></td>
<td colspan="8">REMAINING_CCA_ATTEMPTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-IE154_QUERY_MODE%3ACTS">CTS</a><ul>
<li><a name="reply-IE154_QUERY_MODE%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_QUERY_MODE%3AOPERATING_MODE_PHASE">OPERATING_MODE_PHASE</a><ul>
<li><a name="reply-IE154_QUERY_MODE%3AOPERATING_MODE_PHASE">OPERATING_MODE_PHASE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Indicates the current radio operating mode</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">IE154_MODE_IDLE</td><td>512</td><td align="left">
<ul><li>
IE154_IDLE_MODE</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_TX_PHASE_EXIT</td><td>768</td><td align="left">
<ul><li>
IE154_TX_MODE</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_RX_PHASE_EXIT</td><td>1024</td><td align="left">
<ul><li>
IE154_RX_MODE</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_TX_PHASE_RECV_IDLE</td><td>1025</td><td align="left">
<ul><li>
Waiting for the preamble of an ACK.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_TX_PHASE_RECV_PHY_HDR</td><td>1026</td><td align="left">
<ul><li>
Receiving the Phy Header of the ACK.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_TX_PHASE_RECV_MAC_HDR_FCF</td><td>1027</td><td align="left">
<ul><li>
Receiving the Frame Control Field of the ACK.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_TX_PHASE_RECV_MAC_HDR_SEQ_NUM</td><td>1028</td><td align="left">
<ul><li>
Receiving the Sequence Number of the ACK.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_TX_PHASE_RECV_MAC_HDR_DEST_ADDR</td><td>1029</td><td align="left">
<ul><li>
Receiving the Destination Address of an ACK.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_TX_PHASE_RECV_MAC_HDR_SRC_ADDR</td><td>1030</td><td align="left">
<ul><li>
Receiving the Source Address of an ACK.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_TX_PHASE_RECV_PKT</td><td>1031</td><td align="left">
<ul><li>
Receiving the packet payload of the ACK.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_TX_PHASE_XMIT_WAIT_FOR_RAMP</td><td>1040</td><td align="left">
<ul><li>
Waiting for PA to ramp to transmit packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_TX_PHASE_XMIT_PKT</td><td>1041</td><td align="left">
<ul><li>
Transmitting packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_RX_PHASE_RECV_IDLE</td><td>769</td><td align="left">
<ul><li>
Waiting for the preamble of an packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_RX_PHASE_RECV_PHY_HDR</td><td>770</td><td align="left">
<ul><li>
Receiving the Phy Header of the packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_RX_PHASE_RECV_MAC_HDR_FCF</td><td>771</td><td align="left">
<ul><li>
Receiving the Frame Control Field of the packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_RX_PHASE_RECV_MAC_HDR_SEQ_NUM</td><td>772</td><td align="left">
<ul><li>
Receiving the Sequence Number of the packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_RX_PHASE_RECV_MAC_HDR_DEST_ADDR</td><td>773</td><td align="left">
<ul><li>
Receiving the Destination Address of an packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_RX_PHASE_RECV_MAC_HDR_SRC_ADDR</td><td>774</td><td align="left">
<ul><li>
Receiving the Source Address of an packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_RX_PHASE_RECV_PKT</td><td>775</td><td align="left">
<ul><li>
Receiving the packet payload of the packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_RX_PHASE_XMIT_WAIT_FOR_RAMP</td><td>784</td><td align="left">
<ul><li>
Waiting for PA to ramp to transmit the ACK.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_RX_PHASE_XMIT_PKT</td><td>785</td><td align="left">
<ul><li>
Transmitting the ACK.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_CCA_PHASE_TEST_CHANNEL_CLEAR</td><td>16385</td><td align="left">
<ul><li>
IE154_CCA_MODE_PHASE_TEST_CHANNEL_CLEAR</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154_MODE_ED_PHASE_ENERGY_DETECT</td><td>1281</td><td align="left">
<ul><li>
IE154_ED_MODE_PHASE_ENERGY_DETECT</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="reply-IE154_QUERY_MODE%3AREM_CCA_ATTEMPTS">REM_CCA_ATTEMPTS</a><ul>
<li><a name="reply-IE154_QUERY_MODE%3AREMAINING_CCA_ATTEMPTS">REMAINING_CCA_ATTEMPTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Defines the number of CCA attempts left</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-IE154_START_IDLE">IE154_START_IDLE</a></h4>
<ul>
<li>Number: 0x8c</li>
<li>Summary: INTERNAL STATUS: Implemented and tested.
                        Transitions radio to IDLE mode</li>
<li>Purpose:</li>
<ul><li>
INTERNAL STATUS: Implemented and tested.
                        Transitions radio to IDLE mode</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented and tested.
                        </li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_START_IDLE Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x8c</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_START_IDLE Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-IE154_START_IDLE%3ACTS">CTS</a><ul>
<li><a name="reply-IE154_START_IDLE%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-IE154_START_SLEEP">IE154_START_SLEEP</a></h4>
<ul>
<li>Number: 0x8d</li>
<li>Summary: INTERNAL STATUS: Implemented and tested.
                        Transitions radio to SLEEP mode</li>
<li>Purpose:</li>
<ul><li>
INTERNAL STATUS: Implemented and tested.
                        Transitions radio to SLEEP mode</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented and tested.
                        </li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_START_SLEEP Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x8d</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">IE154_START_SLEEP Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-IE154_START_SLEEP%3ACTS">CTS</a><ul>
<li><a name="reply-IE154_START_SLEEP%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="cset-DEBUG_COMMANDS">DEBUG_COMMANDS</a></h3>
<h4><a name="cmd-PEEK">PEEK</a></h4>
<ul>
<li>Number: 0xf0</li>
<li>Summary: Read a memory location in the device (if the feature is enabled).</li>
<li>Purpose:</li>
<ul><li>
Read a value from a memory location in the device.
    </li><li>
Multiple memory locations may be read by passing more than one ADDR/DATA pair with the command.     The memory locations do not need to be contiguous.
    </li><li>
This command should be used with caution, and should be used only for Silicon Labs diagnostic purposes.     Management of the chip's operational state is performed by the command handler and accessed through the published API.     Directly reading the contents of one hardware memory location does not in itself alter the effective operational state of the chip;    however, a PEEK command is often associated with a subsequent POKE command, and that POKE command may alter the operational state of the chip in an undesired fashion. </li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">PEEK Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0xf0</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">PEEK Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-PEEK%3ACTS">CTS</a><ul>
<li><a name="reply-PEEK%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-POKE">POKE</a></h4>
<ul>
<li>Number: 0xf1</li>
<li>Summary: Write a memory location in the device (if the feature is enabled).</li>
<li>Purpose:</li>
<ul><li>
Write a value to a memory location in the device.     </li><li>
Multiple memory locations may be written by passing more than one ADDR/DATA pair with the command.  The memory locations do not need to be contiguous.     </li><li>
This command should be used with caution, and should be used only for Silicon Labs diagnostic purposes.     Management of the chip's operational state is performed by the command handler and accessed through the published API;    directly modifying the contents of one hardware memory location may alter the effective operational state and result in errant behavior. </li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">POKE Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0xf1</td>
</tr>
<tr><td>0x01</td>
<td rowspan="2"><b>ADDR0</b></td>
<td colspan="8">ADDR[15:8]</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">ADDR[7:0]</td>
</tr>
<tr><td>0x03</td>
<td rowspan="1"><b>DATA0</b></td>
<td colspan="8">DATA</td>
</tr>
<tr><td>0x04</td>
<td rowspan="2"><b>ADDR1</b></td>
<td colspan="8">ADDR[15:8]</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">ADDR[7:0]</td>
</tr>
<tr><td>0x06</td>
<td rowspan="1"><b>DATA1</b></td>
<td colspan="8">DATA</td>
</tr>
<tr><td>0x07</td>
<td rowspan="2"><b>ADDR2</b></td>
<td colspan="8">ADDR[15:8]</td>
</tr>
<tr><td>0x08</td>
<td colspan="8">ADDR[7:0]</td>
</tr>
<tr><td>0x09</td>
<td rowspan="1"><b>DATA2</b></td>
<td colspan="8">DATA</td>
</tr>
<tr><td>0x0a</td>
<td rowspan="2"><b>ADDR3</b></td>
<td colspan="8">ADDR[15:8]</td>
</tr>
<tr><td>0x0b</td>
<td colspan="8">ADDR[7:0]</td>
</tr>
<tr><td>0x0c</td>
<td rowspan="1"><b>DATA3</b></td>
<td colspan="8">DATA</td>
</tr>
<tr><td>0x0d</td>
<td rowspan="2"><b>ADDR4</b></td>
<td colspan="8">ADDR[15:8]</td>
</tr>
<tr><td>0x0e</td>
<td colspan="8">ADDR[7:0]</td>
</tr>
<tr><td>0x0f</td>
<td rowspan="1"><b>DATA4</b></td>
<td colspan="8">DATA</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">POKE Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-POKE%3AADDR0">ADDR0</a><ul>
<li><a name="arg-POKE%3AADDR">ADDR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Memory controller address to which to write the DATA0 value.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-POKE%3ADATA0">DATA0</a><ul>
<li><a name="arg-POKE%3ADATA">DATA</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Data byte to write to the ADDR0 memory lacation.       This byte has no effect if ADDR0 = 0.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-POKE%3AADDR1">ADDR1</a><ul>
<li><a name="arg-POKE%3AADDR">ADDR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Memory controller address to which to write the DATA1 value.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-POKE%3ADATA1">DATA1</a><ul>
<li><a name="arg-POKE%3ADATA">DATA</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Data byte to write to the ADDR1 memory lacation.       This byte has no effect if ADDR1 = 0.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-POKE%3AADDR2">ADDR2</a><ul>
<li><a name="arg-POKE%3AADDR">ADDR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Memory controller address to which to write the DATA2 value.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-POKE%3ADATA2">DATA2</a><ul>
<li><a name="arg-POKE%3ADATA">DATA</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Data byte to write to the ADDR2 memory lacation.       This byte has no effect if ADDR2 = 0.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-POKE%3AADDR3">ADDR3</a><ul>
<li><a name="arg-POKE%3AADDR">ADDR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Memory controller address to which to write the DATA3 value.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-POKE%3ADATA3">DATA3</a><ul>
<li><a name="arg-POKE%3ADATA">DATA</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Data byte to write to the ADDR3 memory lacation.       This byte has no effect if ADDR3 = 0.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-POKE%3AADDR4">ADDR4</a><ul>
<li><a name="arg-POKE%3AADDR">ADDR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Memory controller address to which to write the DATA4 value.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
<li><a name="arg-POKE%3ADATA4">DATA4</a><ul>
<li><a name="arg-POKE%3ADATA">DATA</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Data byte to write to the ADDR4 memory lacation.       This byte has no effect if ADDR4 = 0.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-POKE%3ACTS">CTS</a><ul>
<li><a name="reply-POKE%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-SRAND">SRAND</a></h4>
<ul>
<li>Number: 0xf2</li>
<li>Summary: Set the seed for the random number generator.</li>
<li>Purpose:</li>
<ul><li>
Normally this command is not required, but if deterministic, repeatable random numbers are desired, send this command to seed the random number generator with a specific value.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">SRAND Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0xf2</td>
</tr>
<tr><td>0x01</td>
<td rowspan="4"><b>SEED</b></td>
<td colspan="8">SEED[31:24]</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">SEED[23:16]</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">SEED[15:8]</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">SEED[7:0]</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">SRAND Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-SRAND%3ASEED">SEED</a><ul>
<li><a name="arg-SRAND%3ASEED">SEED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Seed value.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U32</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-SRAND%3ACTS">CTS</a><ul>
<li><a name="reply-SRAND%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-DIE_INFO">DIE_INFO</a></h4>
<ul>
<li>Number: 0xfe</li>
<li>Summary: Reports basic information about the die.</li>
<li>Purpose:</li>
<ul><li>
Returns Die Identifier, Die Version, ROM ID, etc.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">DIE_INFO Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0xfe</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">DIE_INFO Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x09</td>
<td rowspan="1"><b>ROM_ID</b></td>
<td colspan="8">ROM_ID</td>
</tr>
<tr><td>0x0a</td>
<td rowspan="1"><b>CHIP_REV</b></td>
<td colspan="4">SILICON_REV</td>
<td colspan="4">METAL_REV</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-DIE_INFO%3ACTS">CTS</a><ul>
<li><a name="reply-DIE_INFO%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-DIE_INFO%3AROM_ID">ROM_ID</a><ul>
<li><a name="reply-DIE_INFO%3AROM_ID">ROM_ID</a>
<dl><dt>Description:</dt><dd>
<ul><li>
ROM ID.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-DIE_INFO%3ACHIP_REV">CHIP_REV</a><ul>
<li><a name="reply-DIE_INFO%3ASILICON_REV">SILICON_REV</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Silicon Mask Revision.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="reply-DIE_INFO%3AMETAL_REV">METAL_REV</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Metal Mask Revision.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="cset-EZCONFIG_COMMANDS">EZCONFIG_COMMANDS</a></h3>
<h4><a name="cmd-EZCONFIG_CHECK">EZCONFIG_CHECK</a></h4>
<ul>
<li>Number: 0x19</li>
<li>Summary: Validates the EZConfig array was written correctly.</li>
<li>Purpose:</li>
<ul><li>
This command compares the calculated checksum of the written EZConfig against its expected value, and returns the result of that validation.
    </li><li>
This command should be issued immediately following writing of the EZConfig array, and will return an error condition if issued at any other time.
</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">EZCONFIG_CHECK Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x19</td>
</tr>
<tr><td>0x01</td>
<td rowspan="2"><b>CHECKSUM</b></td>
<td colspan="8">CHECKSUM[15:8]</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">CHECKSUM[7:0]</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">EZCONFIG_CHECK Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>RESULT</b></td>
<td colspan="8">RESULT</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-EZCONFIG_CHECK%3ACHECKSUM">CHECKSUM</a><ul>
<li><a name="arg-EZCONFIG_CHECK%3ACHECKSUM">CHECKSUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Expected checksum of the EZConfig array passed to the chip.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-EZCONFIG_CHECK%3ACTS">CTS</a><ul>
<li><a name="reply-EZCONFIG_CHECK%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
<li><a name="reply-EZCONFIG_CHECK%3ARESULT">RESULT</a><ul>
<li><a name="reply-EZCONFIG_CHECK%3ARESULT">RESULT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
 Returns the result of comparing the expected checksum value against the calculated checksum of the written EZConfig array.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">VALID</td><td>0</td><td align="left">
<ul><li>
EZConfig array is valid. The chip is now in normal operating state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">BAD_CHECKSUM</td><td>1</td><td align="left">
<ul><li>
EZConfig array is invalid.  EZConfig state re-started.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INVALID_STATE</td><td>2</td><td align="left">
<ul><li>
The chip was not in the EZConfig state at the time the EZCONFIG_CHECK command was issued.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="cmd-EZCONFIG_ARRAY_WRITE">EZCONFIG_ARRAY_WRITE</a></h4>
<ul>
<li>Number: 0x66</li>
<li>Summary: Writes data byte(s) to the EZConfig array.</li>
<li>Purpose:</li>
<ul><li>
This command is used to configure the chip using a generated EZConfig configuration array.     </li><li>
This command is only valid immediatly following the <a href="#cmd-POWER_UP"><code>POWER_UP</code></a>
 command and before the <a href="#cmd-EZCONFIG_CHECK"><code>EZCONFIG_CHECK</code></a>
 command.         The EZCONFIG_ARRAY_WRITE command ID should be clocked in on SDI (followed by the data byte(s) to be written) without deasserting NSEL.     </li><li>
No more than 128 bytes can be written at one time.  If the configuration array is longer than this a <a href="#cmd-NOP"><code>NOP</code></a>
 followed by a        poll of CTS should be issued before writing the next block of data.     </li><li>
This command does not cause CTS to go low, and can be sent while CTS is low.         This command has no response to be read and thus there is no need to monitor CTS after sending this command.  </li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">EZCONFIG_ARRAY_WRITE Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x66</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">EZCONFIG_ARRAY_WRITE Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
</ul>
</li>
<li>Reply Fields:
<ul>
</ul>
</li>
</ul>
<hr />
<h3><a name="cset-MFSK_COMMANDS">MFSK_COMMANDS</a></h3>
<h4><a name="cmd-START_MFSK">START_MFSK</a></h4>
<ul>
<li>Number: 0x35</li>
<li>Summary: Start direct frequency offset transmission mode.</li>
<li>Purpose:</li>
<ul><li>
This command is used to switch to direct frequency offset transmission mode.</li><li>
Configures MSB or LSB, invert data or not, median frequency offset.</li></ul>
<li>Argument Stream:
<br />
<table>
<thead><tr><th colspan="10">START_MFSK Argument Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CMD</b></td>
<td colspan="8">0x35</td>
</tr>
<tr><td>0x01</td>
<td rowspan="1"><b>DIR_MODE_CFG</b></td>
<td>0</td>
<td colspan="1">INV_DATA</td>
<td colspan="2">SCALE_FACTOR</td>
<td>0</td>
<td>0</td>
<td colspan="1">MSB_FIRST</td>
<td>0</td>
</tr>
<tr><td>0x02</td>
<td rowspan="2"><b>FREQ_OFFSET</b></td>
<td colspan="8">FREQ_OFFSET[15:8]</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">FREQ_OFFSET[7:0]</td>
</tr>
</tbody></table><br />
</li>
<li>Reply Stream:
<br />
<table>
<thead><tr><th colspan="10">START_MFSK Reply Stream</th></tr>
<tr><td>Index</td><td>Name</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td rowspan="1"><b>CTS</b></td>
<td colspan="8">CTS</td>
</tr>
</tbody></table><br />
</li>
<li>Argument Fields:
<ul>
<li><a name="arg-START_MFSK%3ADIR_MODE_CFG">DIR_MODE_CFG</a><ul>
<li><a name="arg-START_MFSK%3AINV_DATA">INV_DATA</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Invert SDI data.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Not invert SDI data.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
SDI data will be inverted prior to be shift in.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-START_MFSK%3ASCALE_FACTOR">SCALE_FACTOR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Data samples will be scaled prior to be written to the  modem offset registers.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
This sampled data X1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
This sampled data X2.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
This sampled data X4.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
This sampled data X8.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="arg-START_MFSK%3AMSB_FIRST">MSB_FIRST</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Allows to shift in SPI data as MSB first or LSB first.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">LSB_FIRST</td><td>0</td><td align="left">
<ul><li>
LSB first.</li></ul>
</td></tr>
<tr valign="top"><td align="left">MSB_FIRST</td><td>1</td><td align="left">
<ul><li>
MSB first.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
<li><a name="arg-START_MFSK%3AFREQ_OFFSET">FREQ_OFFSET</a><ul>
<li><a name="arg-START_MFSK%3AFREQ_OFFSET">FREQ_OFFSET</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Median frequency offset value, in 2's Complement.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
<li>Reply Fields:
<ul>
<li><a name="reply-START_MFSK%3ACTS">CTS</a><ul>
<li><a name="reply-START_MFSK%3ACTS">CTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clear to Send. Indicates that the previous command has completed execution and the response byte stream (if any) is valid. The next command may be sent.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h2><a name="prop-details">Property Details</a></h2>
<h3><a name="pgrp-GLOBAL">GLOBAL</a></h3>
<h4><a name="prop-GLOBAL_XO_TUNE">GLOBAL_XO_TUNE</a></h4>
<ul>
<li>Group: 0x00</li>
<li>Index: 0x00</li>
<li>Summary: Configure the internal capacitor frequency tuning bank for the crystal oscillator.</li>
<li>Purpose:</li>
<ul><li>
The chip provides internal adjustable capacitor banks for the purpose of tuning the frequency of the crystal oscillator.     These capacitances effectively appear in shunt from the XIN and XOUT pins to GND.    </li><li>
TUNE_VALUE = 0x00 corresponds to the lowest tuning capacitance value and thus the highest frequency of oscillation,    while TUNE_VALUE = 0x7F corresponds to the highest tuning capacitance value and the lowest frequency of oscillation.     Each LSB code corresponds to ~70 fF change in capacitance.    </li><li>
The total frequency adjustment range (for a typical 30 MHz crystal blank) is approximately 100 ppm. </li></ul>
<li>Defaults: 0x40</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">GLOBAL_XO_TUNE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0</td>
<td colspan="7">TUNE_VALUE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0x0</td>
<td colspan="7">0x40</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-GLOBAL%3AGLOBAL_XO_TUNE">GLOBAL_XO_TUNE</a><ul>
<li><a name="field-GLOBAL_XO_TUNE%3ATUNE_VALUE">TUNE_VALUE</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">FASTEST_FREQUENCY</td><td>0</td><td align="left">
<ul><li>
Lowest capacitance (i.e., highest oscillation frequency)</li></ul>
</td></tr>
<tr valign="top"><td align="left">SLOWEST_FREQUENCY</td><td>127</td><td align="left">
<ul><li>
Highest capacitance (i.e., lowest oscillation frequency)</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-GLOBAL_CLK_CFG">GLOBAL_CLK_CFG</a></h4>
<ul>
<li>Group: 0x00</li>
<li>Index: 0x01</li>
<li>Summary: Clock configuration options.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for outputting a variety of clock signals on selected GPIO pins.    It is necessary to configure these clock signals prior to using the Wake-Up Timer (WUT) or GPIO clock output.    </li><li>
The source of the clock signal(s) may be derived from the system clock     (i.e., crystal oscillator or external reference source) or from the 32K R-C / Xtal oscillator.    </li><li>
The clock signal derived from the system clock (i.e., crystal oscillator or external reference source)    may be further divided by a configurable divide ratio, as selected by the DIVIDED_CLK_SEL field.     During SPI_ACTIVE mode (i.e., when the crystal oscillator is disabled) the output signal is derived from the divided Boot Clock signal.    </li><li>
The 32K clock source may be obtained from an internal 32K R-C Oscillator,    or from an internal Crystal Oscillator operating with an external 32K crystal blank.
    </li><li>
In the event the 32K Xtal Osc is used, the crystal blank must be placed across the GPIO0 and GPIO1 pins,     thus rendering these pins unavailable for any other purpose.     Additionally, the GPIO0 and GPIO1 pins must be defined as input pins or tri-state pins     (through use of the GPIO_PIN_CFG command) in order to support the mode of oscillation. </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">GLOBAL_CLK_CFG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td>0</td>
<td colspan="1">DIVIDED_CLK_EN</td>
<td colspan="3">DIVIDED_CLK_SEL</td>
<td>0</td>
<td colspan="2">CLK_32K_SEL</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="3">0x0</td>
<td>0x0</td>
<td colspan="2">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-GLOBAL%3AGLOBAL_CLK_CFG">GLOBAL_CLK_CFG</a><ul>
<li><a name="field-GLOBAL_CLK_CFG%3ADIVIDED_CLK_EN">DIVIDED_CLK_EN</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Divided system clock output is disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Divided system clock output is enabled.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-GLOBAL_CLK_CFG%3ADIVIDED_CLK_SEL">DIVIDED_CLK_SEL</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DIV_1</td><td>0</td><td align="left">
<ul><li>
Clock output is system clock divided by 1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIV_2</td><td>1</td><td align="left">
<ul><li>
Clock output is system clock divided by 2.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIV_3</td><td>2</td><td align="left">
<ul><li>
Clock output is system clock divided by 3.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIV_7_5</td><td>3</td><td align="left">
<ul><li>
Clock output is system clock divided by 7.5.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIV_10</td><td>4</td><td align="left">
<ul><li>
Clock output is system clock divided by 10.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIV_15</td><td>5</td><td align="left">
<ul><li>
Clock output is system clock divided by 15.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIV_30</td><td>6</td><td align="left">
<ul><li>
Clock output is system clock divided by 30.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-GLOBAL_CLK_CFG%3ACLK_32K_SEL">CLK_32K_SEL</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">OFF</td><td>0</td><td align="left">
<ul><li>
32 kHz clock is disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RC</td><td>1</td><td align="left">
<ul><li>
32 kHz clock is driven by internal RC oscillator.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CRYSTAL</td><td>2</td><td align="left">
<ul><li>
32 kHz clock is driven by internal crystal oscillator operating with external 32K crystal blank across GPIO0 and GPIO1 pins.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-GLOBAL_LOW_BATT_THRESH">GLOBAL_LOW_BATT_THRESH</a></h4>
<ul>
<li>Group: 0x00</li>
<li>Index: 0x02</li>
<li>Summary: Configures the threshold voltage for low-battery detection.</li>
<li>Purpose:</li>
<ul><li>
The chip provides low-battery detection (LBD) capability.     The battery voltage is compared against the threshold voltage configured in this property, using a dedicated internal voltage comparator.
    </li><li>
The result of the LBD function may be viewed in real-time on a GPIO pin,    or may be used to generate an interrupt event.
    </li><li>
The LBD functionality must be enabled in the <a href="#prop-GLOBAL_WUT_CONFIG">GLOBAL_WUT_CONFIG</a>
 property.     The battery voltage is measured at time intervals defined by the Wake-Up Timer (WUT),    and thus is only available when the WUT is additionally enabled.     (Of course, the host MCU may initiate a measurement of the battery voltage at any time through the <a href="#cmd-GET_ADC_READING"><code>GET_ADC_READING</code></a>
 command.)
    </li><li>
The low battery threshold is configurable from 1.5V to 3.05V in increments of 50mV, and is given by the following formula:
    <br />[LATEX equation: VDD\_THRESH=\left(\frac{30+THRESHOLD}{20}\right)V]
 </li></ul>
<li>Defaults: 0x18</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">GLOBAL_LOW_BATT_THRESH</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="5">THRESHOLD</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x02</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="5">0x18</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-GLOBAL%3AGLOBAL_LOW_BATT_THRESH">GLOBAL_LOW_BATT_THRESH</a><ul>
<li><a name="field-GLOBAL_LOW_BATT_THRESH%3ATHRESHOLD">THRESHOLD</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-GLOBAL_CONFIG">GLOBAL_CONFIG</a></h4>
<ul>
<li>Group: 0x00</li>
<li>Index: 0x03</li>
<li>Summary: Global configuration settings.</li>
<li>Purpose:</li>
<ul><li>
This property configures settings that affect the general operational mode of the chip.     </li><li>
If a non-generic PROTOCOL is specified, the chip is placed into protocol-aware state. </li></ul>
<li>Defaults: 0x20</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">GLOBAL_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x03</td>
<td>0</td>
<td colspan="1">RESERVED</td>
<td colspan="1">SEQUENCER_MODE</td>
<td colspan="1">FIFO_MODE</td>
<td colspan="3">PROTOCOL</td>
<td colspan="1">POWER_MODE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x03</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x1</td>
<td colspan="1">0x0</td>
<td colspan="3">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-GLOBAL%3AGLOBAL_CONFIG">GLOBAL_CONFIG</a><ul>
<li><a name="field-GLOBAL_CONFIG%3ARESERVED">RESERVED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Description: This is a reserved field that should always be written to 1. Note that the recommended               setting does not match the current default (wake-up) value of this bit.</li></ul>
</dd></dl>
<dl><dt>Comments:</dt><dd>
<ul><li>
This field was LPF_SATURATION_MODE in previous api releases.  In fw_3_0_15 (revB1B) if this bit was set to                      0 and the RSSI threshold interrupt fired, the chip could lock up.  It was recommended to *Always* set this bit to                      1.  In a revB1B patch we came up with another way to correct the low power mode non-zero BER error with a minimal                      current consumption hit and therefore deprecated this bit.  So now it is marked as RESERVED write 1!</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-GLOBAL_CONFIG%3ASEQUENCER_MODE">SEQUENCER_MODE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Processing of API commands (e.g., START_TX) is handled by the command handler in the chip.     Due to processing overhead and "housekeeping" functions (e.g., interrupt service routines),     the time required to process an API command may not be fixed.     As a result, the time delay between issuing a START_TX command and the point in time where the chip actually enters TX mode may be slightly variable, in normal operation.     </li><li>
The default operation of the chip is to process the START_TX command and enter TX mode as quickly as possible.     However, the chip may be configured to enter TX mode only after expiration of a fixed (longer) time period,    measured from issuance of the START_TX command.     In this fashion, the time delay between the command and the TX packet is fixed and consistent, but slightly longer than normal.
    </li><li>
The time period is a function of the initial state of the chip prior to entering TX mode.     The timer counts 'X' cycles of a clock operating at Fxtal/30 MHz (i.e., 1 sec clock ticks for the nominal crystal Fxtal=30 MHz).
    </li><li>
SLEEP / SPI_ACTIVE to TX = 0x1F4 = 500 cycles
    </li><li>
TX_TUNE to TX = 0x4B = 75 cycles
    </li><li>
READY to TX = 0x96 = 150 cycles
    </li><li>
RX to TX = 0x96 = 150 cycles </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">GUARANTEED</td><td>0</td><td align="left">
<ul><li>
Enter TX mode upon expiration of a guaranteed time period after nSEL (associated with a START_TX command) goes high.  The time period depends on the current chip state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">FAST</td><td>1</td><td align="left">
<ul><li>
Enter TX mode as quickly as possible after receipt of a START_TX command.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-GLOBAL_CONFIG%3AFIFO_MODE">FIFO_MODE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
 The chip normally provides for two separate 64-byte FIFO memories for the purpose of storing transmit and receive data.
    </li><li>
When this bit is set, these two FIFOs are combined into a single 129-byte shared FIFO.    The user must ensure that all data is transmitted or retrieved from the shared FIFO space prior to switching TX/RX modes, else stored data may be lost.
    </li><li>
Shared FIFO mode will not take effect until after performing a reset of the FIFOs (through the FIFO_INFO command). </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SPLIT_FIFO</td><td>0</td><td align="left">
<ul><li>
TX and RX FIFO are independent, 64-byte size for each other.</li></ul>
</td></tr>
<tr valign="top"><td align="left">HALF_DUPLEX_FIFO</td><td>1</td><td align="left">
<ul><li>
TX/RX FIFO are sharing with 129-byte size buffer.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-GLOBAL_CONFIG%3APROTOCOL">PROTOCOL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Certain protocols (e.g., IEEE 802.15.4g) require dynamic re-configuration of how the packet is processed.
    </li><li>
The default mode of operation is to receive a generic packet format;     the desired processing of the packet is configured prior to packet reception and remains in effect for the duration of the packet.
    </li><li>
If this field is set, the chip becomes "protocol-aware" and dynamically alters its packet processing as a function of received Header byte(s). </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">GENERIC</td><td>0</td><td align="left">
<ul><li>
Packet format is generic, no dynamic reprogramming of packet handler properties.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IE154G</td><td>1</td><td align="left">
<ul><li>
Packet format is IEEE802.15.4g compliant. The following properties are overriden: PKT_CRC_CONFIG, CRC_ENDIAN/BIT_ORDER in PKT_CONFG1 for TX and RX, PKT_FIELD_1_CRC_CONFIG for RX. Other applicable properties in the packet handler group still need to be programmed. Field 1 should have the length of 16 bits to contain the PHR with PKT_LEN_FIELD_SOURCE set to 1 for RX. PSDU field shall use Field 2 with variable length. Field 2 length should be set to the maximum allowed including the anticipated FCS length. It is anticipated that the FCS will be calculated by the host and transmitted over the air.  PHR and FCS will be put in the FIFO for the host to retrieve and check. Therefore, CRC shouldn't be enabled.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-GLOBAL_CONFIG%3APOWER_MODE">POWER_MODE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip may be placed into either a High Performance or Low Power mode of operation.
    </li><li>
This bit primarily affects RX and TUNE modes, and trades off RX performance (i.e., sensitivity and linearity) for current consumption.     The difference in current consumption in TX mode is negligible.
    </li><li>
Please refer to the published datasheet for expected values of current consumption in each mode. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">HIGH_PERF</td><td>0</td><td align="left">
<ul><li>
High performance mode for RX and TX.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LOW_POWER</td><td>1</td><td align="left">
<ul><li>
Low power mode for RX and TX.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-GLOBAL_WUT_CONFIG">GLOBAL_WUT_CONFIG</a></h4>
<ul>
<li>Group: 0x00</li>
<li>Index: 0x04</li>
<li>Summary: General Wakeup Timer feature configuration.</li>
<li>Purpose:</li>
<ul><li>
The chip contains an integrated timer that may be used to wake the chip at periodic intervals.  This property is used to enable and               configure various functions related to the Wake-Up timer (WUT), such as Low-Battery Detection (LBD) and Low Duty Cycle (LDC) operation.
              </li><li>
The WUT counts cycles of the 32K clock signal, and thus a 32K clock source (either internal 32K R-C Oscillator or internal Crystal                   Oscillator with external 32K crystal blank) must also be enabled through the <a href="#prop-GLOBAL_CLK_CFG">GLOBAL_CLK_CFG</a>
 property in order to obtain WUT functionality.
              </li><li>
The frequency of the 32K R-C Oscillator will change with temperature and thus periodic re-calibration is required.  The 32K R-C                   Oscillator is initially calibrated during the <a href="#cmd-POWER_UP"><code>POWER_UP</code></a>
 command after exit from the SDN state.
              </li><li>
There are two different methods by which re-calibration of the 32K R-C Oscillator may be configured.  One method is to enable the                   re-calibration by setting the <a href="#field-GLOBAL_WUT_CONFIG%3ACAL_EN">GLOBAL_WUT_CONFIG:CAL_EN</a>
 bit and selecting the desired calibration period through the <a href="#field-GLOBAL_WUT_CONFIG%3AWUT_CAL_PERIOD">GLOBAL_WUT_CONFIG:WUT_CAL_PERIOD</a>
 parameter.                    The other method is to leave the <a href="#field-GLOBAL_WUT_CONFIG%3ACAL_EN">GLOBAL_WUT_CONFIG:CAL_EN</a>
 bit cleared but to configure a non-zero value in the <a href="#prop-GLOBAL_WUT_CAL">GLOBAL_WUT_CAL</a>
 property, resulting                   in calibration on multiples of the WUT period.  In both methods, the 32K R-C Oscillator must be enabled to provide a clock signal                   to the timer(s).
              </li><li>
Calibration of the 32K R-C Oscillator is performed by comparing its frequency to that of the 30 MHz Xtal Oscillator.  Therefore,                   the 30 MHz Xtal Oscillator is automatically started during calibration, resulting in an increase in average current consumption.                    Selecting a longer value of <a href="#prop-GLOBAL_WUT_CAL">GLOBAL_WUT_CAL</a>
 or <a href="#field-GLOBAL_WUT_CONFIG%3AWUT_CAL_PERIOD">GLOBAL_WUT_CONFIG:WUT_CAL_PERIOD</a>
 is recommended to lower the average current consumption. </li><li>
LDC mode is provided to automatically wake-up the receiver to check if a valid signal is available (LDC RX mode).</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">GLOBAL_WUT_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="2">WUT_LDC_EN</td>
<td colspan="3">WUT_CAL_PERIOD</td>
<td colspan="1">WUT_LBD_EN</td>
<td colspan="1">WUT_EN</td>
<td colspan="1">CAL_EN</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="2">0x0</td>
<td colspan="3">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-GLOBAL%3AGLOBAL_WUT_CONFIG">GLOBAL_WUT_CONFIG</a><ul>
<li><a name="field-GLOBAL_WUT_CONFIG%3AWUT_LDC_EN">WUT_LDC_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enables or disables LDC operation, and selects the mode of LDC operation.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE_LDC</td><td>0</td><td align="left">
<ul><li>
Disable LDC operation.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_LDC</td><td>1</td><td align="left">
<ul><li>
LDC RX Mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TX_LDC</td><td>2</td><td align="left">
<ul><li>
LDC TX Mode.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-GLOBAL_WUT_CONFIG%3AWUT_CAL_PERIOD">WUT_CAL_PERIOD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the time interval for periodic re-calibration of the 32K R-C Oscillator.
              </li><li>
Calibration must additionally be enabled by setting the <a href="#field-WUT_CONFIG%3ACAL_EN">WUT_CONFIG:CAL_EN</a>
 bit, else this field has no effect.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">1_SEC</td><td>0</td><td align="left">
<ul><li>
1 sec.</li></ul>
</td></tr>
<tr valign="top"><td align="left">2_SEC</td><td>1</td><td align="left">
<ul><li>
2 sec.</li></ul>
</td></tr>
<tr valign="top"><td align="left">4_SEC</td><td>2</td><td align="left">
<ul><li>
4 sec.</li></ul>
</td></tr>
<tr valign="top"><td align="left">8_SEC</td><td>3</td><td align="left">
<ul><li>
8 sec.</li></ul>
</td></tr>
<tr valign="top"><td align="left">16_SEC</td><td>4</td><td align="left">
<ul><li>
16 sec.</li></ul>
</td></tr>
<tr valign="top"><td align="left">32_SEC</td><td>5</td><td align="left">
<ul><li>
32 sec.</li></ul>
</td></tr>
<tr valign="top"><td align="left">64_SEC</td><td>6</td><td align="left">
<ul><li>
64 sec.</li></ul>
</td></tr>
<tr valign="top"><td align="left">128_SEC</td><td>7</td><td align="left">
<ul><li>
128 sec.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-GLOBAL_WUT_CONFIG%3AWUT_LBD_EN">WUT_LBD_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
"When high, enables the Low Battery Detect (LBD) function.
               </li><li>
A comparison of the battery voltage with the <a href="#prop-GLOBAL_LOW_BATT_THRESH">GLOBAL_LOW_BATT_THRESH</a>
 value                (through use of a dedicated internal voltage comparator) is performed upon expiration of the WUT interval. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE_LBD</td><td>0</td><td align="left">
<ul><li>
Disable the LBD functionality.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE_LBD</td><td>1</td><td align="left">
<ul><li>
Enable the LBD functionality.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-GLOBAL_WUT_CONFIG%3AWUT_EN">WUT_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Description: Enables or disables the WUT.  No other functionality derived from the WUT (e.g., LBD or LDC)               may be obtained without first enabling the WUT.  It remains additionally necessary to enable a 32K clock               source for the WUT.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE_WUT</td><td>0</td><td align="left">
<ul><li>
Disable wake up timer.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE_WUT</td><td>1</td><td align="left">
<ul><li>
Enable wake up timer.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-GLOBAL_WUT_CONFIG%3ACAL_EN">CAL_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
"Selects whether the chip will wake up at periodic intervals and perform calibration of the 32K R-C Oscillator.
               </li><li>
When enabled, the calibration interval is controlled by the <a href="#field-GLOBAL_WUT_CONFIG%3AWUT_CAL_PERIOD">GLOBAL_WUT_CONFIG:WUT_CAL_PERIOD</a>
 parameter.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE_CAL</td><td>0</td><td align="left">
<ul><li>
Disable the 32K R-C Oscillator calibration timer.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE_CAL</td><td>1</td><td align="left">
<ul><li>
Enable the 32K R-C Oscillator calibration timer.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-GLOBAL_WUT_M">GLOBAL_WUT_M</a></h4>
<ul>
<li>Group: 0x00</li>
<li>Index: 0x05 ... 0x06</li>
<li>Summary: Configure the mantissa of the Wake-Up Timer (WUT) value. </li>
<li>Purpose:</li>
<ul><li>
The chip contains an integrated timer that may be used to wake the chip at periodic intervals.     The WUT is enabled by the <a href="#field-GLOBAL_WUT_CONFIG%3AWUT_EN">GLOBAL_WUT_CONFIG:WUT_EN</a>
 bit.	</li><li>
The WUT_M and WUT_R values should be configured prior to enabling the WUT_EN bit.     In the event it is desired to modify the WUT_M/R values, the WUT_EN bit should first    be disabled and then re-enabled after the timer values are modified.
	</li><li>
The clock source for the WUT is taken from either the internal 32 kHz RC Oscillator     or from the internal 32 kHz crystal oscillator (operating in conjunction with a 32 kHz crystal blank placed between the GPIO0 and GPIO1 pins).    Therefore, a 32K clock source must be enabled (through the <a href="#prop-GLOBAL_CLK_CFG">GLOBAL_CLK_CFG</a>
 property)     in order for the timer to have a clock signal to count.
	</li><li>
The period of the WUT is given by the following formula:
    <br />[LATEX equation: WUT\_PERIOD\_sec = WUT\_M \times (\frac{4 \times 2^{WUT\_R}}{32768})sec]

	</li><li>
This property sets the mantissa value WUT_M.     A value of WUT_M = 0 is a legal value but will have the same effect as WUT_M = 1.
	</li><li>
The WUT_M value is only used in defining the period of the WUT,    and (unlike the WUT_R value) is not shared in defining the Low Duty Cycle (LDC) duration.
	</li><li>
The chip may be configured to generate an interrupt event upon expiration of the WUT.
	</li><li>
Additionally, a GPIO pin may be configured to output a real-time signal with the programmed WUT period.     The duty cycle of this signal may be other than 50%, with the output pulsing high for 2<sup>(WUT_R+1)</sup> cycles of the 32K clock. </li></ul>
<li>Defaults: 0x00, 0x01</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">GLOBAL_WUT_M</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="8">WUT_M[15:8]</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">WUT_M[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-GLOBAL%3AGLOBAL_WUT_M">GLOBAL_WUT_M</a><ul>
<li><a name="field-GLOBAL_WUT_M%3AWUT_M">WUT_M</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Configures the mantissa in the formula for the period.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
<dl><dt>Min:</dt><dd>0x1</dd></dl>
<dl><dt>Max:</dt><dd>0xffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-GLOBAL_WUT_R">GLOBAL_WUT_R</a></h4>
<ul>
<li>Group: 0x00</li>
<li>Index: 0x07</li>
<li>Summary: Configure the exponent of the Wake-Up Timer (WUT) value.</li>
<li>Purpose:</li>
<ul><li>
The chip contains an integrated timer that may be used to wake the chip at periodic intervals.      Please refer to the text description for <a href="#prop-GLOBAL_WUT_M">GLOBAL_WUT_M</a>
 for more details regarding setting the period of the WUT.
    </li><li>
This property sets the value of the exponent WUT_R.     A value of WUT_R = 0 is a legal value but has the same effect as WUT_R = 1.    The maximum permissible value is WUT_R = 0x14 = 20d.
    </li><li>
The WUT_R value is shared between defining the period of the WUT and the LDC mode duration,    in contrast with the WUT_M value which is used only in defining the period of the WUT.
    </li><li>
In most applications the WUT is used to wake from a low-current state such as SLEEP mode.     The WUT_SLEEP bit is used to select whether the chip returns to SLEEP mode after expiration of the WUT, or remains in SPI_ACTIVE mode.     If the chip was already in a higher-current operational state (e.g., TUNE or RX mode)    when the WUT expired, it will not drop back to SLEEP or SPI_ACTIVE mode but will remain in the commanded operational state. </li></ul>
<li>Defaults: 0x60</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">GLOBAL_WUT_R</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x07</td>
<td colspan="2">RESERVED_WRITE_ONE</td>
<td colspan="1">WUT_SLEEP</td>
<td colspan="5">WUT_R</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x07</td>
<td colspan="2">0x1</td>
<td colspan="1">0x1</td>
<td colspan="5">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-GLOBAL%3AGLOBAL_WUT_R">GLOBAL_WUT_R</a><ul>
<li><a name="field-GLOBAL_WUT_R%3ARESERVED_WRITE_ONE">RESERVED_WRITE_ONE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Reserved. Write 1.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-GLOBAL_WUT_R%3AWUT_SLEEP">WUT_SLEEP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
selects the operating state after expiration of the WUT.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">READY</td><td>0</td><td align="left">
<ul><li>
Go to SPI_ACTIVE state after WUT.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SLEEP</td><td>1</td><td align="left">
<ul><li>
Go to Sleep state after WUT.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-GLOBAL_WUT_R%3AWUT_R">WUT_R</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Configures the value of the exponent in the formula for the period of the WUT.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x14</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-GLOBAL_WUT_LDC">GLOBAL_WUT_LDC</a></h4>
<ul>
<li>Group: 0x00</li>
<li>Index: 0x08</li>
<li>Summary: Configures the period of time the chip remains active after automatic wake-up in LDC mode. </li>
<li>Purpose:</li>
<ul><li>
The chip contains an integrated timer used to determine the length of time the chip remains active after automatic wake-up in LDC mode.	</li><li>
The LDC active period is given by the following formula:
    <br />[LATEX equation: LDC\_PERIOD\_sec=WUT\_LDC\times ( \frac{4\times 2^{WUT\_R}}{32768sec})]

	</li><li>
This property sets the mantissa value WUT_LDC.    A value of WUT_LDC = 0 is a legal value but will have the same effect as WUT_LDC = 1.     The WUT_R (exponent) value is shared in defining the period of the WUT.	</li><li>
The clock source for the WUT is taken from either the internal 32 kHz RC Oscillator or from the internal 32 kHz crystal oscillator    (operating in conjunction with a 32 kHz crystal blank placed between the GPIO0 and GPIO1 pins).     Therefore, a 32K clock source must be enabled (through the GLOBAL_CLK_CFG property)    in order for the timer to have a clock signal to count.	</li><li>
The LDC period determines the length of time the chip remains in active mode,    while the WUT period determines the length of time the chip remains inactive.     Therefore the total amount of time between successive wake-up cycles is LDC_PERIOD + WUT_PERIOD.	</li><li>
The period of time spent in active mode may be less than the defined LDC_PERIOD.     Example:  if a valid RX packet is detected within the LDC_PERIOD and completely received prior to the expiration of LDC_PERIOD,     the chip will return to the WUT state immediately upon the end of the packet. </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">GLOBAL_WUT_LDC</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x08</td>
<td colspan="8">WUT_LDC</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x08</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-GLOBAL%3AGLOBAL_WUT_LDC">GLOBAL_WUT_LDC</a><ul>
<li><a name="field-GLOBAL_WUT_LDC%3AWUT_LDC">WUT_LDC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Configures the mantissa in the formula for the period of active time in LDC mode.    </li><li>
An LDC mode of operation must be enabled (through the <a href="#field-GLOBAL_WUT_CONFIG%3AWUT_LDC_EN">GLOBAL_WUT_CONFIG:WUT_LDC_EN</a>
 field) for this parameter to take effect. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x1</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-GLOBAL_WUT_CAL">GLOBAL_WUT_CAL</a></h4>
<ul>
<li>Group: 0x00</li>
<li>Index: 0x09</li>
<li>Summary: Controls if calibration of the 32K R-C Oscillator will be performed on intervals of the WUT.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for two different methods of configuring the period between re-calibration of the 32K R-C Oscillator.     One method involves enabling a Calibration Timer and selecting a calibration interval in various multiples of 1 second    (see the <a href="#prop-GLOBAL_WUT_CONFIG">GLOBAL_WUT_CONFIG</a>
 property);    the other method involves performing calibration on configurable integer multiples of the programmed WUT interval.
    </li><li>
The <a href="#prop-GLOBAL_WUT_CAL">GLOBAL_WUT_CAL</a>
 property configures the desired integer multiple of the WUT interval on which to perform calibration (i.e., the second method mentioned above).     A value of WUT_CAL = 0x00 disables this feature.     Any non-zero value will result in calibration of the 32K R-C Oscillator on that integer multiple of the WUT interval.     Example:  WUT_CAL = 0x01 will calibrate on every WUT interval,    WUT_CAL = 0x02 will calibrate on every second WUT interval, etc.
    </li><li>
The <a href="#field-GLOBAL_WUT_CONFIG%3ACAL_EN">GLOBAL_WUT_CONFIG:CAL_EN</a>
 bit must also be cleared for this method of calibration timing to be enabled. </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">GLOBAL_WUT_CAL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x09</td>
<td colspan="8">WUT_CAL</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x09</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-GLOBAL%3AGLOBAL_WUT_CAL">GLOBAL_WUT_CAL</a><ul>
<li><a name="field-GLOBAL_WUT_CAL%3AWUT_CAL">WUT_CAL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the multiple of the WUT period on which to perform calibration of the 32K R-C Oscillator.
    </li><li>
The <a href="#field-GLOBAL_WUT_CONFIG%3ACAL_EN">GLOBAL_WUT_CONFIG:CAL_EN</a>
 bit must also be cleared for this method of calibration timing to be enabled.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-GLOBAL_BUFCLK_CFG">GLOBAL_BUFCLK_CFG</a></h4>
<ul>
<li>Group: 0x00</li>
<li>Index: 0x0a</li>
<li>Summary: Buffered clock configuration options.</li>
<li>Purpose:</li>
<ul><li>
Configures buffered clock configuration options.  It is necessary to configure these values before using the GPIO buffered clock output.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">GLOBAL_BUFCLK_CFG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0a</td>
<td colspan="2">DIV_MODE</td>
<td colspan="4">DIVX</td>
<td colspan="2">DIVIDED_BUFCLK_MODE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0a</td>
<td colspan="2">0x0</td>
<td colspan="4">0x0</td>
<td colspan="2">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-GLOBAL%3AGLOBAL_BUFCLK_CFG">GLOBAL_BUFCLK_CFG</a><ul>
<li><a name="field-GLOBAL_BUFCLK_CFG%3ADIV_MODE">DIV_MODE</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DIV_1</td><td>0</td><td align="left">
<ul><li>
Clock output is system clock divided by 1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIV_1_5</td><td>1</td><td align="left">
<ul><li>
Clock output is system clock divided by 1.5.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIV_2</td><td>2</td><td align="left">
<ul><li>
Clock output is system clock divided by 2.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIV_X</td><td>3</td><td align="left">
<ul><li>
Clock output is system clock divider comes from a formula based on the number in DIVX.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-GLOBAL_BUFCLK_CFG%3ADIVX">DIVX</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Clock output is system clock divided by (2 * (DIVX[3:0] + 2))</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
<li><a name="field-GLOBAL_BUFCLK_CFG%3ADIVIDED_BUFCLK_MODE">DIVIDED_BUFCLK_MODE</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Divided buffered clock is disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SOUTH_AND_GPIO</td><td>1</td><td align="left">
<ul><li>
Divided buffered clock is enabled, and routed to the south and gpio pads.</li></ul>
</td></tr>
<tr valign="top"><td align="left">NORTH_SOUTH_AND_GPIO</td><td>2</td><td align="left">
<ul><li>
Divided buffered clock is enabled, and routed to the north, south, and gpio pads.</li></ul>
</td></tr>
<tr valign="top"><td align="left">NORTH</td><td>3</td><td align="left">
<ul><li>
Divided buffered clock is enabled, and routed to the north pad.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-INT_CTL">INT_CTL</a></h3>
<h4><a name="prop-INT_CTL_ENABLE">INT_CTL_ENABLE</a></h4>
<ul>
<li>Group: 0x01</li>
<li>Index: 0x00</li>
<li>Summary: This property provides for global enabling of the three interrupt groups (Chip, Modem and Packet Handler) in order to generate HW interrupts at the NIRQ pin.</li>
<li>Purpose:</li>
<ul><li>
Enables top-level interrupt sources to generate HW interrupts at the NIRQ pin.</li><li>
The three interrupt groups are Chip, Modem and Packet Handler.  Each of them contains multiple possible interrupt sources that must be individually enabled via the <a href="#prop-INT_CTL_PH_ENABLE">INT_CTL_PH_ENABLE</a>
, <a href="#prop-INT_CTL_MODEM_ENABLE">INT_CTL_MODEM_ENABLE</a>
, <a href="#prop-INT_CTL_CHIP_ENABLE">INT_CTL_CHIP_ENABLE</a>
 properties.</li><li>
Note that this property only provides for global enabling/disabling of the HW interrupt indication on the NIRQ output pin.  An internal interrupt event may still be generated even if the indication on the NIRQ output pin is disabled.  The interrupt event may always be monitored by polling a GPIO pin, or via <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
, <a href="#cmd-GET_CHIP_STATUS"><code>GET_CHIP_STATUS</code></a>
, <a href="#cmd-GET_PH_STATUS"><code>GET_PH_STATUS</code></a>
, or <a href="#cmd-GET_MODEM_STATUS"><code>GET_MODEM_STATUS</code></a>
 commands.</li></ul>
<li>Defaults: 0x04</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">INT_CTL_ENABLE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CHIP_INT_STATUS_EN</td>
<td colspan="1">MODEM_INT_STATUS_EN</td>
<td colspan="1">PH_INT_STATUS_EN</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x1</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-INT_CTL%3AINT_CTL_ENABLE">INT_CTL_ENABLE</a><ul>
<li><a name="field-INT_CTL_ENABLE%3ACHIP_INT_STATUS_EN">CHIP_INT_STATUS_EN</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable pending interrupts in the Chip Status group from asserting nNIRQ.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable pending interrupts in the Chip Status group to assert nNIRQ.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-INT_CTL_ENABLE%3AMODEM_INT_STATUS_EN">MODEM_INT_STATUS_EN</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable pending interrupts in rx mode group from asserting nNIRQ.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable pending interrupts in rx mode group to assert nNIRQ.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-INT_CTL_ENABLE%3APH_INT_STATUS_EN">PH_INT_STATUS_EN</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable pending interrupts in tx mode group from asserting nNIRQ.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable pending interrupts in tx mode group to assert nNIRQ.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-INT_CTL_PH_ENABLE">INT_CTL_PH_ENABLE</a></h4>
<ul>
<li>Group: 0x01</li>
<li>Index: 0x01</li>
<li>Summary: Enable individual interrupt sources within the Packet Handler Interrupt Group to generate a HW interrupt on the NIRQ output pin.</li>
<li>Purpose:</li>
<ul><li>
Enable individual interrupt sources within the Packet Handler Interrupt Group in order to generate a HW interrupt at the NIRQ output pin.</li><li>
In order to fully enable a HW interrupt, it is necessary to enable both the individual interrupt source (within this property) as well as the corresponding interrupt group (e.g., set <a href="#field-INT_CTL_ENABLE%3APH_INT_STATUS_EN">INT_CTL_ENABLE:PH_INT_STATUS_EN</a>
).</li><li>
Note that even if an interrupt source is not enabled to generate a HW NIRQ interrupt, the given interrupt event still may occur inside the chip and may be monitored by polling a GPIO pin, or via the <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 or <a href="#cmd-GET_PH_STATUS"><code>GET_PH_STATUS</code></a>
 commands.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">INT_CTL_PH_ENABLE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="1">FILTER_MATCH_EN</td>
<td colspan="1">FILTER_MISS_EN</td>
<td colspan="1">PACKET_SENT_EN</td>
<td colspan="1">PACKET_RX_EN</td>
<td colspan="1">CRC_ERROR_EN</td>
<td colspan="1">ALT_CRC_ERROR_EN</td>
<td colspan="1">TX_FIFO_ALMOST_EMPTY_EN</td>
<td colspan="1">RX_FIFO_ALMOST_FULL_EN</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-INT_CTL%3AINT_CTL_PH_ENABLE">INT_CTL_PH_ENABLE</a><ul>
<li><a name="field-INT_CTL_PH_ENABLE%3AFILTER_MATCH_EN">FILTER_MATCH_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables FILTER_MATCH interrupt on rising edge of FILTER_MATCH status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_PH_ENABLE%3AFILTER_MISS_EN">FILTER_MISS_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables FILTER_MISS interrupt on rising edge of FILTER_MISS status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_PH_ENABLE%3APACKET_SENT_EN">PACKET_SENT_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables PACKET_SENT interrupt on rising edge of PACKET_SENT status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_PH_ENABLE%3APACKET_RX_EN">PACKET_RX_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables PACKET_RX interrupt on rising edge of PACKET_RX status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_PH_ENABLE%3ACRC_ERROR_EN">CRC_ERROR_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables CRC_ERROR interrupt on rising edge of CRC_ERROR status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_PH_ENABLE%3AALT_CRC_ERROR_EN">ALT_CRC_ERROR_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables ALT_CRC_ERROR interrupt on rising edge of ALT_CRC_ERROR status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_PH_ENABLE%3ATX_FIFO_ALMOST_EMPTY_EN">TX_FIFO_ALMOST_EMPTY_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables TX_FIFO_ALMOST_EMPTY interrupt on rising edge of TX_FIFO_ALMOST_EMPTY status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_PH_ENABLE%3ARX_FIFO_ALMOST_FULL_EN">RX_FIFO_ALMOST_FULL_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables RX_FIFO_ALMOST_FULL interrupt on rising edge of RX_FIFO_ALMOST_FULL status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-INT_CTL_MODEM_ENABLE">INT_CTL_MODEM_ENABLE</a></h4>
<ul>
<li>Group: 0x01</li>
<li>Index: 0x02</li>
<li>Summary: Enable individual interrupt sources within the Modem Interrupt Group to generate a HW interrupt on the NIRQ output pin.</li>
<li>Purpose:</li>
<ul><li>
Enable individual interrupt sources within the Modem Interrupt Group in order to generate a HW interrupt at the NIRQ output pin.</li><li>
In order to fully enable a HW interrupt, it is necessary to enable both the individual interrupt source (within this property) as well as the corresponding interrupt group (e.g., set <a href="#field-INT_CTL_ENABLE%3AMODEM_INT_STATUS_EN">INT_CTL_ENABLE:MODEM_INT_STATUS_EN</a>
 ).</li><li>
Note that even if an interrupt source is not enabled to generate a HW NIRQ interrupt, the given interrupt event still may occur inside the chip and may be monitored by polling a GPIO pin, or via the <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 or <a href="#cmd-GET_MODEM_STATUS"><code>GET_MODEM_STATUS</code></a>
 commands.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">INT_CTL_MODEM_ENABLE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="1">RSSI_LATCH_EN</td>
<td colspan="1">POSTAMBLE_DETECT_EN</td>
<td colspan="1">INVALID_SYNC_EN</td>
<td colspan="1">RSSI_JUMP_EN</td>
<td colspan="1">RSSI_EN</td>
<td colspan="1">INVALID_PREAMBLE_EN</td>
<td colspan="1">PREAMBLE_DETECT_EN</td>
<td colspan="1">SYNC_DETECT_EN</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-INT_CTL%3AINT_CTL_MODEM_ENABLE">INT_CTL_MODEM_ENABLE</a><ul>
<li><a name="field-INT_CTL_MODEM_ENABLE%3ARSSI_LATCH_EN">RSSI_LATCH_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables RSSI_LATCH interrupt on rising edge of RSSI_LATCH status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_MODEM_ENABLE%3APOSTAMBLE_DETECT_EN">POSTAMBLE_DETECT_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables POSTAMBLE_DETECT interrupt on rising edge of POSTAMBLE_DETECT status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_MODEM_ENABLE%3AINVALID_SYNC_EN">INVALID_SYNC_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables INVALID_SYNC interrupt on rising edge of INVALID_SYNC status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_MODEM_ENABLE%3ARSSI_JUMP_EN">RSSI_JUMP_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables RSSI_JUMP interrupt on rising edge of RSSI_JUMP status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_MODEM_ENABLE%3ARSSI_EN">RSSI_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables RSSI interrupt on rising edge of RSSI status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_MODEM_ENABLE%3AINVALID_PREAMBLE_EN">INVALID_PREAMBLE_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables INVALID_PREAMBLE interrupt on rising edge of INVALID_PREAMBLE status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_MODEM_ENABLE%3APREAMBLE_DETECT_EN">PREAMBLE_DETECT_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables PREAMBLE_DETECT interrupt on rising edge of PREAMBLE_DETECT status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_MODEM_ENABLE%3ASYNC_DETECT_EN">SYNC_DETECT_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables SYNC_DETECT interrupt on rising edge of SYNC_DETECT status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources. If dual sync words are configured via <a href="#field-SYNC_CONFIG2%3ADUAL_SYNC_EN">SYNC_CONFIG2:DUAL_SYNC_EN</a>
, then either sync word can trigger this interrupt.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-INT_CTL_CHIP_ENABLE">INT_CTL_CHIP_ENABLE</a></h4>
<ul>
<li>Group: 0x01</li>
<li>Index: 0x03</li>
<li>Summary: Enable individual interrupt sources within the Chip Interrupt Group to generate a HW interrupt on the NIRQ output pin.</li>
<li>Purpose:</li>
<ul><li>
Enable individual interrupt sources within the Chip Interrupt Group in order to generate a HW interrupt at the NIRQ output pin.</li><li>
In order to fully enable a HW interrupt, it is necessary to enable both the individual interrupt source (within this property) as well as the corresponding interrupt group (e.g., set <a href="#field-INT_CTL_ENABLE%3ACHIP_INT_STATUS_EN">INT_CTL_ENABLE:CHIP_INT_STATUS_EN</a>
).</li><li>
Note that even if an interrupt source is not enabled to generate a HW NIRQ interrupt, the given interrupt event still may occur inside the chip and may be monitored by polling a GPIO pin, or via the <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 or <a href="#cmd-GET_CHIP_STATUS"><code>GET_CHIP_STATUS</code></a>
 commands.</li></ul>
<li>Defaults: 0x04</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">INT_CTL_CHIP_ENABLE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x03</td>
<td>0</td>
<td colspan="1">CAL_EN</td>
<td colspan="1">FIFO_UNDERFLOW_OVERFLOW_ERROR_EN</td>
<td colspan="1">STATE_CHANGE_EN</td>
<td colspan="1">CMD_ERROR_EN</td>
<td colspan="1">CHIP_READY_EN</td>
<td colspan="1">LOW_BATT_EN</td>
<td colspan="1">WUT_EN</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x03</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x1</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-INT_CTL%3AINT_CTL_CHIP_ENABLE">INT_CTL_CHIP_ENABLE</a><ul>
<li><a name="field-INT_CTL_CHIP_ENABLE%3ACAL_EN">CAL_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables CAL interrupt on rising edge of CAL status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_CHIP_ENABLE%3AFIFO_UNDERFLOW_OVERFLOW_ERROR_EN">FIFO_UNDERFLOW_OVERFLOW_ERROR_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables FIFO_UNDERFLOW_OVERFLOW_ERROR interrupt on rising edge of FIFO_UNDERFLOW_OVERFLOW_ERROR status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_CHIP_ENABLE%3ASTATE_CHANGE_EN">STATE_CHANGE_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables STATE_CHANGE interrupt on rising edge of STATE_CHANGE status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_CHIP_ENABLE%3ACMD_ERROR_EN">CMD_ERROR_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables CMD_ERROR interrupt on rising edge of CMD_ERROR status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_CHIP_ENABLE%3ACHIP_READY_EN">CHIP_READY_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables CHIP_READY interrupt on rising edge of CHIP_READY status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_CHIP_ENABLE%3ALOW_BATT_EN">LOW_BATT_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables LOW_BATT interrupt on rising edge of LOW_BATT status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-INT_CTL_CHIP_ENABLE%3AWUT_EN">WUT_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables WUT interrupt on rising edge of WUT status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-FRR_CTL">FRR_CTL</a></h3>
<h4><a name="prop-FRR_CTL_A_MODE">FRR_CTL_A_MODE</a></h4>
<ul>
<li>Group: 0x02</li>
<li>Index: 0x00</li>
<li>Summary: Fast Response Register A Configuration.</li>
<li>Purpose:</li>
<ul><li>
The chip provides four Fast Response Registers (FRR) that may be read immediately without the need to monitor and check CTS, thus improving the speed at which the contents may be retrieved.
    </li><li>
The FRR_CTL_X_MODE properties are used to select the specific parameter values (selected from the enumeration list below) that will be returned by the FRR_X_READ commands.  This property selects the parameter held in FRR_A and returned by the FRR_A_READ command.
    </li><li>
The FRR registers may be read in a burst fashion through the FRR_X_READ commands.    After the initial 16 clock cycles, each additional eight clock cycles will clock out the contents of the next fast response register in a circular fashion.     Example:  If the FRR_A_READ command is issued, the registers will be read in the order A-B-C-D,     while if the FRR_B_READ command is issued, the registers will be read in the order B-C-D-A, etc. </li></ul>
<li>Defaults: 0x01</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">FRR_CTL_A_MODE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="8">FRR_A_MODE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="8">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-FRR_CTL%3AFRR_CTL_A_MODE">FRR_CTL_A_MODE</a><ul>
<li><a name="field-FRR_CTL_A_MODE%3AFRR_A_MODE">FRR_A_MODE</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disabled.  Will always read back 0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_STATUS</td><td>1</td><td align="left">
<ul><li>
Global status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_PEND</td><td>2</td><td align="left">
<ul><li>
Global interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_PH_STATUS</td><td>3</td><td align="left">
<ul><li>
Packet Handler status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_IE154_TX_STATUS</td><td>3</td><td align="left">
<ul><li>
IE154 TX interrupt status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_PH_PEND</td><td>4</td><td align="left">
<ul><li>
Packet Handler interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_IE154_TX_PEND</td><td>4</td><td align="left">
<ul><li>
IE154 TX interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_MODEM_STATUS</td><td>5</td><td align="left">
<ul><li>
Modem status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_IE154_RX_STATUS</td><td>5</td><td align="left">
<ul><li>
IE154 RX interrupt status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_MODEM_PEND</td><td>6</td><td align="left">
<ul><li>
Modem interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_IE154_RX_PEND</td><td>6</td><td align="left">
<ul><li>
IE154 RX interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_CHIP_STATUS</td><td>7</td><td align="left">
<ul><li>
Chip status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_CHIP_PEND</td><td>8</td><td align="left">
<ul><li>
Chip status interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CURRENT_STATE</td><td>9</td><td align="left">
<ul><li>
Current state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LATCHED_RSSI</td><td>10</td><td align="left">
<ul><li>
Latched RSSI value as defined in <a href="#field-MODEM_RSSI_CONTROL%3ALATCH">MODEM_RSSI_CONTROL:LATCH</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE0</td><td>11</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE1</td><td>12</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE2</td><td>13</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE3</td><td>14</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE4</td><td>15</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE5</td><td>16</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE6</td><td>17</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-FRR_CTL_B_MODE">FRR_CTL_B_MODE</a></h4>
<ul>
<li>Group: 0x02</li>
<li>Index: 0x01</li>
<li>Summary: Fast Response Register B Configuration.</li>
<li>Purpose:</li>
<ul><li>
This property selects the parameter held in FRR_B and returned by the FRR_B_READ command.
    </li><li>
Please refer to the text description for <a href="#prop-FRR_CTL_A_MODE">FRR_CTL_A_MODE</a>
 for more details regarding the Fast Response Register (FRR) function.
</li></ul>
<li>Defaults: 0x02</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">FRR_CTL_B_MODE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">FRR_B_MODE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">0x2</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-FRR_CTL%3AFRR_CTL_B_MODE">FRR_CTL_B_MODE</a><ul>
<li><a name="field-FRR_CTL_B_MODE%3AFRR_B_MODE">FRR_B_MODE</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disabled.  Will always read back 0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_STATUS</td><td>1</td><td align="left">
<ul><li>
Global status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_PEND</td><td>2</td><td align="left">
<ul><li>
Global interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_PH_STATUS</td><td>3</td><td align="left">
<ul><li>
Packet Handler status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_IE154_TX_STATUS</td><td>3</td><td align="left">
<ul><li>
IE154 TX interrupt status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_PH_PEND</td><td>4</td><td align="left">
<ul><li>
Packet Handler interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_IE154_TX_PEND</td><td>4</td><td align="left">
<ul><li>
IE154 TX interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_MODEM_STATUS</td><td>5</td><td align="left">
<ul><li>
Modem status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_IE154_RX_STATUS</td><td>5</td><td align="left">
<ul><li>
IE154 RX interrupt status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_MODEM_PEND</td><td>6</td><td align="left">
<ul><li>
Modem interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_IE154_RX_PEND</td><td>6</td><td align="left">
<ul><li>
IE154 RX interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_CHIP_STATUS</td><td>7</td><td align="left">
<ul><li>
Chip status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_CHIP_PEND</td><td>8</td><td align="left">
<ul><li>
Chip status interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CURRENT_STATE</td><td>9</td><td align="left">
<ul><li>
Current state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LATCHED_RSSI</td><td>10</td><td align="left">
<ul><li>
Latched RSSI value as defined in <a href="#field-MODEM_RSSI_CONTROL%3ALATCH">MODEM_RSSI_CONTROL:LATCH</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE0</td><td>11</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE1</td><td>12</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE2</td><td>13</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE3</td><td>14</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE4</td><td>15</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE5</td><td>16</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE6</td><td>17</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-FRR_CTL_C_MODE">FRR_CTL_C_MODE</a></h4>
<ul>
<li>Group: 0x02</li>
<li>Index: 0x02</li>
<li>Summary: Fast Response Register C Configuration.</li>
<li>Purpose:</li>
<ul><li>
This property selects the parameter held in FRR_C and returned by the FRR_C_READ command.
    </li><li>
Please refer to the text description for <a href="#prop-FRR_CTL_A_MODE">FRR_CTL_A_MODE</a>
 for more details regarding the Fast Response Register (FRR) function.
</li></ul>
<li>Defaults: 0x09</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">FRR_CTL_C_MODE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="8">FRR_C_MODE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="8">0x9</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-FRR_CTL%3AFRR_CTL_C_MODE">FRR_CTL_C_MODE</a><ul>
<li><a name="field-FRR_CTL_C_MODE%3AFRR_C_MODE">FRR_C_MODE</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disabled.  Will always read back 0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_STATUS</td><td>1</td><td align="left">
<ul><li>
Global status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_PEND</td><td>2</td><td align="left">
<ul><li>
Global interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_PH_STATUS</td><td>3</td><td align="left">
<ul><li>
Packet Handler status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_IE154_TX_STATUS</td><td>3</td><td align="left">
<ul><li>
IE154 TX interrupt status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_PH_PEND</td><td>4</td><td align="left">
<ul><li>
Packet Handler interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_IE154_TX_PEND</td><td>4</td><td align="left">
<ul><li>
IE154 TX interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_MODEM_STATUS</td><td>5</td><td align="left">
<ul><li>
Modem status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_IE154_RX_STATUS</td><td>5</td><td align="left">
<ul><li>
IE154 RX interrupt status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_MODEM_PEND</td><td>6</td><td align="left">
<ul><li>
Modem interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_IE154_RX_PEND</td><td>6</td><td align="left">
<ul><li>
IE154 RX interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_CHIP_STATUS</td><td>7</td><td align="left">
<ul><li>
Chip status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_CHIP_PEND</td><td>8</td><td align="left">
<ul><li>
Chip status interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CURRENT_STATE</td><td>9</td><td align="left">
<ul><li>
Current state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LATCHED_RSSI</td><td>10</td><td align="left">
<ul><li>
Latched RSSI value as defined in <a href="#field-MODEM_RSSI_CONTROL%3ALATCH">MODEM_RSSI_CONTROL:LATCH</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE0</td><td>11</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE1</td><td>12</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE2</td><td>13</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE3</td><td>14</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE4</td><td>15</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE5</td><td>16</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE6</td><td>17</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-FRR_CTL_D_MODE">FRR_CTL_D_MODE</a></h4>
<ul>
<li>Group: 0x02</li>
<li>Index: 0x03</li>
<li>Summary: Fast Response Register D Configuration.</li>
<li>Purpose:</li>
<ul><li>
This property selects the parameter held in FRR_D and returned by the FRR_D_READ command.
    </li><li>
Please refer to the text description for <a href="#prop-FRR_CTL_A_MODE">FRR_CTL_A_MODE</a>
 for more details regarding the Fast Response Register (FRR) function.
</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">FRR_CTL_D_MODE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="8">FRR_D_MODE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-FRR_CTL%3AFRR_CTL_D_MODE">FRR_CTL_D_MODE</a><ul>
<li><a name="field-FRR_CTL_D_MODE%3AFRR_D_MODE">FRR_D_MODE</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disabled.  Will always read back 0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_STATUS</td><td>1</td><td align="left">
<ul><li>
Global status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_PEND</td><td>2</td><td align="left">
<ul><li>
Global interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_PH_STATUS</td><td>3</td><td align="left">
<ul><li>
Packet Handler status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_IE154_TX_STATUS</td><td>3</td><td align="left">
<ul><li>
IE154 TX interrupt status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_PH_PEND</td><td>4</td><td align="left">
<ul><li>
Packet Handler interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_IE154_TX_PEND</td><td>4</td><td align="left">
<ul><li>
IE154 TX interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_MODEM_STATUS</td><td>5</td><td align="left">
<ul><li>
Modem status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_IE154_RX_STATUS</td><td>5</td><td align="left">
<ul><li>
IE154 RX interrupt status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_MODEM_PEND</td><td>6</td><td align="left">
<ul><li>
Modem interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_IE154_RX_PEND</td><td>6</td><td align="left">
<ul><li>
IE154 RX interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_CHIP_STATUS</td><td>7</td><td align="left">
<ul><li>
Chip status.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INT_CHIP_PEND</td><td>8</td><td align="left">
<ul><li>
Chip status interrupt pending.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CURRENT_STATE</td><td>9</td><td align="left">
<ul><li>
Current state.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LATCHED_RSSI</td><td>10</td><td align="left">
<ul><li>
Latched RSSI value as defined in <a href="#field-MODEM_RSSI_CONTROL%3ALATCH">MODEM_RSSI_CONTROL:LATCH</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE0</td><td>11</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE1</td><td>12</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE2</td><td>13</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE3</td><td>14</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE4</td><td>15</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE5</td><td>16</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SPARE6</td><td>17</td><td align="left">
<ul><li>
Currently unused.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-PREAMBLE">PREAMBLE</a></h3>
<h4><a name="prop-PREAMBLE_TX_LENGTH">PREAMBLE_TX_LENGTH</a></h4>
<ul>
<li>Group: 0x10</li>
<li>Index: 0x00</li>
<li>Summary: Configure length of TX Preamble.</li>
<li>Purpose:</li>
<ul><li>
This property is used to configure the length of the Preamble field in TX mode for both Standard and Non-Standard Preambles.    </li><li>
This property is not used by the chip in RX mode except when receiving a Non-Standard Preamble.    In such a case, this property must be configured with the expected Preamble length (to provide an upper timeout limit on the Sync Word search algorithm).    </li><li>
This property is only applicable in TX Packet Handler FIFO mode;    if TX Direct Synchronous or TX Direct Asynchronous mode is selected (see MODEM_MOD_TYPE property),    the entire transmission is obtained from a real-time TXDATA input stream on a GPIO pin and no automatic field construction is possible.    </li><li>
The units of this property are in either nibbles or bytes,    depending upon the value of <a href="#field-PREAMBLE_CONFIG%3ALENGTH_CONFIG">PREAMBLE_CONFIG:LENGTH_CONFIG</a>
.    </li><li>
Setting PREAMBLE_TX_LENGTH = 0x00 is a valid value,    and will result in skipping transmission of the Preamble field;     in such a case, the Sync Word will be the first transmitted field.</li></ul>
<li>Defaults: 0x08</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PREAMBLE_TX_LENGTH</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="8">TX_LENGTH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="8">0x8</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PREAMBLE%3APREAMBLE_TX_LENGTH">PREAMBLE_TX_LENGTH</a><ul>
<li><a name="field-PREAMBLE_TX_LENGTH%3ATX_LENGTH">TX_LENGTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Length of the TX Preamble to send, in units of nibbles or bytes (depending upon the value of <a href="#field-PREAMBLE_CONFIG%3ALENGTH_CONFIG">PREAMBLE_CONFIG:LENGTH_CONFIG</a>
).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PREAMBLE_CONFIG_STD_1">PREAMBLE_CONFIG_STD_1</a></h4>
<ul>
<li>Group: 0x10</li>
<li>Index: 0x01</li>
<li>Summary: Configuration of reception of a packet with a Standard Preamble pattern.</li>
<li>Purpose:</li>
<ul><li>
The fields in this property are applicable only in RX mode, and apply primarily to reception of Standard Preamble patterns (e.g., 1010 or 0101 patterns).</li><li>
However, see note on required configuration of RX_THRESH during reception of Non-Standard Preamble patterns.</li></ul>
<li>Defaults: 0x14</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PREAMBLE_CONFIG_STD_1</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="1">SKIP_SYNC_TIMEOUT</td>
<td colspan="7">RX_THRESH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="1">0x0</td>
<td colspan="7">0x14</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PREAMBLE%3APREAMBLE_CONFIG_STD_1">PREAMBLE_CONFIG_STD_1</a><ul>
<li><a name="field-PREAMBLE_CONFIG_STD_1%3ASKIP_SYNC_TIMEOUT">SKIP_SYNC_TIMEOUT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
During reception of a Standard Preamble pattern, the chip recognizes the start of the Sync Word field as a sequence of bits that does not match a ...1010... pattern.  Detection of the Sync Word is expected to occur soon thereafter (within the programmed length of the Sync Word field).</li><li>
This bit affects the timeout function only during reception of a Standard Preamble; it is not possible to skip the Sync Word timeout function during reception of a Non-Standard Preamble.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
If Sync Word is not found the system will timeout and return to searching for Preamble.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Sync Word search timeout is ignored and the chip remains continuously searching for Sync Word.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PREAMBLE_CONFIG_STD_1%3ARX_THRESH">RX_THRESH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Configures the number of standard preamble bits (e.g., 1010 or 0101) that must be consecutively received to detect a valid preamble.     Bit errors are not allowed during qualification of a Standard Preamble.    </li><li>
This field does NOT determine the detection threshold during reception of a Non-Standard Preamble     (this is set by <a href="#field-PREAMBLE_CONFIG_NSTD%3APATTERN_LENGTH">PREAMBLE_CONFIG_NSTD:PATTERN_LENGTH</a>
).      However, when receiving a Non-Standard Preamble this field should be configured to a moderate value     (e.g., 0x14 to 0x20) else premature timeout of the search for Sync Word may occur.    </li><li>
Detection of a PREAMBLE_VALID signal is typically used by the chip as a trigger event for gear-switching of internal clock timing loops or AFC functionality.    </li><li>
Setting RX_THRESH = 0x00 is a valid value and will result in skipping checking/qualification of the preamble;     the PREAMBLE_VALID signal will be asserted HIGH immediately upon entering RX mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PREAMBLE_CONFIG_NSTD">PREAMBLE_CONFIG_NSTD</a></h4>
<ul>
<li>Group: 0x10</li>
<li>Index: 0x02</li>
<li>Summary: Configuration of transmission/reception of a packet with a Non-Standard Preamble pattern.</li>
<li>Purpose:</li>
<ul><li>
The fields in this property apply only to transmission and reception of packets with Non-Standard Preamble patterns (e.g., other than 1010 or 0101 patterns).</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PREAMBLE_CONFIG_NSTD</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="3">RX_ERRORS</td>
<td colspan="5">PATTERN_LENGTH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="3">0x0</td>
<td colspan="5">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PREAMBLE%3APREAMBLE_CONFIG_NSTD">PREAMBLE_CONFIG_NSTD</a><ul>
<li><a name="field-PREAMBLE_CONFIG_NSTD%3ARX_ERRORS">RX_ERRORS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Number of bit errors that are allowed during reception and qualification of a Non-Standard Preamble pattern.</li><li>
No bit errors are allowed when configured to receive a Standard Preamble pattern; however, it is possible to configure the chip to receive a Non-Standard Preamble but define the pattern to match that of a Standard Preamble, thus providing a means for tolerating bit errors.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7</dd></dl>
</li>
<li><a name="field-PREAMBLE_CONFIG_NSTD%3APATTERN_LENGTH">PATTERN_LENGTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This value (plus 1) specifies the length (in bits) of the repeating pattern that defines the Non-Standard Preamble.     The actual values of the bits in the pattern are specified within the PREAMBLE_PATTERN_XX properties;     the PATTERN_LENGTH field simply determines how many of those specified bit values are transmitted as a repeating pattern.    </li><li>
In TX mode, if the total length of the TX preamble (as defined by the <a href="#prop-PREAMBLE_TX_LENGTH">PREAMBLE_TX_LENGTH</a>
 property)    is longer than PATTERN_LENGTH, the pattern will be transmitted repeatedly as necessary.    </li><li>
In RX mode during reception of a Non-Standard Preamble,     this field determines the number of preamble bits that must be received to detect a valid preamble.     That is, the PATTERN_LENGTH field provides a similar Detection Threshold functionality for a Non-Standard Preamble as     <a href="#field-PREAMBLE_CONFIG_STD_1%3ARX_THRESH">PREAMBLE_CONFIG_STD_1:RX_THRESH</a>
 provides for a Standard Preamble.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PREAMBLE_CONFIG_STD_2">PREAMBLE_CONFIG_STD_2</a></h4>
<ul>
<li>Group: 0x10</li>
<li>Index: 0x03</li>
<li>Summary: Configuration of timeout periods during reception of a packet with Standard Preamble pattern.</li>
<li>Purpose:</li>
<ul><li>
During initial reception and acquisition of a packet, it is often useful to define a timeout period to limit the amount of time the chip remains on-channel awaiting the incoming packet.  This property allows configuration of this preamble search timeout period.</li><li>
If a valid preamble is not found within the specified timeout period, an INVALID_PREAMBLE event is generated and may be used to generate an interrupt and/or exit automatically from RX mode.</li><li>
The fields in this property are applicable only in RX mode, and only apply to reception of Standard Preamble patterns (e.g., 1010 or 0101 patterns).  Detection of INVALID_PREAMBLE is not possible when configured to receive a Non-Standard Preamble pattern.</li><li>
Two different timeout configuration fields are provided to allow definition of timeout periods with significantly different lengths and bit resolution.</li></ul>
<li>Defaults: 0x0f</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PREAMBLE_CONFIG_STD_2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="4">RX_PREAMBLE_TIMEOUT_EXTEND</td>
<td colspan="4">RX_PREAMBLE_TIMEOUT</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="4">0x0</td>
<td colspan="4">0xf</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PREAMBLE%3APREAMBLE_CONFIG_STD_2">PREAMBLE_CONFIG_STD_2</a><ul>
<li><a name="field-PREAMBLE_CONFIG_STD_2%3ARX_PREAMBLE_TIMEOUT_EXTEND">RX_PREAMBLE_TIMEOUT_EXTEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Length of time (in increments of 15 nibbles, i.e., 60 bits, up to a maximum of 225 nibbles) to search for preamble before determining that a preamble does not exist, and an INVALID_PREAMBLE signal/interrupt is generated.</li><li>
If the value of this field is non-zero, the value of the RX_PREAMBLE_TIMEOUT field is ignored.</li><li>
This field allows for very long RX timeout periods and is typically used for applications in which the RX dwells on a channel and waits for the TX packet to arrive.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
<li><a name="field-PREAMBLE_CONFIG_STD_2%3ARX_PREAMBLE_TIMEOUT">RX_PREAMBLE_TIMEOUT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Length of time (in nibbles i.e., 4 bits) to search for preamble before determining that a preamble does not exist, and an INVALID_PREAMBLE signal/interrupt is generated.  This length of RX timeout period is typically used for RX channel scanning or hopping applications.  This field is only applicable if the value of the RX_PREAMBLE_TIMEOUT_EXTEND field is zero.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PREAMBLE_CONFIG">PREAMBLE_CONFIG</a></h4>
<ul>
<li>Group: 0x10</li>
<li>Index: 0x04</li>
<li>Summary: General configuration bits for the Preamble field.</li>
<li>Purpose:</li>
<ul><li>
Miscellaneous preamble configuration bits.</li></ul>
<li>Defaults: 0x21</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PREAMBLE_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="1">RX_PREAM_SRC</td>
<td>0</td>
<td colspan="1">PREAM_FIRST_1_OR_0</td>
<td colspan="1">LENGTH_CONFIG</td>
<td colspan="1">MAN_CONST</td>
<td colspan="1">MAN_ENABLE</td>
<td colspan="2">STANDARD_PREAM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td colspan="1">0x1</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="2">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PREAMBLE%3APREAMBLE_CONFIG">PREAMBLE_CONFIG</a><ul>
<li><a name="field-PREAMBLE_CONFIG%3ARX_PREAM_SRC">RX_PREAM_SRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Determines the source of preamble detection in RX.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">STANDARD_PREAM</td><td>0</td><td align="left">
<ul><li>
The preamble detection source is determined by <a href="#field-PREAMBLE_CONFIG%3ASTANDARD_PREAM">PREAMBLE_CONFIG:STANDARD_PREAM</a>
. If <a href="#field-MODEM_DSA_CTRL1%3ADSA_EN">MODEM_DSA_CTRL1:DSA_EN</a>
 is enabled, the signal arrival block will help qualify preamble detect.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DSA_ONLY</td><td>1</td><td align="left">
<ul><li>
Signal Arrival Detector is used for preamble detection in RX. Ignores setting in <a href="#field-PREAMBLE_CONFIG%3ASTANDARD_PREAM">PREAMBLE_CONFIG:STANDARD_PREAM</a>
.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PREAMBLE_CONFIG%3APREAM_FIRST_1_OR_0">PREAM_FIRST_1_OR_0</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit should be set to match the polarity of the first bit of the transmitted packet.  The WDS Calculator should configure this bit correctly as a function of the selected Preamble type (i.e. Standard or Non-Standard) and first defined bit (e.g., Standard 0101 or Standard 1010).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">FIRST_0</td><td>0</td><td align="left">
<ul><li>
First transmitted bit in the packet is 0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">FIRST_1</td><td>1</td><td align="left">
<ul><li>
First transmitted bit in the packet is 1.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PREAMBLE_CONFIG%3ALENGTH_CONFIG">LENGTH_CONFIG</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit specifies whether the units of the <a href="#prop-PREAMBLE_TX_LENGTH">PREAMBLE_TX_LENGTH</a>
 property are in increments of nibbles or bytes.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NIBBLE</td><td>0</td><td align="left">
<ul><li>
The units of the <a href="#prop-PREAMBLE_TX_LENGTH">PREAMBLE_TX_LENGTH</a>
 property are in nibbles.</li></ul>
</td></tr>
<tr valign="top"><td align="left">BYTE</td><td>1</td><td align="left">
<ul><li>
The units of the <a href="#prop-PREAMBLE_TX_LENGTH">PREAMBLE_TX_LENGTH</a>
 property are in bytes.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PREAMBLE_CONFIG%3AMAN_CONST">MAN_CONST</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Manchester encoding normally operates by replacing each 0 bit with a 10 chip pattern, and each 1 bit with a 01 bit pattern (or vice versa).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NO_CON</td><td>0</td><td align="left">
<ul><li>
When Manchester encoding is enabled across the Preamble field by setting the MAN_ENABLE bit and STANDARD_PREAM=0x2 (i.e., standard preamble pattern is 0101), the post-Manchester transmitted bits will be 10011001.  If STANDARD_PREAM=0x1 (i.e., standard preamble pattern is 1010), the post-Manchester transmitted bits will be 01100110.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONST</td><td>1</td><td align="left">
<ul><li>
When Manchester encoding is enabled across the Preamble field by setting the MAN_ENABLE bit and STANDARD_PREAM=0x2, the pre-Manchester preamble pattern will be replaced with a pattern of constant 1's, and the post-Manchester transmitted bits will be 01010101.  If STANDARD_PREAM=0x1, the pre-Manchester pattern will be replaced with a pattern of constant 0's, and the post-Manchester transmitted bits will be 10101010.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PREAMBLE_CONFIG%3AMAN_ENABLE">MAN_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit enables or disables Manchester encoding/decoding across only the Preamble field.  This bit is applicable in both TX and RX mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NO_MAN</td><td>0</td><td align="left">
<ul><li>
Preamble field is not Manchester encoded/decoded.</li></ul>
</td></tr>
<tr valign="top"><td align="left">EN_MAN</td><td>1</td><td align="left">
<ul><li>
Preamble field is Manchester encoded/decoded.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PREAMBLE_CONFIG%3ASTANDARD_PREAM">STANDARD_PREAM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This field is applicable to both TX and RX modes, but has slightly different meaning in both modes.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">PRE_NS</td><td>0</td><td align="left">
<ul><li>
TX Mode:  Transmit the Non-Standard Preamble (defined in PREAMBLE_PATTERN_XX) as a repetitive pattern until reaching the number of nibbles/bytes defined in <a href="#prop-PREAMBLE_TX_LENGTH">PREAMBLE_TX_LENGTH</a>
.</li><li>
RX Mode:  Expects to receive the Non-Standard Preamble pattern (defined in PREAMBLE_PATTERN_XX) at least once, and generates a PREAMBLE_VALID signal/interrupt upon the first detection of the number of pattern bits specified by PATTERN_LENGTH.</li></ul>
</td></tr>
<tr valign="top"><td align="left">PRE_1010</td><td>1</td><td align="left">
<ul><li>
TX Mode:  Transmit a Standard 1010 preamble until reaching the number of nibbles/bytes defined in <a href="#prop-PREAMBLE_TX_LENGTH">PREAMBLE_TX_LENGTH</a>
.</li><li>
RX Mode:  Expects to receive a Standard 1010 or 0101 preamble.  In RX mode, a value of 0x1 or 0x2 in this field results in identical operation.</li></ul>
</td></tr>
<tr valign="top"><td align="left">PRE_0101</td><td>2</td><td align="left">
<ul><li>
TX Mode:  Transmit a Standard 0101 preamble until reaching the number of nibbles/bytes defined in <a href="#prop-PREAMBLE_TX_LENGTH">PREAMBLE_TX_LENGTH</a>
.</li><li>
RX Mode:  Expects to receive a Standard 1010 or 0101 preamble.  In RX mode, a value of 0x1 or 0x2 in this field results in identical operation.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PREAMBLE_PATTERN">PREAMBLE_PATTERN</a></h4>
<ul>
<li>Group: 0x10</li>
<li>Index: 0x05 ... 0x08</li>
<li>Summary: Configuration of the bit values describing a Non-Standard Preamble pattern.</li>
<li>Purpose:</li>
<ul><li>
The PREAMBLE_PATTERN property defines the pattern to be transmitted in TX mode and the pattern expected to be received in RX mode,    but only when <a href="#field-PREAMBLE_CONFIG%3ASTANDARD_PREAM">PREAMBLE_CONFIG:STANDARD_PREAM</a>
 has been set to 0x0 (i.e., use Non-Standard Preamble).    </li><li>
The PREAMBLE_PATTERN property is used to define the actual bit values describing the Non-Standard Preamble pattern;     <a href="#field-PREAMBLE_CONFIG_NSTD%3APATTERN_LENGTH">PREAMBLE_CONFIG_NSTD:PATTERN_LENGTH</a>
 is used to define how many bits of the PREAMBLE_PATTERN value is used.    </li><li>
In TX mode, if the value of <a href="#prop-PREAMBLE_TX_LENGTH">PREAMBLE_TX_LENGTH</a>
 is larger than <a href="#field-PREAMBLE_CONFIG_NSTD%3APATTERN_LENGTH">PREAMBLE_CONFIG_NSTD:PATTERN_LENGTH</a>
,    the PREAMBLE_PATTERN will be transmitted repeatedly until the full number of bits has been sent.    </li><li>
In RX mode, the full number of bits defined by <a href="#field-PREAMBLE_CONFIG_NSTD%3APATTERN_LENGTH">PREAMBLE_CONFIG_NSTD:PATTERN_LENGTH</a>
    must be received once before the PREAMBLE_VALID signal/interrupt is generated.    </li><li>
If Manchester encoding/decoding is enabled, the values of the PREAMBLE_PATTERN property is expressed in chips     (i.e., after Manchester encoding in TX mode, or before Manchester decoding in RX mode).    </li><li>
The bits of the PREAMBLE_PATTERN are always sent bits 0-31 time-wise (e.g. bit 0 is sent first).</li></ul>
<li>Defaults: 0x00, 0x00, 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PREAMBLE_PATTERN</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="8">PATTERN[31:24]</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">PATTERN[23:16]</td>
</tr>
<tr><td>0x07</td>
<td colspan="8">PATTERN[15:8]</td>
</tr>
<tr><td>0x08</td>
<td colspan="8">PATTERN[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x07</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x08</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PREAMBLE%3APREAMBLE_PATTERN">PREAMBLE_PATTERN</a><ul>
<li><a name="field-PREAMBLE_PATTERN%3APATTERN">PATTERN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Bits of the Non-Standard Preamble pattern to be transmitted or expected to be received.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xffffffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PREAMBLE_POSTAMBLE_CONFIG">PREAMBLE_POSTAMBLE_CONFIG</a></h4>
<ul>
<li>Group: 0x10</li>
<li>Index: 0x09</li>
<li>Summary: Configuration of Postamble functionality and the Postamble pattern bits.</li>
<li>Purpose:</li>
<ul><li>
The chip provides the ability to search for a specific pattern of byte(s) embedded within the Payload data fields,     and to take action or generate an interrupt event upon detection of that pattern.     This functionality is referred to as a Postamble.     </li><li>
This property enables this feature and configures aspects of its functionality,    such as the size of the Postamble and the action to take upon detection.    </li><li>
The chip will only search for a Postamble pattern once the Sync Word is detected    (i.e., the Postamble pattern must be embedded within the Payload data fields).     It is not possible to use the Postamble functionality if there is no Sync Word or it is not detected. </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PREAMBLE_POSTAMBLE_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x09</td>
<td colspan="1">POSTAMBLE_ENABLE</td>
<td colspan="1">PKT_VALID_ON_POSTAMBLE</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="2">POSTAMBLE_SIZE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x09</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="2">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PREAMBLE%3APREAMBLE_POSTAMBLE_CONFIG">PREAMBLE_POSTAMBLE_CONFIG</a><ul>
<li><a name="field-PREAMBLE_POSTAMBLE_CONFIG%3APOSTAMBLE_ENABLE">POSTAMBLE_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enables/disables detection of a Postamble pattern.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">FALSE</td><td>0</td><td align="left">
<ul><li>
Disables detection of a Postamble.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TRUE</td><td>1</td><td align="left">
<ul><li>
Enables detection of a Postamble.  Detection of a Postamble will generate a POSTAMBLE_DETECT interrupt event.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PREAMBLE_POSTAMBLE_CONFIG%3APKT_VALID_ON_POSTAMBLE">PKT_VALID_ON_POSTAMBLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the action that will be taken upon detection of a Postamble.
    </li><li>
This bit has no effect if POSTAMBLE_ENABLE is not set. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">FALSE</td><td>0</td><td align="left">
<ul><li>
Reception of the packet will continue after detection of Postamble.     However, a POSTAMBLE_DETECT interrupt event is still generated and may be used to notify the host MCU.</li></ul>
</td></tr>
<tr valign="top"><td align="left">TRUE</td><td>1</td><td align="left">
<ul><li>
Packet reception will stop upon detection of Postamble and the part will transition to the state specified by <a href="#arg-START_RX%3ARXVALID_STATE">START_RX:RXVALID_STATE</a>
.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PREAMBLE_POSTAMBLE_CONFIG%3APOSTAMBLE_SIZE">POSTAMBLE_SIZE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the size of the Postamble pattern.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Postamble word is 8 bits, with the bit pattern defined in <a href="#prop-POSTAMBLE_PATTERN">POSTAMBLE_PATTERN</a>
[31:24].</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Postamble word is 16 bits, with the bit pattern defined in <a href="#prop-POSTAMBLE_PATTERN">POSTAMBLE_PATTERN</a>
[31:16].</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
Postamble word is 24 bits, with the bit pattern defined in <a href="#prop-POSTAMBLE_PATTERN">POSTAMBLE_PATTERN</a>
[31:8].</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
Postamble word is 32 bits, with the bit pattern defined in <a href="#prop-POSTAMBLE_PATTERN">POSTAMBLE_PATTERN</a>
[31:0].</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PREAMBLE_POSTAMBLE_PATTERN">PREAMBLE_POSTAMBLE_PATTERN</a></h4>
<ul>
<li>Group: 0x10</li>
<li>Index: 0x0a ... 0x0d</li>
<li>Summary: Defines the Postamble pattern.</li>
<li>Purpose:</li>
<ul><li>
Please refer to <a href="#prop-PREAMBLE_POSTAMBLE_CONFIG">PREAMBLE_POSTAMBLE_CONFIG</a>
 for more details regarding configuration of the Postamble functionality.</li></ul>
<li>Defaults: 0x00, 0x00, 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PREAMBLE_POSTAMBLE_PATTERN</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0a</td>
<td colspan="8">POSTAMBLE_PATTERN[31:24]</td>
</tr>
<tr><td>0x0b</td>
<td colspan="8">POSTAMBLE_PATTERN[23:16]</td>
</tr>
<tr><td>0x0c</td>
<td colspan="8">POSTAMBLE_PATTERN[15:8]</td>
</tr>
<tr><td>0x0d</td>
<td colspan="8">POSTAMBLE_PATTERN[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0a</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x0b</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x0c</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x0d</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PREAMBLE%3APREAMBLE_POSTAMBLE_PATTERN">PREAMBLE_POSTAMBLE_PATTERN</a><ul>
<li><a name="field-PREAMBLE_POSTAMBLE_PATTERN%3APOSTAMBLE_PATTERN">POSTAMBLE_PATTERN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Defines the Postamble pattern.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xffffffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PREAMBLE_RESERVED_10_0E">PREAMBLE_RESERVED_10_0E</a></h4>
<ul>
<li>Group: 0x10</li>
<li>Index: 0x0e</li>
<li>Summary: </li>
<li>Purpose:</li>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PREAMBLE_RESERVED_10_0E</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0e</td>
<td colspan="8">RESERVED</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0e</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PREAMBLE%3APREAMBLE_RESERVED_10_0E">PREAMBLE_RESERVED_10_0E</a><ul>
<li><a name="field-PREAMBLE_RESERVED_10_0E%3ARESERVED">RESERVED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reserved</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-SYNC">SYNC</a></h3>
<h4><a name="prop-SYNC_CONFIG">SYNC_CONFIG</a></h4>
<ul>
<li>Group: 0x11</li>
<li>Index: 0x00</li>
<li>Summary: Sync Word configuration bits.</li>
<li>Purpose:</li>
<ul><li>
Configuration of miscellaneous Sync Word bits.  NOTE:  each byte of the Sync Word is transmitted/received in little-endian fashion (i.e., least significant bit first).  Byte(s) of the Sync Word are transmitted/received in descending order (i.e., Byte 3 first, followed by Byte 2, etc.)</li></ul>
<li>Defaults: 0x01</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">SYNC_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="1">SKIP_TX</td>
<td colspan="3">RX_ERRORS</td>
<td colspan="1">4FSK</td>
<td colspan="1">MANCH</td>
<td colspan="2">LENGTH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="1">0x0</td>
<td colspan="3">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="2">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-SYNC%3ASYNC_CONFIG">SYNC_CONFIG</a><ul>
<li><a name="field-SYNC_CONFIG%3ASKIP_TX">SKIP_TX</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SYNC_XMIT</td><td>0</td><td align="left">
<ul><li>
Sync Word is transmitted.  The number of bytes comprising the Sync Word is defined by the LENGTH field within this same property.</li></ul>
</td></tr>
<tr valign="top"><td align="left">NO_SYNC_XMIT</td><td>1</td><td align="left">
<ul><li>
Sync Word is not transmitted.  NOTE:  the SKIP_TX bit only affects TX operation, and does not affect reception of the Sync Word.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-SYNC_CONFIG%3ARX_ERRORS">RX_ERRORS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Defines the number of bit errors that are allowed in the Sync Word field during receive Sync Word detection.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7</dd></dl>
</li>
<li><a name="field-SYNC_CONFIG%3A4FSK">4FSK</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-SYNC_CONFIG%3AMANCH">MANCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If Manchester decoding of the Sync Word in RX mode is enabled, <a href="#field-MODEM_MAP_CONTROL%3AENMANCH">MODEM_MAP_CONTROL:ENMANCH</a>
 should also be set; this results in an extended search timeout period for the Sync Word to allow for the increased number of bits/chips.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Sync word is not manchester encoded.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Sync word is manchester encoded.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-SYNC_CONFIG%3ALENGTH">LENGTH</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">LEN_1_BYTES</td><td>0</td><td align="left">
<ul><li>
Sync Word is 1-byte (8 bits) in length.  Sync Word byte 3 [31:24] is used, with its value defined in the <a href="#prop-SYNC_BITS">SYNC_BITS</a>
 property.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LEN_2_BYTES</td><td>1</td><td align="left">
<ul><li>
Sync Word is 2-bytes (16 bits) in length.  Sync Word bytes 3 and 2 [31:16] are used (in descending order), with their values defined in the <a href="#prop-SYNC_BITS">SYNC_BITS</a>
 property.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LEN_3_BYTES</td><td>2</td><td align="left">
<ul><li>
Sync Word is 3-bytes (24 bits) in length.  Sync Word bytes 3, 2, and 1 [31:8] are used (in descending order), with their values defined in the <a href="#prop-SYNC_BITS">SYNC_BITS</a>
 property.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LEN_4_BYTES</td><td>3</td><td align="left">
<ul><li>
Sync Word is 4-bytes (32 bits) in length.  Sync Word bytes 3, 2, 1, and 0 [31:0] are used (in descending order), with their values defined in the <a href="#prop-SYNC_BITS">SYNC_BITS</a>
 property.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-SYNC_BITS">SYNC_BITS</a></h4>
<ul>
<li>Group: 0x11</li>
<li>Index: 0x01 ... 0x04</li>
<li>Summary: Sync word.</li>
<li>Purpose:</li>
<ul><li>
Define the value of the Sync Word for both TX and RX operation.  NOTE:  Although the Sync Word byte(s) are transmitted/received in descending order (i.e., Byte 3 first, followed by Byte 2, etc.), each byte is transmitted/received in little-endian fashion (i.e., least significant bit first).</li></ul>
<li>Defaults: 0x2d, 0xd4, 0x2d, 0xd4</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">SYNC_BITS</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">BITS[31:24]</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">BITS[23:16]</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">BITS[15:8]</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">BITS[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">0x2d</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">0xd4</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">0x2d</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">0xd4</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-SYNC%3ASYNC_BITS">SYNC_BITS</a><ul>
<li><a name="field-SYNC_BITS%3ABITS">BITS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
bits</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xffffffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-SYNC_CONFIG2">SYNC_CONFIG2</a></h4>
<ul>
<li>Group: 0x11</li>
<li>Index: 0x05</li>
<li>Summary: Sync Word configuration bits.</li>
<li>Purpose:</li>
<ul><li>
Advanced Sync Configuration Bits.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">SYNC_CONFIG2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="1">SYNC_ERROR_ONLY_BEGIN</td>
<td>0</td>
<td colspan="1">SYNC_TIMEOUT_RST</td>
<td colspan="1">DUAL_SYNC_EN</td>
<td>0</td>
<td>0</td>
<td colspan="2">LENGTH_SUB</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="2">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-SYNC%3ASYNC_CONFIG2">SYNC_CONFIG2</a><ul>
<li><a name="field-SYNC_CONFIG2%3ASYNC_ERROR_ONLY_BEGIN">SYNC_ERROR_ONLY_BEGIN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
When this bit is set, the errors that are allowed in the sync match can only occur at the beginning of the Sync. For example, if 5 errors are allowed, these 5 errors must occur in the first 5 bits of the Sync for a Sync to be detected. If there are one or more errors outside of these first 5 bits, Sync is not detected.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SYNC_ERROR_RAND</td><td>0</td><td align="left">
<ul><li>
Allow errors to be randomly distributed throughout the Sync.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SYNC_ERROR_BEGIN</td><td>1</td><td align="left">
<ul><li>
Allow errors to only be at the beginning of the sync word.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-SYNC_CONFIG2%3ASYNC_TIMEOUT_RST">SYNC_TIMEOUT_RST</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Determine which sync timeout resets the RX state machine.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SYNC_TIMEOUT_MODEM</td><td>0</td><td align="left">
<ul><li>
Sync word timeout in modem resets RX state machine.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SYNC_TIMEOUT_PH</td><td>1</td><td align="left">
<ul><li>
Sync word timeout in packet handler resets RX state machine.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-SYNC_CONFIG2%3ADUAL_SYNC_EN">DUAL_SYNC_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Turns on dual sync word detection. When enabled, a match on either sync word can trigger <a href="#field-GET_INT_STATUS%3AMODEM_STATUS%3ASYNC_DETECT">GET_INT_STATUS:MODEM_STATUS:SYNC_DETECT</a>
.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Dual sync word disabled. Only the value in <a href="#prop-SYNC_BITS">SYNC_BITS</a>
 is used</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Dual sync word enabled. Both <a href="#prop-SYNC_BITS">SYNC_BITS</a>
 and <a href="#prop-SYNC_BITS2">SYNC_BITS2</a>
 properties are used. The length is defined in the LENGTH field of SYNC_CONFIG and SYNC_CONFIG2.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-SYNC_CONFIG2%3ALENGTH_SUB">LENGTH_SUB</a>
<dl><dt>Description:</dt><dd>
<ul><li>
 Combined with the length field in <a href="#prop-SYNC_CONFIG">SYNC_CONFIG</a>
 to determine the total number of sync word bits, this field is the subtracted portion of the sync length formula:

    <br />[LATEX equation: total\_sync\_bits\_on\_air = ((SYNC\_CONFIG\_LENGTH[1:0] + 1) * 8) - (SYNC\_CONFIG2\_LENGTH\_SUB[1:0] * 2)]
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SUB_0</td><td>0</td><td align="left">
<ul><li>
Use the sync length as defined in <a href="#prop-SYNC_CONFIG">SYNC_CONFIG</a>
 directly, without adjustment.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SUB_2</td><td>1</td><td align="left">
<ul><li>
Subract 2 bits from the sync length.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SUB_4</td><td>2</td><td align="left">
<ul><li>
Subract 4 bits from the sync length.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SUB_6</td><td>3</td><td align="left">
<ul><li>
Subract 6 bits from the sync length.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-SYNC_BITS2">SYNC_BITS2</a></h4>
<ul>
<li>Group: 0x11</li>
<li>Index: 0x06 ... 0x09</li>
<li>Summary: Sync word 2.</li>
<li>Purpose:</li>
<ul><li>
Define the value of the second Sync Word, which only applies to RX operation.  NOTE:  Although the Sync Word byte(s) are received in descending order (i.e., Byte 3 first, followed by Byte 2, etc.), each byte is received in little-endian fashion (i.e., least significant bit first). Only valid whenever <a href="#field-SYNC_CONFIG2%3ADUAL_SYNC_EN">SYNC_CONFIG2:DUAL_SYNC_EN</a>
 is enabled.</li></ul>
<li>Defaults: 0x2d, 0xd4, 0x2d, 0xd4</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">SYNC_BITS2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="8">BITS[31:24]</td>
</tr>
<tr><td>0x07</td>
<td colspan="8">BITS[23:16]</td>
</tr>
<tr><td>0x08</td>
<td colspan="8">BITS[15:8]</td>
</tr>
<tr><td>0x09</td>
<td colspan="8">BITS[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="8">0x2d</td>
</tr>
<tr><td>0x07</td>
<td colspan="8">0xd4</td>
</tr>
<tr><td>0x08</td>
<td colspan="8">0x2d</td>
</tr>
<tr><td>0x09</td>
<td colspan="8">0xd4</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-SYNC%3ASYNC_BITS2">SYNC_BITS2</a><ul>
<li><a name="field-SYNC_BITS2%3ABITS">BITS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
bits2</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xffffffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-PKT">PKT</a></h3>
<h4><a name="prop-PKT_CRC_CONFIG">PKT_CRC_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x00</li>
<li>Summary: Select a CRC polynomial and seed.</li>
<li>Purpose:</li>
<ul><li>
The chip contains a 32-bit CRC engine for the purpose of generating and comparing a checksum across selected data fields.  This property is used to select the desired CRC polynomial and CRC seed value.</li><li>
If a 8-bit CRC polynomial is selected, the length of the resulting checksum is 1-bytes. If a 16-bit CRC polynomial is selected, the length of the resulting checksum is 2-bytes. If a 32-bit CRC polynomial is selected, the length of the resulting checksum is 4-bytes.</li><li>
The configuration bits in this property are common to both TX and RX modes; however, this property is only applicable when automatic Packet Handling is enabled (e.g., when using the TX FIFO as the modulation source in TX mode, or when <a href="#field-PKT_CONFIG1%3APH_RX_DISABLE">PKT_CONFIG1:PH_RX_DISABLE</a>
 is cleared in RX mode).</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_CRC_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="1">CRC_SEED</td>
<td colspan="3">ALT_CRC_POLYNOMIAL</td>
<td colspan="4">CRC_POLYNOMIAL</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="1">0x0</td>
<td colspan="3">0x0</td>
<td colspan="4">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_CRC_CONFIG">PKT_CRC_CONFIG</a><ul>
<li><a name="field-PKT_CRC_CONFIG%3ACRC_SEED">CRC_SEED</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">CRC_SEED_0</td><td>0</td><td align="left">
<ul><li>
Use all 0's for the CRC Seed.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CRC_SEED_1</td><td>1</td><td align="left">
<ul><li>
Use all 1's for the CRC Seed.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_CRC_CONFIG%3AALT_CRC_POLYNOMIAL">ALT_CRC_POLYNOMIAL</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NO_CRC</td><td>0</td><td align="left">
<ul><li>
None</li></ul>
</td></tr>
<tr valign="top"><td align="left">ITU_T_CRC8</td><td>1</td><td align="left">
<ul><li>
ITU-T CRC8:   X8+X2+X+1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IEC_16</td><td>2</td><td align="left">
<ul><li>
IEC-16:       X16+X14+X12+X11+X9+X8+X7+X4+X+1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">BAICHEVA_16</td><td>3</td><td align="left">
<ul><li>
Baicheva-16:  X16+X15+X12+X7+X6+X4+X3+1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CRC_16_IBM</td><td>4</td><td align="left">
<ul><li>
CRC-16 (IBM): X16+X15+X2+1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CCITT_16</td><td>5</td><td align="left">
<ul><li>
CCIT-16:      X16+X12+X5+1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CRC_16_DNP</td><td>6</td><td align="left">
<ul><li>
CRC-16-DNP:   X16+X13+X12+X11+X10+X8+X6+X5+X2+1.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_CRC_CONFIG%3ACRC_POLYNOMIAL">CRC_POLYNOMIAL</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NO_CRC</td><td>0</td><td align="left">
<ul><li>
None</li></ul>
</td></tr>
<tr valign="top"><td align="left">ITU_T_CRC8</td><td>1</td><td align="left">
<ul><li>
ITU-T CRC8:   X8+X2+X+1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IEC_16</td><td>2</td><td align="left">
<ul><li>
IEC-16:       X16+X14+X12+X11+X9+X8+X7+X4+X+1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">BAICHEVA_16</td><td>3</td><td align="left">
<ul><li>
Baicheva-16:  X16+X15+X12+X7+X6+X4+X3+1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CRC_16_IBM</td><td>4</td><td align="left">
<ul><li>
CRC-16 (IBM): X16+X15+X2+1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CCITT_16</td><td>5</td><td align="left">
<ul><li>
CCIT-16:      X16+X12+X5+1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">KOOPMAN</td><td>6</td><td align="left">
<ul><li>
Koopman:      X32+X30+X29+X28+X26+X20+X19+X17+X16+X15+X11+X10+X7+X6+X4+X2+X+1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">IEEE_802_3</td><td>7</td><td align="left">
<ul><li>
IEEE 802.3:   X32+X26+X23+X22+X16+X12+X11+X10+X8+X7+X5+X4+X2+X+1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CASTAGNOLI</td><td>8</td><td align="left">
<ul><li>
Castagnoli:   X32+X28+X27+X26+X25+X23+X22+X20+X19+X18+X14+X13+X11+X10+X9+X8+X6+1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CRC_16_DNP</td><td>9</td><td align="left">
<ul><li>
CRC-16-DNP:   X16+X13+X12+X11+X10+X8+X6+X5+X2+1.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_WHT_POLY">PKT_WHT_POLY</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x01 ... 0x02</li>
<li>Summary: 16-bit polynomial value for the PN Generator (e.g., for Data Whitening)</li>
<li>Purpose:</li>
<ul><li>
The chip contains a 16-bit linear feedback shift register (LFSR) for the purpose of generating a pseudo-random number (PN).  The resulting PN sequence may be used for data whitening/de-whitening by XOR-ing the output with the data bits of specified fields.</li><li>
The PN sequence may also be used a modulation source for the TXDATA stream through configuration of the MODEM_MOD_TYPE property.  This is often useful for test purposes (e.g., BER tests).</li><li>
The PN sequence generated by the LFSR is determined by the selected 16-bit polynomial and starting seed value.  This property defines the polynomial.</li><li>
In general, it is desired to select a polynomial value that results in a maximal length run sequence, where the PN pattern length = 2^N - 1 (e.g., pattern length = 511 bits for a PN9 sequence).  There may be more than one polynomial value that will result in a PN sequence of a desired length; the following polynomial values are provided as examples for a variety of popular PN sequence lengths.</li><li>
- PN6:  PKT_WHT_POLY = 0x0030.</li><li>
- PN9:  PKT_WHT_POLY = 0x0108.</li><li>
- PN11:  PKT_WHT_POLY = 0x0500.</li><li>
- PN13:  PKT_WHT_POLY = 0x1B00.</li><li>
- PN15:  PKT_WHT_POLY = 0x6000.</li><li>
Additional properties related to the generation of the PN sequence are PKT_WHT_SEED and <a href="#prop-PKT_WHT_BIT_NUM">PKT_WHT_BIT_NUM</a>
.</li></ul>
<li>Defaults: 0x01, 0x08</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_WHT_POLY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">WHT_POLY[15:8]</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">WHT_POLY[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">0x1</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">0x8</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_WHT_POLY">PKT_WHT_POLY</a><ul>
<li><a name="field-PKT_WHT_POLY%3AWHT_POLY">WHT_POLY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Defines the 16-bit PN polynomial value.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_WHT_SEED">PKT_WHT_SEED</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x03 ... 0x04</li>
<li>Summary: 16-bit seed value for the PN Generator (e.g., for Data Whitening)</li>
<li>Purpose:</li>
<ul><li>
The PN sequence generated by the LFSR is determined by the selected 16-bit polynomial and starting seed value.  This property defines the starting seed value.</li><li>
The seed value determines the starting state of the PN sequence, but does not affect the bit order of the sequence.</li><li>
Please refer to the text description for <a href="#prop-PKT_WHT_POLY">PKT_WHT_POLY</a>
 for more details regarding configuration of the PN Generator.</li></ul>
<li>Defaults: 0xff, 0xff</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_WHT_SEED</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="8">WHT_SEED[15:8]</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">WHT_SEED[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="8">0xff</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">0xff</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_WHT_SEED">PKT_WHT_SEED</a><ul>
<li><a name="field-PKT_WHT_SEED%3AWHT_SEED">WHT_SEED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Defines the 16-bit PN seed value.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_WHT_BIT_NUM">PKT_WHT_BIT_NUM</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x05</li>
<li>Summary: Selects which bit of the LFSR (used to generate the PN / data whitening sequence) is used as the output bit for data scrambling.</li>
<li>Purpose:</li>
<ul><li>
This property determines which bit of the 16-bit LFSR is taken as the output bit, to be XOR'ed with the Payload data fields when data whitening is enabled.</li><li>
Selection of the output bit number will affect the starting point of the PN sequence, but will not affect the bit order or pattern of the sequence itself.</li><li>
Please refer to the text description for <a href="#prop-PKT_WHT_POLY">PKT_WHT_POLY</a>
 for more details regarding configuration of the PN Generator.</li><li>
This property also allows configuration of special software-based data whitening and CRC algorithms (as compared with the normal hardware-based implementation using the built-in LFSR). This is provided to allow compatibility with data whitening and CRC algorithms from other vendors; contact Silicon Labs Applications Support for further details.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_WHT_BIT_NUM</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="1">SW_WHT_CTRL</td>
<td colspan="1">SW_CRC_CTRL</td>
<td colspan="1">PN_DIRECTION</td>
<td>0</td>
<td colspan="4">WHT_BIT_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td colspan="4">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_WHT_BIT_NUM">PKT_WHT_BIT_NUM</a><ul>
<li><a name="field-PKT_WHT_BIT_NUM%3ASW_WHT_CTRL">SW_WHT_CTRL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enables software whitening over the packet.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Disable the software based data whitening algorithm.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Enable the software based data whitening algorithm.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_WHT_BIT_NUM%3ASW_CRC_CTRL">SW_CRC_CTRL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enables software-based CRC calculation over the packet, and is only applicable when also using software-based data whitening by setting the SW_WHT_CTRL bit. If not using software-based whitening, CRC functionality must be configured in the Packet Handler (see <a href="#prop-PKT_CRC_CONFIG">PKT_CRC_CONFIG</a>
).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Disable the software based CRC engine.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Enable the software based CRC engine.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_WHT_BIT_NUM%3APN_DIRECTION">PN_DIRECTION</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit controls the direction data bits are shifted during the whitening operation.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SAME</td><td>1</td><td align="left">
<ul><li>
Data bits are shifted from bit 7 down to bit 0, in the same direction the polynomial bits are shifted from bit 8 down to bit 0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">FORWARD</td><td>0</td><td align="left">
<ul><li>
Data bits are shifted from bit 7 down to bit 0, in the same direction the polynomial bits are shifted from bit 8 down to bit 0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">REVERSE</td><td>0</td><td align="left">
<ul><li>
Data bits are shifted from bit 0 up to bit 7, in the opposite direction the polynomial bits are shifted from bit 8 down to bit 0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">REVERSED</td><td>1</td><td align="left">
<ul><li>
Data bits are shifted from bit 0 up to bit 7, in the opposite direction the polynomial bits are shifted from bit 8 down to bit 0.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_WHT_BIT_NUM%3AWHT_BIT_NUM">WHT_BIT_NUM</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Bit 0 is selected as the output bit for data whitening.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Bit 1 is selected as the output bit for data whitening.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
Bit 2 is selected as the output bit for data whitening.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
Bit 3 is selected as the output bit for data whitening.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_4</td><td>4</td><td align="left">
<ul><li>
Bit 4 is selected as the output bit for data whitening.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_5</td><td>5</td><td align="left">
<ul><li>
Bit 5 is selected as the output bit for data whitening.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_6</td><td>6</td><td align="left">
<ul><li>
Bit 6 is selected as the output bit for data whitening.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_7</td><td>7</td><td align="left">
<ul><li>
Bit 7 is selected as the output bit for data whitening.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_8</td><td>8</td><td align="left">
<ul><li>
Bit 8 is selected as the output bit for data whitening.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_9</td><td>9</td><td align="left">
<ul><li>
Bit 9 is selected as the output bit for data whitening.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_10</td><td>10</td><td align="left">
<ul><li>
Bit 10 is selected as the output bit for data whitening.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_11</td><td>11</td><td align="left">
<ul><li>
Bit 11 is selected as the output bit for data whitening.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_12</td><td>12</td><td align="left">
<ul><li>
Bit 12 is selected as the output bit for data whitening.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_13</td><td>13</td><td align="left">
<ul><li>
Bit 13 is selected as the output bit for data whitening.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_14</td><td>14</td><td align="left">
<ul><li>
Bit 14 is selected as the output bit for data whitening.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_15</td><td>15</td><td align="left">
<ul><li>
Bit 15 is selected as the output bit for data whitening.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_CONFIG1">PKT_CONFIG1</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x06</li>
<li>Summary: General configuration bits for transmission or reception of a packet.</li>
<li>Purpose:</li>
<ul><li>
This property provides general configuration bits for transmission or reception of a packet.
    </li><li>
The configuration bits in this property are generally common to both TX and RX modes;        an exception is the PH_RX_DISABLE bit which is applicable only in RX mode. </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_CONFIG1</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="1">PH_FIELD_SPLIT</td>
<td colspan="1">PH_RX_DISABLE</td>
<td colspan="1">4FSK_EN</td>
<td colspan="1">RX_MULTI_PKT</td>
<td colspan="1">MANCH_POL</td>
<td colspan="1">CRC_INVERT</td>
<td colspan="1">CRC_ENDIAN</td>
<td colspan="1">BIT_ORDER</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_CONFIG1">PKT_CONFIG1</a><ul>
<li><a name="field-PKT_CONFIG1%3APH_FIELD_SPLIT">PH_FIELD_SPLIT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
In many links, the flow of information is primarily in one direction with only brief acknowledgement (ACK) packets sent in the reverse direction.    In such a case, it is inconvenient to re-define the field-level properties (e.g., field length, data whitening, etc.) in between each TX-to-RX-to-TX transition.
    </li><li>
The chip provides for "splitting" the definitions of field-level properties in TX and RX mode.    That is, the chip is capable of using one shared set of field-level properties for both TX and RX, or separate sets of field-level properties in TX and RX. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">FIELD_SHARED</td><td>0</td><td align="left">
<ul><li>
Field level properties are shared between TX and RX modes (defined in property addresses 0x120D to 0x1220).</li></ul>
</td></tr>
<tr valign="top"><td align="left">FIELD_SPLIT</td><td>1</td><td align="left">
<ul><li>
Field level properties are split between TX and RX modes.  TX field-level properties are defined from property address 0x120D to 0x1220, RX field-level properties from 0x1221 to 0x1234.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_CONFIG1%3APH_RX_DISABLE">PH_RX_DISABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit controls whether automatic Packet Handling functionality is enabled/disabled in RX mode.     Certain data processing functions (e.g., variable length packets, CRC calculation/checking, data whitening, etc.)    are not available unless Packet Handling is enabled.    Note:  Packet Handling is always available in TX mode; there is no similar bit for enabling/disabling Packet Handling in TX mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">RX_ENABLED</td><td>0</td><td align="left">
<ul><li>
Packet Handler is enabled in RX mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_DISABLED</td><td>1</td><td align="left">
<ul><li>
Packet Handler is disabled in RX mode.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_CONFIG1%3A4FSK_EN">4FSK_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, enables 4(G)FSK processing across the selected field.     The Modem must be additionally configured for 4(G)FSK demodulation through appropriate setting of the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property;    the 4FSK bit simply configures the PH to process the data stream to the RX FIFO as bit pairs (instead of as single bits for 2(G)FSK mode).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
The modem is not in 4(G)FSK mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
The modem is in 4(G)FSK mode.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_CONFIG1%3ARX_MULTI_PKT">RX_MULTI_PKT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
In normal operation, the chip receives one packet and then exits to the operational state specified in the <a href="#cmd-START_RX"><code>START_RX</code></a>
 command.    </li><li>
In the event reception of additional packets is desired,    it is necessary to command the chip to re-enter RX mode by issuing another <a href="#cmd-START_RX"><code>START_RX</code></a>
 command (or alternatively, specify the exit mode as "Return to RX mode").    </li><li>
If this bit is set, the chip is configured to receive multiple packets without ever exiting from RX mode.    Upon reception of a valid packet, the Packet Handler and Modem are re-armed to immediately acquire another packet.     The Payload contents of subsequent packets are stored in the RX FIFO following the contents of the first packet.
    </li><li>
To terminate reception of packets, the chip must be explicitly commanded to leave RX mode through use of the <a href="#cmd-CHANGE_STATE"><code>CHANGE_STATE</code></a>
 command. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Turn off receive chain after packet is received.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Leave receive chain enabled after packet is received for acquisition of additional packets.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_CONFIG1%3AMANCH_POL">MANCH_POL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Manchester encoding operates by replacing each bit with a two-chip pattern.     This bit selects the polarity of Manchester encoding/decoding.
    </li><li>
The selected coding polarity is applied to all fields in the packet;    it is not possible to select the coding polarity on a field-by-field basis. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">PATTERN_10</td><td>0</td><td align="left">
<ul><li>
0 is encoded to/decoded from a 10 Manchester pattern, and a 1 is encoded to/decoded from a 01 Manchester pattern.</li></ul>
</td></tr>
<tr valign="top"><td align="left">PATTERN_01</td><td>1</td><td align="left">
<ul><li>
0 is encoded to/decoded from a 01 Manchester pattern, and a 1 is encoded to/decoded from a 10 Manchester pattern.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_CONFIG1%3ACRC_INVERT">CRC_INVERT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit determines whether each bit in the transmitted or received CRC checksum is inverted in polarity.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NO_INVERT</td><td>0</td><td align="left">
<ul><li>
Transmit/receive each CRC checksum bit with non-inverted polarity.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INVERT_CRC</td><td>1</td><td align="left">
<ul><li>
In TX mode, calculate the CRC checksum and then invert the polarity of each checksum bit before transmission.     In RX mode, invert the polarity of each received CRC checksum bit prior to comparison.     In both modes, the data in the FIFOs remains unaltered.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_CONFIG1%3ACRC_ENDIAN">CRC_ENDIAN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit selects the order in which the bytes of the CRC checksum are transmitted or received.
    </li><li>
Note:  if a 16-bit CRC polynomial is selected (in <a href="#prop-PKT_CRC_CONFIG">PKT_CRC_CONFIG</a>
),    the length of the resulting checksum is 2-bytes.      If a 32-bit CRC polynomial is selected, the length of the resulting checksum is 4-bytes. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">LSBYTE_FIRST</td><td>0</td><td align="left">
<ul><li>
The CRC bytes are received/transmitted in the order: lowest byte to highest byte.</li></ul>
</td></tr>
<tr valign="top"><td align="left">MSBYTE_FIRST</td><td>1</td><td align="left">
<ul><li>
The CRC bytes are received/transmitted in the order: highest byte to lowest byte.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_CONFIG1%3ABIT_ORDER">BIT_ORDER</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit selects the transmission/reception order for the bits in all data fields.    Note: The Preamble and Sync Word fields are always transmitted or received LSB first     (little-endian), regardless of the state of this bit.
    </li><li>
This bit does not affect the transmission/reception order of the bytes.    Example: the transmission of bytes will match the order in which they are stored in the TX FIFO.     However, this bit selects whether each byte is transmitted or received in big-endian or little-endian fashion.
    </li><li>
In RX mode, received data bits observed in real-time (on a GPIO pin)    always reflect their true time-wise sequence on the air interface;    bit order inversion is performed only on bits stored in the RX FIFO. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">MSBIT_FIRST</td><td>0</td><td align="left">
<ul><li>
MSB first for all bytes in data fields (big-endian). Bit 7 is transmitted/received first, time-wise.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LSBIT_FIRST</td><td>1</td><td align="left">
<ul><li>
LSB first for all bytes in data fields (little-endian). Bit 0 is transmitted/received first, time-wise.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_CONFIG2">PKT_CONFIG2</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x07</li>
<li>Summary: General packet configuration bits.</li>
<li>Purpose:</li>
<ul><li>
General packet configuration bits.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_CONFIG2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x07</td>
<td colspan="1">CRC_BIT_ENDIAN</td>
<td colspan="1">CRC_PADDING</td>
<td colspan="1">ALT_CRC_SEED</td>
<td colspan="1">EN_3_OF_6</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x07</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_CONFIG2">PKT_CONFIG2</a><ul>
<li><a name="field-PKT_CONFIG2%3ACRC_BIT_ENDIAN">CRC_BIT_ENDIAN</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">MSBIT_FIRST</td><td>0</td><td align="left">
<ul><li>
CRC is transmitted most significant bit first. Bit 7 transmitted first timewise.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LSBIT_FIRST</td><td>1</td><td align="left">
<ul><li>
CRC is transmitted least significant bit first. Bit 0 transmitted first timewise.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_CONFIG2%3ACRC_PADDING">CRC_PADDING</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NO_PADDING</td><td>0</td><td align="left">
<ul><li>
CRC engine does not pad if message length is less than 32 bits.</li></ul>
</td></tr>
<tr valign="top"><td align="left">PAD_ZEROS</td><td>1</td><td align="left">
<ul><li>
CRC engine pads zeros if the message length is less than 32 bits.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_CONFIG2%3AALT_CRC_SEED">ALT_CRC_SEED</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ALT_CRC_SEED_0</td><td>0</td><td align="left">
<ul><li>
Use all 0's for the CRC Seed.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ALT_CRC_SEED_1</td><td>1</td><td align="left">
<ul><li>
Use all 1's for the CRC Seed.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_CONFIG2%3AEN_3_OF_6">EN_3_OF_6</a>
<dl><dt>Description:</dt><dd>
<ul><li>
 Enables 3 of 6 encoding/decoding. The encoding/decoding is not applied to preamble and sync fields but for all five fields and the CRC. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Data encoding 3 of 6 is disabled. </li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Data encoding 3 of 6 is enabled. </li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_LEN">PKT_LEN</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x08</li>
<li>Summary: Configuration bits for reception of a variable length packet.</li>
<li>Purpose:</li>
<ul><li>
The chip supports reception of a variable length packet.    This property configures parameters associated with variable length packet functionality.
    </li><li>
This property is applicable only in RX mode, and only when the automatic Packet Handler is enabled (i.e.,<a href="#field-PKT_CONFIG1%3APH_RX_DISABLE">PKT_CONFIG1:PH_RX_DISABLE</a>
 is cleared).
    </li><li>
The length value is received at the end of the field specified by the <a href="#field-PKT_LEN_FIELD_SOURCE%3ASRC_FIELD">PKT_LEN_FIELD_SOURCE:SRC_FIELD</a>
 value.     The received length value always describes the variable length of the field pointed to by the DST_FIELD parameter.     As the complete packet may consist of other fixed-length fields in addition to the variable-length field, the total packet length may be different than the received length value.     The received length value of only the variable-length field may be extracted and returned using the <a href="#cmd-PACKET_INFO"><code>PACKET_INFO</code></a>
 command,     or may be retrieved directly from the RX FIFO in the event the IN_FIFO bit is set.     If using the <a href="#cmd-PACKET_INFO"><code>PACKET_INFO</code></a>
 command to retrieve the length value,     the command must be issued prior to re-entering RX mode to receive the next packet,    as the length value is cleared upon entering RX mode. </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_LEN</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x08</td>
<td>0</td>
<td colspan="1">INFINITE_LEN</td>
<td colspan="1">ENDIAN</td>
<td colspan="1">SIZE</td>
<td colspan="1">IN_FIFO</td>
<td colspan="3">DST_FIELD</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x08</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="3">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_LEN">PKT_LEN</a><ul>
<li><a name="field-PKT_LEN%3AINFINITE_LEN">INFINITE_LEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Allows for a infinte length packet to be received.  Useful for packets greater than can be supported using the 5 fields.               If active, after sync detection, data will be placed into the RX FIFO until RX is exited manually by changing the state of the radio.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NORMAL</td><td>0</td><td align="left">
<ul><li>
Normal length packet handler mode.  Total packet length is a sum of all lengths specified in the fields.</li></ul>
</td></tr>
<tr valign="top"><td align="left">INFINITE</td><td>1</td><td align="left">
<ul><li>
Infinite length packet rx active.  The fields will be repeated continuously until RX is manually exited.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_LEN%3AENDIAN">ENDIAN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The received field length value may be either one or two bytes in length.     In the event the received field length value is two bytes in length (i.e., the SIZE bit is set),     the ENDIAN bit determines whether the received field length value is considered as most significant byte first or least significant byte first. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">LITTLE</td><td>0</td><td align="left">
<ul><li>
The received field length value is least significant byte first.</li></ul>
</td></tr>
<tr valign="top"><td align="left">BIG</td><td>1</td><td align="left">
<ul><li>
The received field length value is most significant byte first.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_LEN%3ASIZE">SIZE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The received field length value may be either one or two bytes in length.    The SIZE bit determines the length of the received field length value. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
The received field length value is one byte in length.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
The received field length value is two bytes in length.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_LEN%3AIN_FIFO">IN_FIFO</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip provides the ability to strip off the received field length byte(s) and store only the Payload data bytes in the RX FIFO.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">CUT_OUT</td><td>0</td><td align="left">
<ul><li>
The received data bytes containing the length field value are not put in the RX FIFO.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LEAVE_IN</td><td>1</td><td align="left">
<ul><li>
The received data bytes containing the field length value are put in the RX FIFO.  The stored value represents the value of the received length data bytes, prior to adjustment by the LEN_ADJUST value (if applicable).</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_LEN%3ADST_FIELD">DST_FIELD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This value determines which data field will be configured as a variable length field.     This value must be greater than the value in the <a href="#field-PKT_LEN_FIELD_SOURCE%3ASRC_FIELD">PKT_LEN_FIELD_SOURCE:SRC_FIELD</a>
    (i.e., the variable length field must be located after the field containing the field length bytes).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disables variable length packet mode;    the chip receives fixed-length packets with the field lengths specified by the PKT_FIELD_X_LENGTH properties,     or specified by the packet length value passed to the <a href="#cmd-START_RX"><code>START_RX</code></a>
 command.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Disallowed value (Field 1 may not be configured as a variable length field).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
Field 2 is configured as the variable length field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
Field 3 is configured as the variable length field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_4</td><td>4</td><td align="left">
<ul><li>
Field 4 is configured as the variable length field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_5</td><td>5</td><td align="left">
<ul><li>
Field 5 is configured as the variable length field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_6</td><td>6</td><td align="left">
<ul><li>
Disables variable length packet mode; the chip receives fixed-length packets     with the field lengths specified by the PKT_FIELD_X_LENGTH properties.     However, the received field length value is captured from the specified SRC_FIELD and may be retrieved with the PKT_INFO command. </li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_7</td><td>7</td><td align="left">
<ul><li>
Disables variable length packet mode;     the chip receives fixed-length packets with the field lengths specified by the PKT_FIELD_X_LENGTH properties.     However, the received field length value is captured from the specified SRC_FIELD and may be retrieved with the PKT_INFO command. </li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_LEN_FIELD_SOURCE">PKT_LEN_FIELD_SOURCE</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x09</li>
<li>Summary: Field number containing the received packet length byte(s).</li>
<li>Purpose:</li>
<ul><li>
This property configures the chip for reception of a variable length packet, and defines where the length field is in the packet.  The packet length byte(s) must be the last byte(s) in a fixed length field and must precede the variable length field.</li><li>
This property is applicable only in RX mode, and only when the automatic Packet Handler is enabled (i.e., the PH_RX_DISABLE bit in the PKT_CONFIG1 property is cleared).</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_LEN_FIELD_SOURCE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x09</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="3">SRC_FIELD</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x09</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="3">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_LEN_FIELD_SOURCE">PKT_LEN_FIELD_SOURCE</a><ul>
<li><a name="field-PKT_LEN_FIELD_SOURCE%3ASRC_FIELD">SRC_FIELD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This value determines which data field will be processed as containing the packet length byte(s).  The SRC_FIELD value must be less than the value of <a href="#field-PKT_LEN%3ADST_FIELD">PKT_LEN:DST_FIELD</a>
 (i.e., the variable length field must be located after the field containing the packet length bytes).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Field 1 is processed as containing the packet length byte(s).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Field 1 is processed as containing the packet length byte(s).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
Field 2 is processed as containing the packet length byte(s).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
Field 3 is processed as containing the packet length byte(s).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_4</td><td>4</td><td align="left">
<ul><li>
Field 4 is processed as containing the packet length byte(s).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_5</td><td>5</td><td align="left">
<ul><li>
Disallowed value (Field 5 may not be configured as containing the packet length bytes).</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_LEN_ADJUST">PKT_LEN_ADJUST</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x0a</li>
<li>Summary: Provides for adjustment/offset of the received packet length value (in order to accommodate a variety of methods of defining total packet length).</li>
<li>Purpose:</li>
<ul><li>
It is possible to define the total length of a packet in a variety of ways     (e.g., including/excluding the packet length bytes, including/excluding the CRC bytes, etc.)     This property provides a means of adjusting/offsetting the received packet length value in order to comply with a wide range of packet length implementations.
    </li><li>
This property is applicable only in RX mode,    and only when the automatic Packet Handler is enabled     (i.e., the PH_RX_DISABLE bit in the <a href="#prop-PKT_CONFIG1">PKT_CONFIG1</a>
 property is cleared).
    </li><li>
The value of the LEN_ADJUST field is added to the received value of the packet length byte(s),    extracted from the field specified by the SRC_FIELD value in the <a href="#prop-PKT_LEN_FIELD_SOURCE">PKT_LEN_FIELD_SOURCE</a>
 property.     The resulting value is then used to configure the length of the variable length field specified by the DST_FIELD value in the <a href="#prop-PKT_LEN">PKT_LEN</a>
 property.
    </li><li>
The required constant value of the LEN_ADJUST field is typically defined in a protocol specification or regulatory standard,     or can be derived from the specification.
    </li><li>
The default processing mode of the chip is that the received packet length value does NOT include the packet length bytes,    and does NOT include CRC bytes.     In such a case, the LEN_ADJUST field should be set to 0x00.
    </li><li>
If the received packet length value includes the packet length bytes and/or the CRC bytes,    its effective value must be reduced by adding a negative offset.    In such a case, the LEN_ADJUST field should be set to the negative value of the extra byte count (in 2's complement format).     Example:  the transmitted packet has a 2-byte packet length field followed by a 10-byte Payload field,    and the value contained in the packet length bytes = 0x000C = 12 bytes.  The value of LEN_ADJUST should be set = 0xFE = -2.
    </li><li>
The LEN_ADJUST field is a signed value.
    </li><li>
The value of the packet length byte(s) returned by the <a href="#cmd-PACKET_INFO"><code>PACKET_INFO</code></a>
 command reflects the value extracted from the received packet,    prior to adjustment by the LEN_ADJUST value.     The value stored in the RX FIFO (in the event the <a href="#field-PKT_LEN%3AIN_FIFO">PKT_LEN:IN_FIFO</a>
 bit is set) also represents the unadjusted length value. </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_LEN_ADJUST</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0a</td>
<td colspan="8">LEN_ADJUST</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0a</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_LEN_ADJUST">PKT_LEN_ADJUST</a><ul>
<li><a name="field-PKT_LEN_ADJUST%3ALEN_ADJUST">LEN_ADJUST</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The value of the LEN_ADJUST field is added to the received value of the packet length byte(s);    the result is used to configure the length of the specified variable length field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_TX_THRESHOLD">PKT_TX_THRESHOLD</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x0b</li>
<li>Summary: TX FIFO almost empty threshold.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for two separate 64-byte FIFO memories for the purpose of storing transmit and receive data.                (When the <a href="#field-GLOBAL_CONFIG%3AFIFO_MODE">GLOBAL_CONFIG:FIFO_MODE</a>
 bit is set, these two FIFOs are combined into a single 129-byte shared FIFO.)</li><li>
This property is used to set a threshold value for the TX FIFO.                 An interrupt event is generated when the amount of empty space in the TX FIFO is equal to or greater than this threshold.
                </li><li>
The TX_FIFO_ALMOST_EMPTY interrupt may be used to signal the host MCU to store more data bytes into the TX FIFO,                thus providing a means for handling packets with lengths greater than the size of the TX FIFO (i.e., 64 bytes, or 129 bytes in shared FIFO mode). </li></ul>
<li>Defaults: 0x30</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_TX_THRESHOLD</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0b</td>
<td colspan="8">TX_THRESHOLD</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0b</td>
<td colspan="8">0x30</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_TX_THRESHOLD">PKT_TX_THRESHOLD</a><ul>
<li><a name="field-PKT_TX_THRESHOLD%3ATX_THRESHOLD">TX_THRESHOLD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Sets the TX FIFO Almost Empty threshold, in number of bytes.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x40</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RX_THRESHOLD">PKT_RX_THRESHOLD</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x0c</li>
<li>Summary: RX FIFO Almost Full threshold.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for two separate 64-byte FIFO memories for the purpose of storing transmit and receive data.                (When the <a href="#field-GLOBAL_CONFIG%3AFIFO_MODE">GLOBAL_CONFIG:FIFO_MODE</a>
 bit is set, these two FIFOs are combined into a single 129-byte shared FIFO.)</li><li>
This property is used to set a threshold value for the RX FIFO.                  An interrupt event is generated when the number of bytes stored in the RX FIFO is equal to or greater than this threshold.
                </li><li>
The RX_FIFO_ALMOST_FULL interrupt may be used to signal the host MCU to read more data bytes from the RX FIFO,                thus providing a means for handling packets with lengths greater than the size of the RX FIFO (i.e., 64 bytes, or 129 bytes in shared FIFO mode). </li></ul>
<li>Defaults: 0x30</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RX_THRESHOLD</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0c</td>
<td colspan="8">RX_THRESHOLD</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0c</td>
<td colspan="8">0x30</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RX_THRESHOLD">PKT_RX_THRESHOLD</a><ul>
<li><a name="field-PKT_RX_THRESHOLD%3ARX_THRESHOLD">RX_THRESHOLD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Sets the RX FIFO Almost Full threshold, in number of bytes.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x40</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_FIELD_1_LENGTH">PKT_FIELD_1_LENGTH</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x0d ... 0x0e</li>
<li>Summary: Unsigned 13-bit Field 1 length value.</li>
<li>Purpose:</li>
<ul><li>
The PKT_FIELD_1_LENGTH properties specify the length of Field 1 in bytes.        The field length is an unsigned 13-bit value.</li><li>
Partitioning of the Payload into separate fields is provided to support variable length packets,        and to allow different forms of data processing (e.g., Manchester encoding, data whitening, etc)        across different fields.</li><li>
These properties are applicable in TX mode only if the <a href="#cmd-START_TX"><code>START_TX</code></a>
 command is sent with the parameter TX_LEN=0.</li><li>
These properties are applicable in RX mode only under the following conditions: a) RX Packet Handling is enabled by clearing <a href="#field-PKT_CONFIG1%3APH_RX_DISABLE">PKT_CONFIG1:PH_RX_DISABLE</a>
, and b) The <a href="#cmd-START_RX"><code>START_RX</code></a>
 command is sent with the parameter RX_LEN=0, and c) <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 is cleared. (If <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 bit is set, the lengths of the various fields in RX mode are determined by the PKT_RX_FIELD_LENGTH_XX properties.)</li><li>
A value of zero in this property means that the field is not used.         During TX mode, data will be retrieved from the TX FIFO until encountering the first field whose length has been set to zero. During RX mode, data will be stored in the RX FIFO until again encountering the first field whose length has been set to zero.  It is possible (although not common) to set the length of Field 1 = 0 bytes, as this would indicate transmission/reception of a packet with no Payload data at all. </li><li>
 Field 1 cannot be configured as a variable length field, as there is no preceding field that may contain the variable length byte(s).</li></ul>
<li>Defaults: 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_FIELD_1_LENGTH</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0d</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="5">FIELD_1_LENGTH[12:8]</td>
</tr>
<tr><td>0x0e</td>
<td colspan="8">FIELD_1_LENGTH[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0d</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="5">0x0</td>
</tr>
<tr><td>0x0e</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_FIELD_1_LENGTH">PKT_FIELD_1_LENGTH</a><ul>
<li><a name="field-PKT_FIELD_1_LENGTH%3AFIELD_1_LENGTH">FIELD_1_LENGTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Bits 12 to 0 of the field length.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1fff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_FIELD_1_CONFIG">PKT_FIELD_1_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x0f</li>
<li>Summary: General data processing and packet configuration bits for Field 1.</li>
<li>Purpose:</li>
<ul><li>
Partitioning of the Payload into separate fields is provided to support features such as variable length packets and field-specific data processing        (e.g., Manchester encoding, data whitening, etc).         This property provides configuration bits for field-specific processing on Field 1.       </li><li>
The configuration bits in this property are common to both TX and RX modes dependent on <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
;       however, this property is only applicable when automatic Packet Handling is enabled (e.g.,        when using the TX FIFO as the modulation source in TX mode,       or when <a href="#field-PKT_CONFIG1%3APH_RX_DISABLE">PKT_CONFIG1:PH_RX_DISABLE</a>
 is cleared in RX mode).</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_FIELD_1_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0f</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">4FSK</td>
<td>0</td>
<td colspan="1">PN_START</td>
<td colspan="1">WHITEN</td>
<td colspan="1">MANCH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0f</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_FIELD_1_CONFIG">PKT_FIELD_1_CONFIG</a><ul>
<li><a name="field-PKT_FIELD_1_CONFIG%3A4FSK">4FSK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip supports field-specific configuration of (G)FSK modulation modes, i.e., 2(G)FSK across certain fields and 4(G)FSK across other fields.  In such a case, the Modem must be configured for 4(G)FSK operation across the entire packet (by setting the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), and the Packet Handler is then configured on a field-by-field basis to process the data stream from the FIFO as bit pairs (for 4(G)FSK) or single bits (for 2(G)FSK).</li><li>
When 4(G)FSK is enabled across a field, the PH pulls two bits from the FIFO and sends them to the TX Modulator to be transmitted as one-of-four deviation levels.</li><li>
When 4(G)FSK is disabled across a field, the PH pulls one bit from the FIFO and replaces it with the appropriate two bits that map to the outer two deviation levels.  Although the TX Modulator remains configured for four levels of deviation (by the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), using only the outer two deviation levels effectively results in 2(G)FSK modulation across that field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_1_CONFIG%3APN_START">PN_START</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip contains a linear feedback shift register (LFSR) for the purpose of generating a pseudo-random number (PN).  Data whitening/de-whitening may be obtained by XOR-ing the output from the resulting PN sequence with the data bits of specified fields.</li><li>
This bit controls whether the PN engine is freshly loaded with its seed value (specified in PKT_WHT_SEED_XX) at the start of this field, or whether the PN engine continues calculation from its last state (i.e., from the previous packet).  Note:  the seed value for the PN engine may only be loaded at the start of Field 1; it is not possible to re-load the seed value at any other place in the packet.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Continue PN generation using last state from previous packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Load PN engine with the seed value at the start of Field 1.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_1_CONFIG%3AWHITEN">WHITEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The data whitening/de-whitening function is only available when automatic Packet Handling is enabled (e.g., when using the TX FIFO as the modulation source in TX mode, or when the PH_RX_DISABLE bit in the PKT_CONFIG1 property is cleared in RX mode).</li><li>
In RX mode, the data de-whitening function is performed only on bits stored in the RX FIFO; received data bits observed in real-time (on a GPIO pin) are output prior to de-whitening.</li><li>
Enabling data whitening does not affect the over-the-air data rate.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable data whitening/de-whitening on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable data whitening/de-whitening on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_1_CONFIG%3AMANCH">MANCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Manchester encoding operates by replacing each bit with a two-chip pattern (e.g., each '0' bit with a '10' pattern     and each '1' bit with a '01' bit pattern, or vice versa).     The desired encoding polarity is selected by <a href="#field-PKT_CONFIG1%3AMANCH_POL">PKT_CONFIG1:MANCH_POL</a>
.    </li><li>
Enabling Manchester encoding in one or more fields does not affect the over-the-air data rate;    each bit/chip within the entire packet is transmitted at the same data rate (specified by the MODEM_DATA_RATE_X properties).     Manchester encoding simply affects the number of bits/chips that are sent (e.g., by replacing one bit with two chips).    </li><li>
In RX mode, the Manchester decoding function is performed only on bits stored in the RX FIFO;    received data bits observed in real-time (on a GPIO pin) are output prior to decoding.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable manchester encoding/decoding on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable manchester encoding/decoding on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_FIELD_1_CRC_CONFIG">PKT_FIELD_1_CRC_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x10</li>
<li>Summary: Configuration of CRC control bits across Field 1.</li>
<li>Purpose:</li>
<ul><li>
This property is use to control the calculation, transmission, and checking of CRC across Field 1.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_FIELD_1_CRC_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x10</td>
<td colspan="1">CRC_START</td>
<td colspan="1">ALT_CRC_START</td>
<td colspan="1">SEND_CRC</td>
<td colspan="1">SEND_ALT_CRC</td>
<td colspan="1">CHECK_CRC</td>
<td colspan="1">CHECK_ALT_CRC</td>
<td colspan="1">CRC_ENABLE</td>
<td colspan="1">ALT_CRC_ENABLE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x10</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_FIELD_1_CRC_CONFIG">PKT_FIELD_1_CRC_CONFIG</a><ul>
<li><a name="field-PKT_FIELD_1_CRC_CONFIG%3ACRC_START">CRC_START</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip contains a 32-bit CRC engine that may be configured for a variety of polynomials and seed values (refer to the PKT_CRC_CONFIG property).  This bit controls whether the CRC engine is freshly loaded with its seed value (<a href="#field-PKT_CRC_CONFIG%3ACRC_SEED">PKT_CRC_CONFIG:CRC_SEED</a>
) at the start of this field, or whether the CRC engine continues calculation from its last state (i.e., from the previous packet).  Note:  the seed value for the CRC engine may only be loaded at the start of Field 1; it is not possible to re-load the seed value at any other place in the packet.</li><li>
This bit is applicable in both TX and RX modes.</li><li>
If in RX mode and <a href="#prop-PKT_CONFIG1">PKT_CONFIG1</a>
:PH_FIELD_SPLIT is set, this bit is ignored and the CRC_START functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Continue CRC calculation using the last state from the previous packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Load the CRC engine with the seed value at the start of this field using <a href="#field-PKT_CRC_CONFIG%3ACRC_SEED">PKT_CRC_CONFIG:CRC_SEED</a>
.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_1_CRC_CONFIG%3AALT_CRC_START">ALT_CRC_START</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip contains a 16-bit CRC engine that may be configured for a variety of polynomials and seed values (refer to the <a href="#prop-PKT_CRC_CONFIG">PKT_CRC_CONFIG</a>
 property).                 This bit controls whether the CRC engine is freshly loaded with its seed value (<a href="#field-PKT_CRC_CONFIG%3ACRC_SEED">PKT_CRC_CONFIG:CRC_SEED</a>
)                at the start of this field, or whether the CRC engine continues calculation from its last state (i.e., from the previous packet).                 Note:  the seed value for the ALT CRC engine may only be loaded at the start of Field 1;                it is not possible to re-load the seed value at any other place in the packet.                </li><li>
This bit is applicable in both TX and RX modes.                </li><li>
If in RX mode and <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 bit is set,                this bit is ignored and the ALT_CRC_START functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">CONTINUE</td><td>0</td><td align="left">
<ul><li>
Continue 16-bit CRC calculation using the last state from the previous packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LOAD</td><td>1</td><td align="left">
<ul><li>
Load 16-bit CRC engine with seed value at the start of this field using <a href="#field-PKT_CRC_CONFIG%3ACRC_SEED">PKT_CRC_CONFIG:CRC_SEED</a>
.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_1_CRC_CONFIG%3ASEND_CRC">SEND_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in TX mode, and determines whether the accumulated CRC checksum will be transmitted at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not Transmit CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Transmit CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_1_CRC_CONFIG%3ASEND_ALT_CRC">SEND_ALT_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in TX mode, and determines whether the accumulated ALT CRC checksum will be transmitted at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not Transmit ALT CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Transmit ALT CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_1_CRC_CONFIG%3ACHECK_CRC">CHECK_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in RX mode, and determines whether the accumulated CRC checksum will be checked at the end of this field.</li><li>
If the <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 bit is set, this bit is ignored and the CHECK_CRC functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_1_CRC_CONFIG%3ACHECK_ALT_CRC">CHECK_ALT_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in RX mode, and determines whether the accumulated ALT CRC checksum will be checked at the end of this field.</li><li>
If the <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 bit is set, this bit is ignored and the CHECK_ALT_CRC functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check ALT CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check ALT CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_1_CRC_CONFIG%3ACRC_ENABLE">CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable in both TX and RX modes,            and enables CRC checksum calculation over this field.             Note:  enabling CRC calculation across a field does not automatically result in transmission/checking of the CRC checksum at the end of the field.</li><li>
If in RX mode and             <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 is set,             this bit is ignored and the CRC_ENABLE functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_1_CRC_CONFIG%3AALT_CRC_ENABLE">ALT_CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable in both TX and RX modes, and enables ALT CRC checksum calculation over this field.             Note:  enabling ALT CRC calculation across a field does not automatically result in transmission/checking of the ALT CRC checksum at the end of the field.            </li><li>
If in RX mode and <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 is set,            this bit is ignored and the ALT_CRC_ENABLE functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable ALT CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable ALT CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_FIELD_2_LENGTH">PKT_FIELD_2_LENGTH</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x11 ... 0x12</li>
<li>Summary: Unsigned 13-bit Field 2 length value.</li>
<li>Purpose:</li>
<ul><li>
The PKT_FIELD_2_LENGTH properties specify the length of Field 2 in bytes.        The field length is an unsigned 13-bit value.</li><li>
Field 2 may be configured as a variable length field by setting the appropriate value of <a href="#field-PKT_LEN%3ADST_FIELD">PKT_LEN:DST_FIELD</a>
; however, it is also necessary that a previous field contain the variable length byte(s). If configured as a variable length field, this property must be set with a value that represents the maximum expected length of the field.</li><li>
Please refer to the text description for <a href="#prop-PKT_FIELD_1_LENGTH">PKT_FIELD_1_LENGTH</a>
 for more details regarding field length configuration.</li></ul>
<li>Defaults: 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_FIELD_2_LENGTH</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x11</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="5">FIELD_2_LENGTH[12:8]</td>
</tr>
<tr><td>0x12</td>
<td colspan="8">FIELD_2_LENGTH[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x11</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="5">0x0</td>
</tr>
<tr><td>0x12</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_FIELD_2_LENGTH">PKT_FIELD_2_LENGTH</a><ul>
<li><a name="field-PKT_FIELD_2_LENGTH%3AFIELD_2_LENGTH">FIELD_2_LENGTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Bits 12 to 0 of the field length.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1fff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_FIELD_2_CONFIG">PKT_FIELD_2_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x13</li>
<li>Summary: General data processing and packet configuration bits for Field 2.</li>
<li>Purpose:</li>
<ul><li>
Partitioning of the Payload into separate fields is provided to support features such as variable length packets and field-specific data processing        (e.g., Manchester encoding, data whitening, etc).         This property provides configuration bits for field-specific processing on Field 2.       </li><li>
The configuration bits in this property are common to both TX and RX modes dependent on <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
;       however, this property is only applicable when automatic Packet Handling is enabled (e.g.,        when using the TX FIFO as the modulation source in TX mode,       or when <a href="#field-PKT_CONFIG1%3APH_RX_DISABLE">PKT_CONFIG1:PH_RX_DISABLE</a>
 is cleared in RX mode).</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_FIELD_2_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x13</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">4FSK</td>
<td>0</td>
<td>0</td>
<td colspan="1">WHITEN</td>
<td colspan="1">MANCH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x13</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_FIELD_2_CONFIG">PKT_FIELD_2_CONFIG</a><ul>
<li><a name="field-PKT_FIELD_2_CONFIG%3A4FSK">4FSK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip supports field-specific configuration of (G)FSK modulation modes, i.e., 2(G)FSK across certain fields and 4(G)FSK across other fields.  In such a case, the Modem must be configured for 4(G)FSK operation across the entire packet (by setting the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), and the Packet Handler is then configured on a field-by-field basis to process the data stream from the FIFO as bit pairs (for 4(G)FSK) or single bits (for 2(G)FSK).</li><li>
When 4(G)FSK is enabled across a field, the PH pulls two bits from the FIFO and sends them to the TX Modulator to be transmitted as one-of-four deviation levels.</li><li>
When 4(G)FSK is disabled across a field, the PH pulls one bit from the FIFO and replaces it with the appropriate two bits that map to the outer two deviation levels.  Although the TX Modulator remains configured for four levels of deviation (by the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), using only the outer two deviation levels effectively results in 2(G)FSK modulation across that field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_2_CONFIG%3AWHITEN">WHITEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The data whitening/de-whitening function is only available when automatic Packet Handling is enabled (e.g., when using the TX FIFO as the modulation source in TX mode, or when the PH_RX_DISABLE bit in the PKT_CONFIG1 property is cleared in RX mode).</li><li>
In RX mode, the data de-whitening function is performed only on bits stored in the RX FIFO; received data bits observed in real-time (on a GPIO pin) are output prior to de-whitening.</li><li>
Enabling data whitening does not affect the over-the-air data rate.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable data whitening/de-whitening on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable data whitening/de-whitening on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_2_CONFIG%3AMANCH">MANCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Manchester encoding operates by replacing each bit with a two-chip pattern (e.g., each '0' bit with a '10' pattern     and each '1' bit with a '01' bit pattern, or vice versa).     The desired encoding polarity is selected by <a href="#field-PKT_CONFIG1%3AMANCH_POL">PKT_CONFIG1:MANCH_POL</a>
.    </li><li>
Enabling Manchester encoding in one or more fields does not affect the over-the-air data rate;    each bit/chip within the entire packet is transmitted at the same data rate (specified by the MODEM_DATA_RATE_X properties).     Manchester encoding simply affects the number of bits/chips that are sent (e.g., by replacing one bit with two chips).    </li><li>
In RX mode, the Manchester decoding function is performed only on bits stored in the RX FIFO;    received data bits observed in real-time (on a GPIO pin) are output prior to decoding.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable manchester encoding/decoding on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable manchester encoding/decoding on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_FIELD_2_CRC_CONFIG">PKT_FIELD_2_CRC_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x14</li>
<li>Summary: Configuration of CRC control bits across Field 2.</li>
<li>Purpose:</li>
<ul><li>
This property is use to control the calculation, transmission, and checking of CRC across Field 2.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_FIELD_2_CRC_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x14</td>
<td>0</td>
<td>0</td>
<td colspan="1">SEND_CRC</td>
<td colspan="1">SEND_ALT_CRC</td>
<td colspan="1">CHECK_CRC</td>
<td colspan="1">CHECK_ALT_CRC</td>
<td colspan="1">CRC_ENABLE</td>
<td colspan="1">ALT_CRC_ENABLE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x14</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_FIELD_2_CRC_CONFIG">PKT_FIELD_2_CRC_CONFIG</a><ul>
<li><a name="field-PKT_FIELD_2_CRC_CONFIG%3ASEND_CRC">SEND_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in TX mode, and determines whether the accumulated CRC checksum will be transmitted at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not Transmit CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Transmit CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_2_CRC_CONFIG%3ASEND_ALT_CRC">SEND_ALT_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in TX mode, and determines whether the accumulated ALT CRC checksum will be transmitted at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not Transmit ALT CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Transmit ALT CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_2_CRC_CONFIG%3ACHECK_CRC">CHECK_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in RX mode, and determines whether the accumulated CRC checksum will be checked at the end of this field.</li><li>
If the <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 bit is set, this bit is ignored and the CHECK_CRC functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_2_CRC_CONFIG%3ACHECK_ALT_CRC">CHECK_ALT_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in RX mode, and determines whether the accumulated ALT CRC checksum will be checked at the end of this field.</li><li>
If the <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 bit is set, this bit is ignored and the CHECK_ALT_CRC functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check ALT CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check ALT CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_2_CRC_CONFIG%3ACRC_ENABLE">CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable in both TX and RX modes,            and enables CRC checksum calculation over this field.             Note:  enabling CRC calculation across a field does not automatically result in transmission/checking of the CRC checksum at the end of the field.</li><li>
If in RX mode and             <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 is set,             this bit is ignored and the CRC_ENABLE functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_2_CRC_CONFIG%3AALT_CRC_ENABLE">ALT_CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable in both TX and RX modes, and enables ALT CRC checksum calculation over this field.             Note:  enabling ALT CRC calculation across a field does not automatically result in transmission/checking of the ALT CRC checksum at the end of the field.            </li><li>
If in RX mode and <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 is set,            this bit is ignored and the ALT_CRC_ENABLE functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable ALT CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable ALT CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_FIELD_3_LENGTH">PKT_FIELD_3_LENGTH</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x15 ... 0x16</li>
<li>Summary: Unsigned 13-bit Field 3 length value.</li>
<li>Purpose:</li>
<ul><li>
The PKT_FIELD_3_LENGTH properties specify the length of Field 3 in bytes.        The field length is an unsigned 13-bit value.</li><li>
Field 3 may be configured as a variable length field by setting the appropriate value of <a href="#field-PKT_LEN%3ADST_FIELD">PKT_LEN:DST_FIELD</a>
; however, it is also necessary that a previous field contain the variable length byte(s). If configured as a variable length field, this property must be set with a value that represents the maximum expected length of the field.</li><li>
Please refer to the text description for <a href="#prop-PKT_FIELD_1_LENGTH">PKT_FIELD_1_LENGTH</a>
 for more details regarding field length configuration.</li></ul>
<li>Defaults: 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_FIELD_3_LENGTH</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x15</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="5">FIELD_3_LENGTH[12:8]</td>
</tr>
<tr><td>0x16</td>
<td colspan="8">FIELD_3_LENGTH[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x15</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="5">0x0</td>
</tr>
<tr><td>0x16</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_FIELD_3_LENGTH">PKT_FIELD_3_LENGTH</a><ul>
<li><a name="field-PKT_FIELD_3_LENGTH%3AFIELD_3_LENGTH">FIELD_3_LENGTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Bits 12 to 0 of the field length.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1fff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_FIELD_3_CONFIG">PKT_FIELD_3_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x17</li>
<li>Summary: General data processing and packet configuration bits for Field 3.</li>
<li>Purpose:</li>
<ul><li>
Partitioning of the Payload into separate fields is provided to support features such as variable length packets and field-specific data processing        (e.g., Manchester encoding, data whitening, etc).         This property provides configuration bits for field-specific processing on Field 3.       </li><li>
The configuration bits in this property are common to both TX and RX modes dependent on <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
;       however, this property is only applicable when automatic Packet Handling is enabled (e.g.,        when using the TX FIFO as the modulation source in TX mode,       or when <a href="#field-PKT_CONFIG1%3APH_RX_DISABLE">PKT_CONFIG1:PH_RX_DISABLE</a>
 is cleared in RX mode).</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_FIELD_3_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x17</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">4FSK</td>
<td>0</td>
<td>0</td>
<td colspan="1">WHITEN</td>
<td colspan="1">MANCH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x17</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_FIELD_3_CONFIG">PKT_FIELD_3_CONFIG</a><ul>
<li><a name="field-PKT_FIELD_3_CONFIG%3A4FSK">4FSK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip supports field-specific configuration of (G)FSK modulation modes, i.e., 2(G)FSK across certain fields and 4(G)FSK across other fields.  In such a case, the Modem must be configured for 4(G)FSK operation across the entire packet (by setting the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), and the Packet Handler is then configured on a field-by-field basis to process the data stream from the FIFO as bit pairs (for 4(G)FSK) or single bits (for 2(G)FSK).</li><li>
When 4(G)FSK is enabled across a field, the PH pulls two bits from the FIFO and sends them to the TX Modulator to be transmitted as one-of-four deviation levels.</li><li>
When 4(G)FSK is disabled across a field, the PH pulls one bit from the FIFO and replaces it with the appropriate two bits that map to the outer two deviation levels.  Although the TX Modulator remains configured for four levels of deviation (by the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), using only the outer two deviation levels effectively results in 2(G)FSK modulation across that field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_3_CONFIG%3AWHITEN">WHITEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The data whitening/de-whitening function is only available when automatic Packet Handling is enabled (e.g., when using the TX FIFO as the modulation source in TX mode, or when the PH_RX_DISABLE bit in the PKT_CONFIG1 property is cleared in RX mode).</li><li>
In RX mode, the data de-whitening function is performed only on bits stored in the RX FIFO; received data bits observed in real-time (on a GPIO pin) are output prior to de-whitening.</li><li>
Enabling data whitening does not affect the over-the-air data rate.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable data whitening/de-whitening on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable data whitening/de-whitening on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_3_CONFIG%3AMANCH">MANCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Manchester encoding operates by replacing each bit with a two-chip pattern (e.g., each '0' bit with a '10' pattern     and each '1' bit with a '01' bit pattern, or vice versa).     The desired encoding polarity is selected by <a href="#field-PKT_CONFIG1%3AMANCH_POL">PKT_CONFIG1:MANCH_POL</a>
.    </li><li>
Enabling Manchester encoding in one or more fields does not affect the over-the-air data rate;    each bit/chip within the entire packet is transmitted at the same data rate (specified by the MODEM_DATA_RATE_X properties).     Manchester encoding simply affects the number of bits/chips that are sent (e.g., by replacing one bit with two chips).    </li><li>
In RX mode, the Manchester decoding function is performed only on bits stored in the RX FIFO;    received data bits observed in real-time (on a GPIO pin) are output prior to decoding.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable manchester encoding/decoding on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable manchester encoding/decoding on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_FIELD_3_CRC_CONFIG">PKT_FIELD_3_CRC_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x18</li>
<li>Summary: Configuration of CRC control bits across Field 3.</li>
<li>Purpose:</li>
<ul><li>
This property is use to control the calculation, transmission, and checking of CRC across Field 3.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_FIELD_3_CRC_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x18</td>
<td>0</td>
<td>0</td>
<td colspan="1">SEND_CRC</td>
<td colspan="1">SEND_ALT_CRC</td>
<td colspan="1">CHECK_CRC</td>
<td colspan="1">CHECK_ALT_CRC</td>
<td colspan="1">CRC_ENABLE</td>
<td colspan="1">ALT_CRC_ENABLE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x18</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_FIELD_3_CRC_CONFIG">PKT_FIELD_3_CRC_CONFIG</a><ul>
<li><a name="field-PKT_FIELD_3_CRC_CONFIG%3ASEND_CRC">SEND_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in TX mode, and determines whether the accumulated CRC checksum will be transmitted at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not Transmit CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Transmit CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_3_CRC_CONFIG%3ASEND_ALT_CRC">SEND_ALT_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in TX mode, and determines whether the accumulated ALT CRC checksum will be transmitted at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not Transmit ALT CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Transmit ALT CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_3_CRC_CONFIG%3ACHECK_CRC">CHECK_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in RX mode, and determines whether the accumulated CRC checksum will be checked at the end of this field.</li><li>
If the <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 bit is set, this bit is ignored and the CHECK_CRC functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_3_CRC_CONFIG%3ACHECK_ALT_CRC">CHECK_ALT_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in RX mode, and determines whether the accumulated ALT CRC checksum will be checked at the end of this field.</li><li>
If the <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 bit is set, this bit is ignored and the CHECK_ALT_CRC functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check ALT CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check ALT CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_3_CRC_CONFIG%3ACRC_ENABLE">CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable in both TX and RX modes,            and enables CRC checksum calculation over this field.             Note:  enabling CRC calculation across a field does not automatically result in transmission/checking of the CRC checksum at the end of the field.</li><li>
If in RX mode and             <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 is set,             this bit is ignored and the CRC_ENABLE functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_3_CRC_CONFIG%3AALT_CRC_ENABLE">ALT_CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable in both TX and RX modes, and enables ALT CRC checksum calculation over this field.             Note:  enabling ALT CRC calculation across a field does not automatically result in transmission/checking of the ALT CRC checksum at the end of the field.            </li><li>
If in RX mode and <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 is set,            this bit is ignored and the ALT_CRC_ENABLE functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable ALT CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable ALT CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_FIELD_4_LENGTH">PKT_FIELD_4_LENGTH</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x19 ... 0x1a</li>
<li>Summary: Unsigned 13-bit Field 4 length value.</li>
<li>Purpose:</li>
<ul><li>
The PKT_FIELD_4_LENGTH properties specify the length of Field 4 in bytes.        The field length is an unsigned 13-bit value.</li><li>
Field 4 may be configured as a variable length field by setting the appropriate value of <a href="#field-PKT_LEN%3ADST_FIELD">PKT_LEN:DST_FIELD</a>
; however, it is also necessary that a previous field contain the variable length byte(s). If configured as a variable length field, this property must be set with a value that represents the maximum expected length of the field.</li><li>
Please refer to the text description for <a href="#prop-PKT_FIELD_1_LENGTH">PKT_FIELD_1_LENGTH</a>
 for more details regarding field length configuration.</li></ul>
<li>Defaults: 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_FIELD_4_LENGTH</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x19</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="5">FIELD_4_LENGTH[12:8]</td>
</tr>
<tr><td>0x1a</td>
<td colspan="8">FIELD_4_LENGTH[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x19</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="5">0x0</td>
</tr>
<tr><td>0x1a</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_FIELD_4_LENGTH">PKT_FIELD_4_LENGTH</a><ul>
<li><a name="field-PKT_FIELD_4_LENGTH%3AFIELD_4_LENGTH">FIELD_4_LENGTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Bits 12 to 0 of the field length.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1fff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_FIELD_4_CONFIG">PKT_FIELD_4_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x1b</li>
<li>Summary: General data processing and packet configuration bits for Field 4.</li>
<li>Purpose:</li>
<ul><li>
Partitioning of the Payload into separate fields is provided to support features such as variable length packets and field-specific data processing        (e.g., Manchester encoding, data whitening, etc).         This property provides configuration bits for field-specific processing on Field 4.       </li><li>
The configuration bits in this property are common to both TX and RX modes dependent on <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
;       however, this property is only applicable when automatic Packet Handling is enabled (e.g.,        when using the TX FIFO as the modulation source in TX mode,       or when <a href="#field-PKT_CONFIG1%3APH_RX_DISABLE">PKT_CONFIG1:PH_RX_DISABLE</a>
 is cleared in RX mode).</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_FIELD_4_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1b</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">4FSK</td>
<td>0</td>
<td>0</td>
<td colspan="1">WHITEN</td>
<td colspan="1">MANCH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1b</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_FIELD_4_CONFIG">PKT_FIELD_4_CONFIG</a><ul>
<li><a name="field-PKT_FIELD_4_CONFIG%3A4FSK">4FSK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip supports field-specific configuration of (G)FSK modulation modes, i.e., 2(G)FSK across certain fields and 4(G)FSK across other fields.  In such a case, the Modem must be configured for 4(G)FSK operation across the entire packet (by setting the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), and the Packet Handler is then configured on a field-by-field basis to process the data stream from the FIFO as bit pairs (for 4(G)FSK) or single bits (for 2(G)FSK).</li><li>
When 4(G)FSK is enabled across a field, the PH pulls two bits from the FIFO and sends them to the TX Modulator to be transmitted as one-of-four deviation levels.</li><li>
When 4(G)FSK is disabled across a field, the PH pulls one bit from the FIFO and replaces it with the appropriate two bits that map to the outer two deviation levels.  Although the TX Modulator remains configured for four levels of deviation (by the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), using only the outer two deviation levels effectively results in 2(G)FSK modulation across that field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_4_CONFIG%3AWHITEN">WHITEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The data whitening/de-whitening function is only available when automatic Packet Handling is enabled (e.g., when using the TX FIFO as the modulation source in TX mode, or when the PH_RX_DISABLE bit in the PKT_CONFIG1 property is cleared in RX mode).</li><li>
In RX mode, the data de-whitening function is performed only on bits stored in the RX FIFO; received data bits observed in real-time (on a GPIO pin) are output prior to de-whitening.</li><li>
Enabling data whitening does not affect the over-the-air data rate.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable data whitening/de-whitening on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable data whitening/de-whitening on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_4_CONFIG%3AMANCH">MANCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Manchester encoding operates by replacing each bit with a two-chip pattern (e.g., each '0' bit with a '10' pattern     and each '1' bit with a '01' bit pattern, or vice versa).     The desired encoding polarity is selected by <a href="#field-PKT_CONFIG1%3AMANCH_POL">PKT_CONFIG1:MANCH_POL</a>
.    </li><li>
Enabling Manchester encoding in one or more fields does not affect the over-the-air data rate;    each bit/chip within the entire packet is transmitted at the same data rate (specified by the MODEM_DATA_RATE_X properties).     Manchester encoding simply affects the number of bits/chips that are sent (e.g., by replacing one bit with two chips).    </li><li>
In RX mode, the Manchester decoding function is performed only on bits stored in the RX FIFO;    received data bits observed in real-time (on a GPIO pin) are output prior to decoding.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable manchester encoding/decoding on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable manchester encoding/decoding on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_FIELD_4_CRC_CONFIG">PKT_FIELD_4_CRC_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x1c</li>
<li>Summary: Configuration of CRC control bits across Field 4.</li>
<li>Purpose:</li>
<ul><li>
This property is use to control the calculation, transmission, and checking of CRC across Field 4.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_FIELD_4_CRC_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1c</td>
<td>0</td>
<td>0</td>
<td colspan="1">SEND_CRC</td>
<td colspan="1">SEND_ALT_CRC</td>
<td colspan="1">CHECK_CRC</td>
<td colspan="1">CHECK_ALT_CRC</td>
<td colspan="1">CRC_ENABLE</td>
<td colspan="1">ALT_CRC_ENABLE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1c</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_FIELD_4_CRC_CONFIG">PKT_FIELD_4_CRC_CONFIG</a><ul>
<li><a name="field-PKT_FIELD_4_CRC_CONFIG%3ASEND_CRC">SEND_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in TX mode, and determines whether the accumulated CRC checksum will be transmitted at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not Transmit CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Transmit CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_4_CRC_CONFIG%3ASEND_ALT_CRC">SEND_ALT_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in TX mode, and determines whether the accumulated ALT CRC checksum will be transmitted at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not Transmit ALT CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Transmit ALT CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_4_CRC_CONFIG%3ACHECK_CRC">CHECK_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in RX mode, and determines whether the accumulated CRC checksum will be checked at the end of this field.</li><li>
If the <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 bit is set, this bit is ignored and the CHECK_CRC functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_4_CRC_CONFIG%3ACHECK_ALT_CRC">CHECK_ALT_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in RX mode, and determines whether the accumulated ALT CRC checksum will be checked at the end of this field.</li><li>
If the <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 bit is set, this bit is ignored and the CHECK_ALT_CRC functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check ALT CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check ALT CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_4_CRC_CONFIG%3ACRC_ENABLE">CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable in both TX and RX modes,            and enables CRC checksum calculation over this field.             Note:  enabling CRC calculation across a field does not automatically result in transmission/checking of the CRC checksum at the end of the field.</li><li>
If in RX mode and             <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 is set,             this bit is ignored and the CRC_ENABLE functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_4_CRC_CONFIG%3AALT_CRC_ENABLE">ALT_CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable in both TX and RX modes, and enables ALT CRC checksum calculation over this field.             Note:  enabling ALT CRC calculation across a field does not automatically result in transmission/checking of the ALT CRC checksum at the end of the field.            </li><li>
If in RX mode and <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 is set,            this bit is ignored and the ALT_CRC_ENABLE functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable ALT CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable ALT CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_FIELD_5_LENGTH">PKT_FIELD_5_LENGTH</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x1d ... 0x1e</li>
<li>Summary: Unsigned 13-bit Field 5 length value.</li>
<li>Purpose:</li>
<ul><li>
The PKT_FIELD_5_LENGTH properties specify the length of Field 5 in bytes.        The field length is an unsigned 13-bit value.</li><li>
Field 5 may be configured as a variable length field by setting the appropriate value of <a href="#field-PKT_LEN%3ADST_FIELD">PKT_LEN:DST_FIELD</a>
; however, it is also necessary that a previous field contain the variable length byte(s). If configured as a variable length field, this property must be set with a value that represents the maximum expected length of the field.</li><li>
Please refer to the text description for <a href="#prop-PKT_FIELD_1_LENGTH">PKT_FIELD_1_LENGTH</a>
 for more details regarding field length configuration.</li></ul>
<li>Defaults: 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_FIELD_5_LENGTH</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1d</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="5">FIELD_5_LENGTH[12:8]</td>
</tr>
<tr><td>0x1e</td>
<td colspan="8">FIELD_5_LENGTH[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1d</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="5">0x0</td>
</tr>
<tr><td>0x1e</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_FIELD_5_LENGTH">PKT_FIELD_5_LENGTH</a><ul>
<li><a name="field-PKT_FIELD_5_LENGTH%3AFIELD_5_LENGTH">FIELD_5_LENGTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Bits 12 to 0 of the field length.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1fff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_FIELD_5_CONFIG">PKT_FIELD_5_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x1f</li>
<li>Summary: General data processing and packet configuration bits for Field 5.</li>
<li>Purpose:</li>
<ul><li>
Partitioning of the Payload into separate fields is provided to support features such as variable length packets and field-specific data processing        (e.g., Manchester encoding, data whitening, etc).         This property provides configuration bits for field-specific processing on Field 5.       </li><li>
The configuration bits in this property are common to both TX and RX modes dependent on <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
;       however, this property is only applicable when automatic Packet Handling is enabled (e.g.,        when using the TX FIFO as the modulation source in TX mode,       or when <a href="#field-PKT_CONFIG1%3APH_RX_DISABLE">PKT_CONFIG1:PH_RX_DISABLE</a>
 is cleared in RX mode).</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_FIELD_5_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1f</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">4FSK</td>
<td>0</td>
<td>0</td>
<td colspan="1">WHITEN</td>
<td colspan="1">MANCH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1f</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_FIELD_5_CONFIG">PKT_FIELD_5_CONFIG</a><ul>
<li><a name="field-PKT_FIELD_5_CONFIG%3A4FSK">4FSK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip supports field-specific configuration of (G)FSK modulation modes, i.e., 2(G)FSK across certain fields and 4(G)FSK across other fields.  In such a case, the Modem must be configured for 4(G)FSK operation across the entire packet (by setting the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), and the Packet Handler is then configured on a field-by-field basis to process the data stream from the FIFO as bit pairs (for 4(G)FSK) or single bits (for 2(G)FSK).</li><li>
When 4(G)FSK is enabled across a field, the PH pulls two bits from the FIFO and sends them to the TX Modulator to be transmitted as one-of-four deviation levels.</li><li>
When 4(G)FSK is disabled across a field, the PH pulls one bit from the FIFO and replaces it with the appropriate two bits that map to the outer two deviation levels.  Although the TX Modulator remains configured for four levels of deviation (by the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), using only the outer two deviation levels effectively results in 2(G)FSK modulation across that field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_5_CONFIG%3AWHITEN">WHITEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The data whitening/de-whitening function is only available when automatic Packet Handling is enabled (e.g., when using the TX FIFO as the modulation source in TX mode, or when the PH_RX_DISABLE bit in the PKT_CONFIG1 property is cleared in RX mode).</li><li>
In RX mode, the data de-whitening function is performed only on bits stored in the RX FIFO; received data bits observed in real-time (on a GPIO pin) are output prior to de-whitening.</li><li>
Enabling data whitening does not affect the over-the-air data rate.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable data whitening/de-whitening on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable data whitening/de-whitening on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_5_CONFIG%3AMANCH">MANCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Manchester encoding operates by replacing each bit with a two-chip pattern (e.g., each '0' bit with a '10' pattern     and each '1' bit with a '01' bit pattern, or vice versa).     The desired encoding polarity is selected by <a href="#field-PKT_CONFIG1%3AMANCH_POL">PKT_CONFIG1:MANCH_POL</a>
.    </li><li>
Enabling Manchester encoding in one or more fields does not affect the over-the-air data rate;    each bit/chip within the entire packet is transmitted at the same data rate (specified by the MODEM_DATA_RATE_X properties).     Manchester encoding simply affects the number of bits/chips that are sent (e.g., by replacing one bit with two chips).    </li><li>
In RX mode, the Manchester decoding function is performed only on bits stored in the RX FIFO;    received data bits observed in real-time (on a GPIO pin) are output prior to decoding.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable manchester encoding/decoding on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable manchester encoding/decoding on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_FIELD_5_CRC_CONFIG">PKT_FIELD_5_CRC_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x20</li>
<li>Summary: Configuration of CRC control bits across Field 5.</li>
<li>Purpose:</li>
<ul><li>
This property is use to control the calculation, transmission, and checking of CRC across Field 5.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_FIELD_5_CRC_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x20</td>
<td>0</td>
<td>0</td>
<td colspan="1">SEND_CRC</td>
<td colspan="1">SEND_ALT_CRC</td>
<td colspan="1">CHECK_CRC</td>
<td colspan="1">CHECK_ALT_CRC</td>
<td colspan="1">CRC_ENABLE</td>
<td colspan="1">ALT_CRC_ENABLE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x20</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_FIELD_5_CRC_CONFIG">PKT_FIELD_5_CRC_CONFIG</a><ul>
<li><a name="field-PKT_FIELD_5_CRC_CONFIG%3ASEND_CRC">SEND_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in TX mode, and determines whether the accumulated CRC checksum will be transmitted at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not Transmit CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Transmit CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_5_CRC_CONFIG%3ASEND_ALT_CRC">SEND_ALT_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in TX mode, and determines whether the accumulated ALT CRC checksum will be transmitted at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not Transmit ALT CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Transmit ALT CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_5_CRC_CONFIG%3ACHECK_CRC">CHECK_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in RX mode, and determines whether the accumulated CRC checksum will be checked at the end of this field.</li><li>
If the <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 bit is set, this bit is ignored and the CHECK_CRC functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_5_CRC_CONFIG%3ACHECK_ALT_CRC">CHECK_ALT_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable only in RX mode, and determines whether the accumulated ALT CRC checksum will be checked at the end of this field.</li><li>
If the <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 bit is set, this bit is ignored and the CHECK_ALT_CRC functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check ALT CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check ALT CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_5_CRC_CONFIG%3ACRC_ENABLE">CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable in both TX and RX modes,            and enables CRC checksum calculation over this field.             Note:  enabling CRC calculation across a field does not automatically result in transmission/checking of the CRC checksum at the end of the field.</li><li>
If in RX mode and             <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 is set,             this bit is ignored and the CRC_ENABLE functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_FIELD_5_CRC_CONFIG%3AALT_CRC_ENABLE">ALT_CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit is applicable in both TX and RX modes, and enables ALT CRC checksum calculation over this field.             Note:  enabling ALT CRC calculation across a field does not automatically result in transmission/checking of the ALT CRC checksum at the end of the field.            </li><li>
If in RX mode and <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 is set,            this bit is ignored and the ALT_CRC_ENABLE functionality is obtained from the appropriate PKT_RX_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable ALT CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable ALT CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RX_FIELD_1_LENGTH">PKT_RX_FIELD_1_LENGTH</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x21 ... 0x22</li>
<li>Summary: Unsigned 13-bit RX Field 1 length value.</li>
<li>Purpose:</li>
<ul><li>
The PKT_RX_FIELD_1_LENGTH properties specify the length of Field 1 in bytes.          The field length is an unsigned 13-bit value.</li><li>
Partitioning of the Payload into separate fields is provided to support variable length packets,            and to allow different forms of data processing (e.g., Manchester encoding, data whitening, etc)            across different fields.            </li><li>
These properties are applicable in RX mode only under the following conditions: a) RX Packet Handling is enabled by clearing the PH_RX_DISABLE bit in the PKT_CONFIG1 property, and b) The <a href="#cmd-START_RX"><code>START_RX</code></a>
 command is sent with the parameter RX_LEN=0, and c) <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 is set. (If <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 is cleared, the lengths of the various fields in RX mode are determined by the PKT_FIELD_LENGTH_XX properties, shared between TX and RX modes.)            </li><li>
A value of zero in this property means that the field is not used.            During RX mode, data will be stored in the RX FIFO until again encountering the first field whose length has been set to zero.</li><li>
It is possible (although not common) to set the length of Field 1 = 0 bytes, as this would indicate transmission/reception of a packet with no Payload data at all.</li><li>
 Field 1 cannot be configured as a variable length field, as there is no preceding field that may contain the variable length byte(s).</li></ul>
<li>Defaults: 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RX_FIELD_1_LENGTH</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x21</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="5">RX_FIELD_1_LENGTH[12:8]</td>
</tr>
<tr><td>0x22</td>
<td colspan="8">RX_FIELD_1_LENGTH[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x21</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="5">0x0</td>
</tr>
<tr><td>0x22</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RX_FIELD_1_LENGTH">PKT_RX_FIELD_1_LENGTH</a><ul>
<li><a name="field-PKT_RX_FIELD_1_LENGTH%3ARX_FIELD_1_LENGTH">RX_FIELD_1_LENGTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx_field_length</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1fff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RX_FIELD_1_CONFIG">PKT_RX_FIELD_1_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x23</li>
<li>Summary: General data processing and packet configuration bits for RX Field 1.</li>
<li>Purpose:</li>
<ul><li>
Partitioning of the Payload into separate fields is provided to support features such as variable length packets         and field-specific data processing (e.g., Manchester encoding, data whitening, etc).        This property provides configuration bits for field-specific processing on RX Field 1.        </li><li>
This property is not applicable in TX mode.        </li><li>
This property is applicable in RX mode only under the following conditions:        </li><li>
RX Packet Handling is enabled by clearing <a href="#field-PKT_CONFIG1%3APH_RX_DISABLE">PKT_CONFIG1:PH_RX_DISABLE</a>
,         and</li><li>
<a href="#field-PKT_CONFIG1%3APH_FIELD_SPLI">PKT_CONFIG1:PH_FIELD_SPLI</a>
T is set.          If the PH_FIELD_SPLIT bit is cleared, the general packet configuration bits for the various fields in         RX mode are determined by the PKT_FIELD_X_CONFIG properties (shared between TX and RX modes).</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RX_FIELD_1_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x23</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">4FSK</td>
<td>0</td>
<td colspan="1">PN_START</td>
<td colspan="1">WHITEN</td>
<td colspan="1">MANCH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x23</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RX_FIELD_1_CONFIG">PKT_RX_FIELD_1_CONFIG</a><ul>
<li><a name="field-PKT_RX_FIELD_1_CONFIG%3A4FSK">4FSK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip supports field-specific configuration of (G)FSK modulation modes, i.e., 2(G)FSK across certain fields and 4(G)FSK across other fields.  In such a case, the Modem must be configured for 4(G)FSK operation across the entire packet (by setting the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), and the Packet Handler is then configured on a field-by-field basis to process the data stream from the FIFO as bit pairs (for 4(G)FSK) or single bits (for 2(G)FSK).</li><li>
When 4(G)FSK is enabled across a field, the PH pulls two bits from the FIFO and sends them to the TX Modulator to be transmitted as one-of-four deviation levels.</li><li>
When 4(G)FSK is disabled across a field, the PH pulls one bit from the FIFO and replaces it with the appropriate two bits that map to the outer two deviation levels.  Although the TX Modulator remains configured for four levels of deviation (by the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), using only the outer two deviation levels effectively results in 2(G)FSK modulation across that field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_1_CONFIG%3APN_START">PN_START</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip contains a linear feedback shift register (LFSR) for the purpose of generating a pseudo-random number (PN).  Data whitening/de-whitening may be obtained by XOR-ing the output from the resulting PN sequence with the data bits of specified fields.</li><li>
This bit controls whether the PN engine is freshly loaded with its seed value (specified in PKT_WHT_SEED_XX) at the start of this field, or whether the PN engine continues calculation from its last state (i.e., from the previous packet).  Note:  the seed value for the PN engine may only be loaded at the start of Field 1; it is not possible to re-load the seed value at any other place in the packet.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Continue PN generation using last state from previous packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Load PN engine with the seed value at the start of Field 1.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_1_CONFIG%3AWHITEN">WHITEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The data whitening/de-whitening function is only available when automatic Packet Handling is enabled (e.g., when using the TX FIFO as the modulation source in TX mode, or when the PH_RX_DISABLE bit in the PKT_CONFIG1 property is cleared in RX mode).</li><li>
In RX mode, the data de-whitening function is performed only on bits stored in the RX FIFO; received data bits observed in real-time (on a GPIO pin) are output prior to de-whitening.</li><li>
Enabling data whitening does not affect the over-the-air data rate.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable data whitening/de-whitening on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable data whitening/de-whitening on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_1_CONFIG%3AMANCH">MANCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Manchester encoding operates by replacing each bit with a two-chip pattern         (e.g., each '0' bit with a '10' pattern and each '1' bit with a '01' bit pattern, or vice versa).         The desired encoding polarity is selected by <a href="#field-PKT_CONFIG1%3AMANCH_POL">PKT_CONFIG1:MANCH_POL</a>
.        </li><li>
Enabling Manchester encoding in one or more fields does not affect the over-the-air data rate;        each bit/chip within the entire packet is transmitted at the same data rate (specified by the MODEM_DATA_RATE_X properties).         Manchester encoding simply affects the number of bits/chips that are sent (e.g., by replacing one bit with two chips).        </li><li>
In RX mode, the Manchester decoding function is performed only on bits stored in the RX FIFO;        received data bits observed in real-time (on a GPIO pin) are output prior to decoding.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable Manchester decoding on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable Manchester decoding on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RX_FIELD_1_CRC_CONFIG">PKT_RX_FIELD_1_CRC_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x24</li>
<li>Summary: Configuration of CRC control bits across RX Field 1.</li>
<li>Purpose:</li>
<ul><li>
This property is use to control the calculation, transmission, and checking of CRC across RX Field 1.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RX_FIELD_1_CRC_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x24</td>
<td colspan="1">CRC_START</td>
<td colspan="1">ALT_CRC_START</td>
<td>0</td>
<td>0</td>
<td colspan="1">CHECK_CRC</td>
<td colspan="1">CHECK_ALT_CRC</td>
<td colspan="1">CRC_ENABLE</td>
<td colspan="1">ALT_CRC_ENABLE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x24</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RX_FIELD_1_CRC_CONFIG">PKT_RX_FIELD_1_CRC_CONFIG</a><ul>
<li><a name="field-PKT_RX_FIELD_1_CRC_CONFIG%3ACRC_START">CRC_START</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip contains a 32-bit CRC engine that may be configured for a variety of polynomials          and seed values (refer to the <a href="#prop-PKT_CRC_CONFIG">PKT_CRC_CONFIG</a>
 property).          This bit controls whether the CRC engine is freshly loaded with its seed value         (<a href="#field-PKT_CRC_CONFIG%3ACRC_SEED">PKT_CRC_CONFIG:CRC_SEED</a>
) at the start of this field,         or whether the CRC engine continues calculation from its last state          (i.e., from the previous packet).          Note:  the seed value for the CRC engine may only be loaded at the start of Field 1.         It is not possible to re-load the seed value at any other place in the packet.         </li><li>
This bit is only applicable if in RX mode and <a href="#field-PKT_CONFIG1%3APH_FIELD_SPLIT">PKT_CONFIG1:PH_FIELD_SPLIT</a>
 is set.         If the PH_FIELD_SPLIT bit is cleared, this bit is ignored and the CRC_START functionality is obtained from the appropriate PKT_FIELD_X_CRC_CONFIG property.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Continue CRC calculation using the last state from the previous packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Load the CRC engine with the seed value at the start of this field using <a href="#field-PKT_CRC_CONFIG%3ACRC_SEED">PKT_CRC_CONFIG:CRC_SEED</a>
.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_1_CRC_CONFIG%3AALT_CRC_START">ALT_CRC_START</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip contains a 16-bit CRC engine that may be configured for a variety of polynomials and seed values (refer to the <a href="#prop-PKT_CRC_CONFIG">PKT_CRC_CONFIG</a>
 property).          This bit controls whether the CRC engine is freshly loaded with its seed value          (<a href="#field-PKT_CRC_CONFIG%3ACRC_SEED">PKT_CRC_CONFIG:CRC_SEED</a>
) at the start of this field,          or whether the CRC engine continues calculation from its last state          (i.e., from the previous packet).          Note:  the seed value for the ALT CRC engine may only be loaded at the start of Field 1.         It is not possible to re-load the seed value at any other place in the packet.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">CONTINUE</td><td>0</td><td align="left">
<ul><li>
Continue 16-bit CRC calculation using the last state from the previous packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LOAD</td><td>1</td><td align="left">
<ul><li>
Load 16-bit CRC engine with seed value at the start of this field using <a href="#field-PKT_CRC_CONFIG%3ACRC_SEED">PKT_CRC_CONFIG:CRC_SEED</a>
.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_1_CRC_CONFIG%3ACHECK_CRC">CHECK_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This determines whether the accumulated CRC checksum will be checked at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_1_CRC_CONFIG%3ACHECK_ALT_CRC">CHECK_ALT_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit determines whether the accumulated ALT CRC checksum will be checked at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check ALT CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check ALT CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_1_CRC_CONFIG%3ACRC_ENABLE">CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit enables CRC checksum calculation over this field.  Note:  enabling CRC calculation across a field does not automatically result in transmission/checking of the CRC checksum at the end of the field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_1_CRC_CONFIG%3AALT_CRC_ENABLE">ALT_CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit enables ALT CRC checksum calculation over this field.  Note:  enabling ALT CRC calculation across a field does not automatically result in transmission/checking of the ALT CRC checksum at the end of the field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable ALT CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable ALT CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RX_FIELD_2_LENGTH">PKT_RX_FIELD_2_LENGTH</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x25 ... 0x26</li>
<li>Summary: Unsigned 13-bit RX Field 2 length value.</li>
<li>Purpose:</li>
<ul><li>
The PKT_RX_FIELD_2_LENGTH properties specify the length of Field 2 in bytes.          The field length is an unsigned 13-bit value.</li><li>
RX Field 2 may be configured as a variable length field by setting the appropriate value of <a href="#field-PKT_LEN%3ADST_FIELD">PKT_LEN:DST_FIELD</a>
; however, it is also necessary that a previous field contain the variable length byte(s). If configured as a variable length field, this property must be set with a value that represents the maximum expected length of the field.                </li><li>
Please refer to the text description for <a href="#prop-PKT_RX_FIELD_1_LENGTH">PKT_RX_FIELD_1_LENGTH</a>
 for more details regarding field length configuration.</li></ul>
<li>Defaults: 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RX_FIELD_2_LENGTH</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x25</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="5">RX_FIELD_2_LENGTH[12:8]</td>
</tr>
<tr><td>0x26</td>
<td colspan="8">RX_FIELD_2_LENGTH[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x25</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="5">0x0</td>
</tr>
<tr><td>0x26</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RX_FIELD_2_LENGTH">PKT_RX_FIELD_2_LENGTH</a><ul>
<li><a name="field-PKT_RX_FIELD_2_LENGTH%3ARX_FIELD_2_LENGTH">RX_FIELD_2_LENGTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx_field_length</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1fff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RX_FIELD_2_CONFIG">PKT_RX_FIELD_2_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x27</li>
<li>Summary: General data processing and packet configuration bits for RX Field 2.</li>
<li>Purpose:</li>
<ul><li>
Partitioning of the Payload into separate fields is provided to support features such as variable length packets         and field-specific data processing (e.g., Manchester encoding, data whitening, etc).        This property provides configuration bits for field-specific processing on RX Field 2.        </li><li>
This property is not applicable in TX mode.        </li><li>
This property is applicable in RX mode only under the following conditions:        </li><li>
RX Packet Handling is enabled by clearing <a href="#field-PKT_CONFIG1%3APH_RX_DISABLE">PKT_CONFIG1:PH_RX_DISABLE</a>
,         and</li><li>
<a href="#field-PKT_CONFIG1%3APH_FIELD_SPLI">PKT_CONFIG1:PH_FIELD_SPLI</a>
T is set.          If the PH_FIELD_SPLIT bit is cleared, the general packet configuration bits for the various fields in         RX mode are determined by the PKT_FIELD_X_CONFIG properties (shared between TX and RX modes).</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RX_FIELD_2_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x27</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">4FSK</td>
<td>0</td>
<td>0</td>
<td colspan="1">WHITEN</td>
<td colspan="1">MANCH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x27</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RX_FIELD_2_CONFIG">PKT_RX_FIELD_2_CONFIG</a><ul>
<li><a name="field-PKT_RX_FIELD_2_CONFIG%3A4FSK">4FSK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip supports field-specific configuration of (G)FSK modulation modes, i.e., 2(G)FSK across certain fields and 4(G)FSK across other fields.  In such a case, the Modem must be configured for 4(G)FSK operation across the entire packet (by setting the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), and the Packet Handler is then configured on a field-by-field basis to process the data stream from the FIFO as bit pairs (for 4(G)FSK) or single bits (for 2(G)FSK).</li><li>
When 4(G)FSK is enabled across a field, the PH pulls two bits from the FIFO and sends them to the TX Modulator to be transmitted as one-of-four deviation levels.</li><li>
When 4(G)FSK is disabled across a field, the PH pulls one bit from the FIFO and replaces it with the appropriate two bits that map to the outer two deviation levels.  Although the TX Modulator remains configured for four levels of deviation (by the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), using only the outer two deviation levels effectively results in 2(G)FSK modulation across that field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_2_CONFIG%3AWHITEN">WHITEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The data whitening/de-whitening function is only available when automatic Packet Handling is enabled (e.g., when using the TX FIFO as the modulation source in TX mode, or when the PH_RX_DISABLE bit in the PKT_CONFIG1 property is cleared in RX mode).</li><li>
In RX mode, the data de-whitening function is performed only on bits stored in the RX FIFO; received data bits observed in real-time (on a GPIO pin) are output prior to de-whitening.</li><li>
Enabling data whitening does not affect the over-the-air data rate.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable data whitening/de-whitening on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable data whitening/de-whitening on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_2_CONFIG%3AMANCH">MANCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Manchester encoding operates by replacing each bit with a two-chip pattern         (e.g., each '0' bit with a '10' pattern and each '1' bit with a '01' bit pattern, or vice versa).         The desired encoding polarity is selected by <a href="#field-PKT_CONFIG1%3AMANCH_POL">PKT_CONFIG1:MANCH_POL</a>
.        </li><li>
Enabling Manchester encoding in one or more fields does not affect the over-the-air data rate;        each bit/chip within the entire packet is transmitted at the same data rate (specified by the MODEM_DATA_RATE_X properties).         Manchester encoding simply affects the number of bits/chips that are sent (e.g., by replacing one bit with two chips).        </li><li>
In RX mode, the Manchester decoding function is performed only on bits stored in the RX FIFO;        received data bits observed in real-time (on a GPIO pin) are output prior to decoding.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable Manchester decoding on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable Manchester decoding on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RX_FIELD_2_CRC_CONFIG">PKT_RX_FIELD_2_CRC_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x28</li>
<li>Summary: Configuration of CRC control bits across RX Field 2.</li>
<li>Purpose:</li>
<ul><li>
This property is use to control the calculation, transmission, and checking of CRC across RX Field 2.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RX_FIELD_2_CRC_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x28</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CHECK_CRC</td>
<td colspan="1">CHECK_ALT_CRC</td>
<td colspan="1">CRC_ENABLE</td>
<td colspan="1">ALT_CRC_ENABLE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x28</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RX_FIELD_2_CRC_CONFIG">PKT_RX_FIELD_2_CRC_CONFIG</a><ul>
<li><a name="field-PKT_RX_FIELD_2_CRC_CONFIG%3ACHECK_CRC">CHECK_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This determines whether the accumulated CRC checksum will be checked at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_2_CRC_CONFIG%3ACHECK_ALT_CRC">CHECK_ALT_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit determines whether the accumulated ALT CRC checksum will be checked at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check ALT CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check ALT CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_2_CRC_CONFIG%3ACRC_ENABLE">CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit enables CRC checksum calculation over this field.  Note:  enabling CRC calculation across a field does not automatically result in transmission/checking of the CRC checksum at the end of the field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_2_CRC_CONFIG%3AALT_CRC_ENABLE">ALT_CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit enables ALT CRC checksum calculation over this field.  Note:  enabling ALT CRC calculation across a field does not automatically result in transmission/checking of the ALT CRC checksum at the end of the field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable ALT CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable ALT CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RX_FIELD_3_LENGTH">PKT_RX_FIELD_3_LENGTH</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x29 ... 0x2a</li>
<li>Summary: Unsigned 13-bit RX Field 3 length value.</li>
<li>Purpose:</li>
<ul><li>
The PKT_RX_FIELD_3_LENGTH properties specify the length of Field 3 in bytes.          The field length is an unsigned 13-bit value.</li><li>
RX Field 3 may be configured as a variable length field by setting the appropriate value of <a href="#field-PKT_LEN%3ADST_FIELD">PKT_LEN:DST_FIELD</a>
; however, it is also necessary that a previous field contain the variable length byte(s). If configured as a variable length field, this property must be set with a value that represents the maximum expected length of the field.                </li><li>
Please refer to the text description for <a href="#prop-PKT_RX_FIELD_1_LENGTH">PKT_RX_FIELD_1_LENGTH</a>
 for more details regarding field length configuration.</li></ul>
<li>Defaults: 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RX_FIELD_3_LENGTH</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x29</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="5">RX_FIELD_3_LENGTH[12:8]</td>
</tr>
<tr><td>0x2a</td>
<td colspan="8">RX_FIELD_3_LENGTH[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x29</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="5">0x0</td>
</tr>
<tr><td>0x2a</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RX_FIELD_3_LENGTH">PKT_RX_FIELD_3_LENGTH</a><ul>
<li><a name="field-PKT_RX_FIELD_3_LENGTH%3ARX_FIELD_3_LENGTH">RX_FIELD_3_LENGTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx_field_length</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1fff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RX_FIELD_3_CONFIG">PKT_RX_FIELD_3_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x2b</li>
<li>Summary: General data processing and packet configuration bits for RX Field 3.</li>
<li>Purpose:</li>
<ul><li>
Partitioning of the Payload into separate fields is provided to support features such as variable length packets         and field-specific data processing (e.g., Manchester encoding, data whitening, etc).        This property provides configuration bits for field-specific processing on RX Field 3.        </li><li>
This property is not applicable in TX mode.        </li><li>
This property is applicable in RX mode only under the following conditions:        </li><li>
RX Packet Handling is enabled by clearing <a href="#field-PKT_CONFIG1%3APH_RX_DISABLE">PKT_CONFIG1:PH_RX_DISABLE</a>
,         and</li><li>
<a href="#field-PKT_CONFIG1%3APH_FIELD_SPLI">PKT_CONFIG1:PH_FIELD_SPLI</a>
T is set.          If the PH_FIELD_SPLIT bit is cleared, the general packet configuration bits for the various fields in         RX mode are determined by the PKT_FIELD_X_CONFIG properties (shared between TX and RX modes).</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RX_FIELD_3_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2b</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">4FSK</td>
<td>0</td>
<td>0</td>
<td colspan="1">WHITEN</td>
<td colspan="1">MANCH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2b</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RX_FIELD_3_CONFIG">PKT_RX_FIELD_3_CONFIG</a><ul>
<li><a name="field-PKT_RX_FIELD_3_CONFIG%3A4FSK">4FSK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip supports field-specific configuration of (G)FSK modulation modes, i.e., 2(G)FSK across certain fields and 4(G)FSK across other fields.  In such a case, the Modem must be configured for 4(G)FSK operation across the entire packet (by setting the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), and the Packet Handler is then configured on a field-by-field basis to process the data stream from the FIFO as bit pairs (for 4(G)FSK) or single bits (for 2(G)FSK).</li><li>
When 4(G)FSK is enabled across a field, the PH pulls two bits from the FIFO and sends them to the TX Modulator to be transmitted as one-of-four deviation levels.</li><li>
When 4(G)FSK is disabled across a field, the PH pulls one bit from the FIFO and replaces it with the appropriate two bits that map to the outer two deviation levels.  Although the TX Modulator remains configured for four levels of deviation (by the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), using only the outer two deviation levels effectively results in 2(G)FSK modulation across that field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_3_CONFIG%3AWHITEN">WHITEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The data whitening/de-whitening function is only available when automatic Packet Handling is enabled (e.g., when using the TX FIFO as the modulation source in TX mode, or when the PH_RX_DISABLE bit in the PKT_CONFIG1 property is cleared in RX mode).</li><li>
In RX mode, the data de-whitening function is performed only on bits stored in the RX FIFO; received data bits observed in real-time (on a GPIO pin) are output prior to de-whitening.</li><li>
Enabling data whitening does not affect the over-the-air data rate.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable data whitening/de-whitening on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable data whitening/de-whitening on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_3_CONFIG%3AMANCH">MANCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Manchester encoding operates by replacing each bit with a two-chip pattern         (e.g., each '0' bit with a '10' pattern and each '1' bit with a '01' bit pattern, or vice versa).         The desired encoding polarity is selected by <a href="#field-PKT_CONFIG1%3AMANCH_POL">PKT_CONFIG1:MANCH_POL</a>
.        </li><li>
Enabling Manchester encoding in one or more fields does not affect the over-the-air data rate;        each bit/chip within the entire packet is transmitted at the same data rate (specified by the MODEM_DATA_RATE_X properties).         Manchester encoding simply affects the number of bits/chips that are sent (e.g., by replacing one bit with two chips).        </li><li>
In RX mode, the Manchester decoding function is performed only on bits stored in the RX FIFO;        received data bits observed in real-time (on a GPIO pin) are output prior to decoding.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable Manchester decoding on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable Manchester decoding on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RX_FIELD_3_CRC_CONFIG">PKT_RX_FIELD_3_CRC_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x2c</li>
<li>Summary: Configuration of CRC control bits across RX Field 3.</li>
<li>Purpose:</li>
<ul><li>
This property is use to control the calculation, transmission, and checking of CRC across RX Field 3.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RX_FIELD_3_CRC_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2c</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CHECK_CRC</td>
<td colspan="1">CHECK_ALT_CRC</td>
<td colspan="1">CRC_ENABLE</td>
<td colspan="1">ALT_CRC_ENABLE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2c</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RX_FIELD_3_CRC_CONFIG">PKT_RX_FIELD_3_CRC_CONFIG</a><ul>
<li><a name="field-PKT_RX_FIELD_3_CRC_CONFIG%3ACHECK_CRC">CHECK_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This determines whether the accumulated CRC checksum will be checked at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_3_CRC_CONFIG%3ACHECK_ALT_CRC">CHECK_ALT_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit determines whether the accumulated ALT CRC checksum will be checked at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check ALT CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check ALT CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_3_CRC_CONFIG%3ACRC_ENABLE">CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit enables CRC checksum calculation over this field.  Note:  enabling CRC calculation across a field does not automatically result in transmission/checking of the CRC checksum at the end of the field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_3_CRC_CONFIG%3AALT_CRC_ENABLE">ALT_CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit enables ALT CRC checksum calculation over this field.  Note:  enabling ALT CRC calculation across a field does not automatically result in transmission/checking of the ALT CRC checksum at the end of the field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable ALT CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable ALT CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RX_FIELD_4_LENGTH">PKT_RX_FIELD_4_LENGTH</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x2d ... 0x2e</li>
<li>Summary: Unsigned 13-bit RX Field 4 length value.</li>
<li>Purpose:</li>
<ul><li>
The PKT_RX_FIELD_4_LENGTH properties specify the length of Field 4 in bytes.          The field length is an unsigned 13-bit value.</li><li>
RX Field 4 may be configured as a variable length field by setting the appropriate value of <a href="#field-PKT_LEN%3ADST_FIELD">PKT_LEN:DST_FIELD</a>
; however, it is also necessary that a previous field contain the variable length byte(s). If configured as a variable length field, this property must be set with a value that represents the maximum expected length of the field.                </li><li>
Please refer to the text description for <a href="#prop-PKT_RX_FIELD_1_LENGTH">PKT_RX_FIELD_1_LENGTH</a>
 for more details regarding field length configuration.</li></ul>
<li>Defaults: 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RX_FIELD_4_LENGTH</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2d</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="5">RX_FIELD_4_LENGTH[12:8]</td>
</tr>
<tr><td>0x2e</td>
<td colspan="8">RX_FIELD_4_LENGTH[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2d</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="5">0x0</td>
</tr>
<tr><td>0x2e</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RX_FIELD_4_LENGTH">PKT_RX_FIELD_4_LENGTH</a><ul>
<li><a name="field-PKT_RX_FIELD_4_LENGTH%3ARX_FIELD_4_LENGTH">RX_FIELD_4_LENGTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx_field_length</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1fff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RX_FIELD_4_CONFIG">PKT_RX_FIELD_4_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x2f</li>
<li>Summary: General data processing and packet configuration bits for RX Field 4.</li>
<li>Purpose:</li>
<ul><li>
Partitioning of the Payload into separate fields is provided to support features such as variable length packets         and field-specific data processing (e.g., Manchester encoding, data whitening, etc).        This property provides configuration bits for field-specific processing on RX Field 4.        </li><li>
This property is not applicable in TX mode.        </li><li>
This property is applicable in RX mode only under the following conditions:        </li><li>
RX Packet Handling is enabled by clearing <a href="#field-PKT_CONFIG1%3APH_RX_DISABLE">PKT_CONFIG1:PH_RX_DISABLE</a>
,         and</li><li>
<a href="#field-PKT_CONFIG1%3APH_FIELD_SPLI">PKT_CONFIG1:PH_FIELD_SPLI</a>
T is set.          If the PH_FIELD_SPLIT bit is cleared, the general packet configuration bits for the various fields in         RX mode are determined by the PKT_FIELD_X_CONFIG properties (shared between TX and RX modes).</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RX_FIELD_4_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2f</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">4FSK</td>
<td>0</td>
<td>0</td>
<td colspan="1">WHITEN</td>
<td colspan="1">MANCH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2f</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RX_FIELD_4_CONFIG">PKT_RX_FIELD_4_CONFIG</a><ul>
<li><a name="field-PKT_RX_FIELD_4_CONFIG%3A4FSK">4FSK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip supports field-specific configuration of (G)FSK modulation modes, i.e., 2(G)FSK across certain fields and 4(G)FSK across other fields.  In such a case, the Modem must be configured for 4(G)FSK operation across the entire packet (by setting the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), and the Packet Handler is then configured on a field-by-field basis to process the data stream from the FIFO as bit pairs (for 4(G)FSK) or single bits (for 2(G)FSK).</li><li>
When 4(G)FSK is enabled across a field, the PH pulls two bits from the FIFO and sends them to the TX Modulator to be transmitted as one-of-four deviation levels.</li><li>
When 4(G)FSK is disabled across a field, the PH pulls one bit from the FIFO and replaces it with the appropriate two bits that map to the outer two deviation levels.  Although the TX Modulator remains configured for four levels of deviation (by the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), using only the outer two deviation levels effectively results in 2(G)FSK modulation across that field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_4_CONFIG%3AWHITEN">WHITEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The data whitening/de-whitening function is only available when automatic Packet Handling is enabled (e.g., when using the TX FIFO as the modulation source in TX mode, or when the PH_RX_DISABLE bit in the PKT_CONFIG1 property is cleared in RX mode).</li><li>
In RX mode, the data de-whitening function is performed only on bits stored in the RX FIFO; received data bits observed in real-time (on a GPIO pin) are output prior to de-whitening.</li><li>
Enabling data whitening does not affect the over-the-air data rate.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable data whitening/de-whitening on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable data whitening/de-whitening on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_4_CONFIG%3AMANCH">MANCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Manchester encoding operates by replacing each bit with a two-chip pattern         (e.g., each '0' bit with a '10' pattern and each '1' bit with a '01' bit pattern, or vice versa).         The desired encoding polarity is selected by <a href="#field-PKT_CONFIG1%3AMANCH_POL">PKT_CONFIG1:MANCH_POL</a>
.        </li><li>
Enabling Manchester encoding in one or more fields does not affect the over-the-air data rate;        each bit/chip within the entire packet is transmitted at the same data rate (specified by the MODEM_DATA_RATE_X properties).         Manchester encoding simply affects the number of bits/chips that are sent (e.g., by replacing one bit with two chips).        </li><li>
In RX mode, the Manchester decoding function is performed only on bits stored in the RX FIFO;        received data bits observed in real-time (on a GPIO pin) are output prior to decoding.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable Manchester decoding on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable Manchester decoding on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RX_FIELD_4_CRC_CONFIG">PKT_RX_FIELD_4_CRC_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x30</li>
<li>Summary: Configuration of CRC control bits across RX Field 4.</li>
<li>Purpose:</li>
<ul><li>
This property is use to control the calculation, transmission, and checking of CRC across RX Field 4.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RX_FIELD_4_CRC_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x30</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CHECK_CRC</td>
<td colspan="1">CHECK_ALT_CRC</td>
<td colspan="1">CRC_ENABLE</td>
<td colspan="1">ALT_CRC_ENABLE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x30</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RX_FIELD_4_CRC_CONFIG">PKT_RX_FIELD_4_CRC_CONFIG</a><ul>
<li><a name="field-PKT_RX_FIELD_4_CRC_CONFIG%3ACHECK_CRC">CHECK_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This determines whether the accumulated CRC checksum will be checked at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_4_CRC_CONFIG%3ACHECK_ALT_CRC">CHECK_ALT_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit determines whether the accumulated ALT CRC checksum will be checked at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check ALT CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check ALT CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_4_CRC_CONFIG%3ACRC_ENABLE">CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit enables CRC checksum calculation over this field.  Note:  enabling CRC calculation across a field does not automatically result in transmission/checking of the CRC checksum at the end of the field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_4_CRC_CONFIG%3AALT_CRC_ENABLE">ALT_CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit enables ALT CRC checksum calculation over this field.  Note:  enabling ALT CRC calculation across a field does not automatically result in transmission/checking of the ALT CRC checksum at the end of the field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable ALT CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable ALT CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RX_FIELD_5_LENGTH">PKT_RX_FIELD_5_LENGTH</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x31 ... 0x32</li>
<li>Summary: Unsigned 13-bit RX Field 5 length value.</li>
<li>Purpose:</li>
<ul><li>
The PKT_RX_FIELD_5_LENGTH properties specify the length of Field 5 in bytes.          The field length is an unsigned 13-bit value.</li><li>
RX Field 5 may be configured as a variable length field by setting the appropriate value of <a href="#field-PKT_LEN%3ADST_FIELD">PKT_LEN:DST_FIELD</a>
; however, it is also necessary that a previous field contain the variable length byte(s). If configured as a variable length field, this property must be set with a value that represents the maximum expected length of the field.                </li><li>
Please refer to the text description for <a href="#prop-PKT_RX_FIELD_1_LENGTH">PKT_RX_FIELD_1_LENGTH</a>
 for more details regarding field length configuration.</li></ul>
<li>Defaults: 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RX_FIELD_5_LENGTH</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x31</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="5">RX_FIELD_5_LENGTH[12:8]</td>
</tr>
<tr><td>0x32</td>
<td colspan="8">RX_FIELD_5_LENGTH[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x31</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="5">0x0</td>
</tr>
<tr><td>0x32</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RX_FIELD_5_LENGTH">PKT_RX_FIELD_5_LENGTH</a><ul>
<li><a name="field-PKT_RX_FIELD_5_LENGTH%3ARX_FIELD_5_LENGTH">RX_FIELD_5_LENGTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx_field_length</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1fff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RX_FIELD_5_CONFIG">PKT_RX_FIELD_5_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x33</li>
<li>Summary: General data processing and packet configuration bits for RX Field 5.</li>
<li>Purpose:</li>
<ul><li>
Partitioning of the Payload into separate fields is provided to support features such as variable length packets         and field-specific data processing (e.g., Manchester encoding, data whitening, etc).        This property provides configuration bits for field-specific processing on RX Field 5.        </li><li>
This property is not applicable in TX mode.        </li><li>
This property is applicable in RX mode only under the following conditions:        </li><li>
RX Packet Handling is enabled by clearing <a href="#field-PKT_CONFIG1%3APH_RX_DISABLE">PKT_CONFIG1:PH_RX_DISABLE</a>
,         and</li><li>
<a href="#field-PKT_CONFIG1%3APH_FIELD_SPLI">PKT_CONFIG1:PH_FIELD_SPLI</a>
T is set.          If the PH_FIELD_SPLIT bit is cleared, the general packet configuration bits for the various fields in         RX mode are determined by the PKT_FIELD_X_CONFIG properties (shared between TX and RX modes).</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RX_FIELD_5_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x33</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">4FSK</td>
<td>0</td>
<td>0</td>
<td colspan="1">WHITEN</td>
<td colspan="1">MANCH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x33</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RX_FIELD_5_CONFIG">PKT_RX_FIELD_5_CONFIG</a><ul>
<li><a name="field-PKT_RX_FIELD_5_CONFIG%3A4FSK">4FSK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip supports field-specific configuration of (G)FSK modulation modes, i.e., 2(G)FSK across certain fields and 4(G)FSK across other fields.  In such a case, the Modem must be configured for 4(G)FSK operation across the entire packet (by setting the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), and the Packet Handler is then configured on a field-by-field basis to process the data stream from the FIFO as bit pairs (for 4(G)FSK) or single bits (for 2(G)FSK).</li><li>
When 4(G)FSK is enabled across a field, the PH pulls two bits from the FIFO and sends them to the TX Modulator to be transmitted as one-of-four deviation levels.</li><li>
When 4(G)FSK is disabled across a field, the PH pulls one bit from the FIFO and replaces it with the appropriate two bits that map to the outer two deviation levels.  Although the TX Modulator remains configured for four levels of deviation (by the <a href="#prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a>
 property), using only the outer two deviation levels effectively results in 2(G)FSK modulation across that field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable 4(G)FSK data processing on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_5_CONFIG%3AWHITEN">WHITEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The data whitening/de-whitening function is only available when automatic Packet Handling is enabled (e.g., when using the TX FIFO as the modulation source in TX mode, or when the PH_RX_DISABLE bit in the PKT_CONFIG1 property is cleared in RX mode).</li><li>
In RX mode, the data de-whitening function is performed only on bits stored in the RX FIFO; received data bits observed in real-time (on a GPIO pin) are output prior to de-whitening.</li><li>
Enabling data whitening does not affect the over-the-air data rate.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable data whitening/de-whitening on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable data whitening/de-whitening on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_5_CONFIG%3AMANCH">MANCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Manchester encoding operates by replacing each bit with a two-chip pattern         (e.g., each '0' bit with a '10' pattern and each '1' bit with a '01' bit pattern, or vice versa).         The desired encoding polarity is selected by <a href="#field-PKT_CONFIG1%3AMANCH_POL">PKT_CONFIG1:MANCH_POL</a>
.        </li><li>
Enabling Manchester encoding in one or more fields does not affect the over-the-air data rate;        each bit/chip within the entire packet is transmitted at the same data rate (specified by the MODEM_DATA_RATE_X properties).         Manchester encoding simply affects the number of bits/chips that are sent (e.g., by replacing one bit with two chips).        </li><li>
In RX mode, the Manchester decoding function is performed only on bits stored in the RX FIFO;        received data bits observed in real-time (on a GPIO pin) are output prior to decoding.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable Manchester decoding on this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable Manchester decoding on this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RX_FIELD_5_CRC_CONFIG">PKT_RX_FIELD_5_CRC_CONFIG</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x34</li>
<li>Summary: Configuration of CRC control bits across RX Field 5.</li>
<li>Purpose:</li>
<ul><li>
This property is use to control the calculation, transmission, and checking of CRC across RX Field 5.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RX_FIELD_5_CRC_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x34</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CHECK_CRC</td>
<td colspan="1">CHECK_ALT_CRC</td>
<td colspan="1">CRC_ENABLE</td>
<td colspan="1">ALT_CRC_ENABLE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x34</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RX_FIELD_5_CRC_CONFIG">PKT_RX_FIELD_5_CRC_CONFIG</a><ul>
<li><a name="field-PKT_RX_FIELD_5_CRC_CONFIG%3ACHECK_CRC">CHECK_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This determines whether the accumulated CRC checksum will be checked at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_5_CRC_CONFIG%3ACHECK_ALT_CRC">CHECK_ALT_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit determines whether the accumulated ALT CRC checksum will be checked at the end of this field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not check ALT CRC at the end of this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Check ALT CRC at the end of this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_5_CRC_CONFIG%3ACRC_ENABLE">CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit enables CRC checksum calculation over this field.  Note:  enabling CRC calculation across a field does not automatically result in transmission/checking of the CRC checksum at the end of the field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PKT_RX_FIELD_5_CRC_CONFIG%3AALT_CRC_ENABLE">ALT_CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit enables ALT CRC checksum calculation over this field.  Note:  enabling ALT CRC calculation across a field does not automatically result in transmission/checking of the ALT CRC checksum at the end of the field.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable ALT CRC calculation over this field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable ALT CRC calculation over this field.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_RESERVED_53">PKT_RESERVED_53</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x35</li>
<li>Summary: Reserved.</li>
<li>Purpose:</li>
<ul><li>
Reserved.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_RESERVED_53</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x35</td>
<td colspan="8">RESERVED</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x35</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_RESERVED_53">PKT_RESERVED_53</a><ul>
<li><a name="field-PKT_RESERVED_53%3ARESERVED">RESERVED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Reserved.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PKT_CRC_SEED">PKT_CRC_SEED</a></h4>
<ul>
<li>Group: 0x12</li>
<li>Index: 0x36 ... 0x39</li>
<li>Summary: 32-bit seed value for the 32-bit CRC engine</li>
<li>Purpose:</li>
<ul><li>
This property defines the starting seed value for the 32-bit CRC engine.</li><li>
The value in this field is used when <a href="#field-PKT_CRC_CONFIG%3ACRC_SEED">PKT_CRC_CONFIG:CRC_SEED</a>
 is set to zero.</li></ul>
<li>Defaults: 0x00, 0x00, 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PKT_CRC_SEED</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x36</td>
<td colspan="8">CRC_SEED[31:24]</td>
</tr>
<tr><td>0x37</td>
<td colspan="8">CRC_SEED[23:16]</td>
</tr>
<tr><td>0x38</td>
<td colspan="8">CRC_SEED[15:8]</td>
</tr>
<tr><td>0x39</td>
<td colspan="8">CRC_SEED[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x36</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x37</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x38</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x39</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PKT%3APKT_CRC_SEED">PKT_CRC_SEED</a><ul>
<li><a name="field-PKT_CRC_SEED%3ACRC_SEED">CRC_SEED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Defines the 32-bit PN seed value.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U32</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xffffffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-MODEM">MODEM</a></h3>
<h4><a name="prop-MODEM_MOD_TYPE">MODEM_MOD_TYPE</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x00</li>
<li>Summary: Selects the type of modulation.  In TX mode, additionally selects the source of the modulation.</li>
<li>Purpose:</li>
<ul><li>
This property configures the Modem in the chip for transmission/reception of the following modulation types:    OOK, 2(G)FSK, and 4(G)FSK (if supported) modulation.
    </li><li>
In TX mode, this property is additionally used to select the source of the TX data stream,     and whether that TX data stream is from a synchronous or asynchronous source (in Direct mode only).
    </li><li>
The Modem must be configured for transmission/reception of only one type of modulation throughout the entire packet;    it is not possible (for example) to use OOK modulation over certain fields and (G)FSK modulation over other fields.     If 4(G)FSK is supported, it is possible to switch between 2(G)FSK and 4(G)FSK on a field-specific basis;     however, this is accomplished by configuring the Modem to 4(G)FSK mode for the entire packet and then performing special data processing in the Packet Handler.</li></ul>
<li>Defaults: 0x02</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_MOD_TYPE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="1">TX_DIRECT_MODE_TYPE</td>
<td colspan="2">TX_DIRECT_MODE_GPIO</td>
<td colspan="2">MOD_SOURCE</td>
<td colspan="3">MOD_TYPE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="1">0x0</td>
<td colspan="2">0x0</td>
<td colspan="2">0x0</td>
<td colspan="3">0x2</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_MOD_TYPE">MODEM_MOD_TYPE</a><ul>
<li><a name="field-MODEM_MOD_TYPE%3ATX_DIRECT_MODE_TYPE">TX_DIRECT_MODE_TYPE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit determines whether a real-time TX data stream (applied to the chip on a selected GPIO input pin)     is processed in synchronous or asynchronous fashion.     This bit is applicable only in TX mode, and only when the MOD_SOURCE field is also set for TX Direct mode.
    </li><li>
In TX Direct Synchronous mode, the chip controls the transmit data rate by outputting a TX bit clock (GPIO_PIN_CFG=0x10).     The host MCU receives the rising edge of the TX clock and responds by outputting one bit for each clock tick;     the chip clocks in this new data bit on the subsequent falling edge of the TX clock.     All 2-level modulation modes (OOK, 2FSK, 2GFSK) are supported.</li><li>
In TX Direct Asynchronous mode,     the host MCU controls the transmit data rate; the RFIC has no knowledge of the rate of the    incoming TX data stream but simply oversamples the data as fast as possible to determine the bit edge transitions.     OOK and 2FSK are supported, but 2GFSK is not supported in this mode.
    </li><li>
4(G)FSK is not supported in either TX Direct Synchronous or TX Direct Asynchronous modes.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SYNC</td><td>0</td><td align="left">
<ul><li>
Direct mode operates in synchronous mode, applies to TX only.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ASYNC</td><td>1</td><td align="left">
<ul><li>
Direct mode operates in asynchronous mode, applies to TX only.  GFSK is not supported.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_MOD_TYPE%3ATX_DIRECT_MODE_GPIO">TX_DIRECT_MODE_GPIO</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This field determines which GPIO pin is selected by the Modem as the modulation data source during TX Direct mode.     This bit is applicable only in TX mode, and only when the MOD_SOURCE field is also set for TX Direct mode.
    </li><li>
This field does not automatically configure the selected GPIO pin as a digital input pin;     it remains necessary to additionally configure the desired GPIO pin as a CMOS-compatible input pin by setting <a href="#cmd-GPIO_PIN_CFG"><code>GPIO_PIN_CFG</code></a>
=0x04.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">GPIO0</td><td>0</td><td align="left">
<ul><li>
TX direct mode uses GPIO0 as data source.</li></ul>
</td></tr>
<tr valign="top"><td align="left">GPIO1</td><td>1</td><td align="left">
<ul><li>
TX direct mode uses GPIO1 as data source.</li></ul>
</td></tr>
<tr valign="top"><td align="left">GPIO2</td><td>2</td><td align="left">
<ul><li>
TX direct mode uses GPIO2 as data source.</li></ul>
</td></tr>
<tr valign="top"><td align="left">GPIO3</td><td>3</td><td align="left">
<ul><li>
TX direct mode uses GPIO3 as data source.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_MOD_TYPE%3AMOD_SOURCE">MOD_SOURCE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit selects the source of modulation during TX mode.  It is applicable only in TX mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">PACKET</td><td>0</td><td align="left">
<ul><li>
The modulation is sourced from the TX FIFO in the packet handler.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIRECT</td><td>1</td><td align="left">
<ul><li>
The modulation is sourced in real-time (i.e., TX Direct Mode) from a GPIO pin, as selected by the TX_DIRECT_MODE_GPIO field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">PSEUDO</td><td>2</td><td align="left">
<ul><li>
The modulation is sourced from the internal pseudo-random generator.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_MOD_TYPE%3AMOD_TYPE">MOD_TYPE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This field configures the Modem for transmission or reception of the desired type of modulation.
    </li><li>
With the exception of CW mode (a TX-only function), this bit is applicable in both TX and RX modes.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">CW</td><td>0</td><td align="left">
<ul><li>
CW.</li></ul>
</td></tr>
<tr valign="top"><td align="left">OOK</td><td>1</td><td align="left">
<ul><li>
OOK.</li></ul>
</td></tr>
<tr valign="top"><td align="left">2FSK</td><td>2</td><td align="left">
<ul><li>
2FSK.</li></ul>
</td></tr>
<tr valign="top"><td align="left">2GFSK</td><td>3</td><td align="left">
<ul><li>
2GFSK.</li></ul>
</td></tr>
<tr valign="top"><td align="left">4FSK</td><td>4</td><td align="left">
<ul><li>
4FSK.</li></ul>
</td></tr>
<tr valign="top"><td align="left">4GFSK</td><td>5</td><td align="left">
<ul><li>
4GFSK.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_MAP_CONTROL">MODEM_MAP_CONTROL</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x01</li>
<li>Summary: Controls polarity and mapping of transmit and receive bits.</li>
<li>Purpose:</li>
<ul><li>
The chip provides the ability to invert the polarity of the TX and RX data bits.    This flexibility is provided to ensure compatibility of the chip with other legacy systems that may have a different definition of data bit polarity.    </li><li>
The ENMANCH bit signals the chip to adjust the "search for Sync Word" timeout period in the event that the     Sync Word is configured for simultaneous Manchester coding and 4(G)FSK coding.      This configuration is currently not supported and thus the setting of the ENMANCH bit is internally ignored. </li></ul>
<li>Defaults: 0x80</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_MAP_CONTROL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="1">ENMANCH</td>
<td colspan="1">ENINV_RXBIT</td>
<td colspan="1">ENINV_TXBIT</td>
<td colspan="1">ENINV_FD</td>
<td colspan="1">ENINV_ADCQ</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="1">0x1</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_MAP_CONTROL">MODEM_MAP_CONTROL</a><ul>
<li><a name="field-MODEM_MAP_CONTROL%3AENMANCH">ENMANCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
When set, signals the chip adjust the "search for Sync Word" timeout period in the event     that the Sync Word field is simultaneously configured for Manchester coding and 4(G)FSK coding.
    </li><li>
This configuration is currently not supported;     the setting of the ENMANCH bit is internally ignored. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not adjust Sync Word timeout for Manchester coding. </li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Adjust Sync Word timeout for Manchester coding. </li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_MAP_CONTROL%3AENINV_RXBIT">ENINV_RXBIT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enables/disables inversion of the entire RX data bit stream,    occurring at the circuit point just after the Demodulator and prior to any    subsequent decoding (e.g., Manchester decoding or data de-whitening).    </li><li>
The data bits appearing in real-time on a GPIO pin (if selected) will be inverted,    as will the data bytes stored in the RX FIFO. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not invert RX data bits.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Invert RX data bits.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_MAP_CONTROL%3AENINV_TXBIT">ENINV_TXBIT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enables/disables inversion of the entire TX data bit stream, occurring at the circuit point just prior to injection into the Modulator.    The inversion of the data bit stream applies to all three possible sources of TX modulation (FIFO, Direct from GPIO pin, or PN generator).    </li><li>
In OOK mode, this has the obvious effect of changing a TX-ON bit to a TX-OFF bit, and vice versa.    </li><li>
In 2(G)FSK mode, this has the obvious effect of changing a +Fdev bit to a -Fdev bit, and vice versa.      </li><li>
The default setting of this bit (i.e., non-inversion) results in a '1' TX data bit mapping to the +Fdev deviation level.    </li><li>
In 4(G)FSK mode, the resulting effect depends upon the selected symbol mapping;    that is, inverting a pair of TX data bits (that previously mapped to one 4(G)FSK deviation level)     may not result in transmission of the opposite deviation level. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not invert TX data bits.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Invert TX data bits.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_MAP_CONTROL%3AENINV_FD">ENINV_FD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enables/disables inversion of the polarity of frequency deviation in TX 2(G)FSK or 4(G)FSK mode.      This bit has no effect in TX OOK mode or RX mode.
    </li><li>
In 2(G)FSK mode, this bit has the same effect as inverting the TX data bit stream through the ENINV_TXBIT.
    </li><li>
In 4(G)FSK mode, this bit results in inversion of the modulation waveform;    this may differ from inverting the TX data bit stream (through the ENINV_TXBIT),     depending upon the selected symbol mapping. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not invert the polarity of the frequency deviation.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Invert the polarity of the frequency deviation.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_MAP_CONTROL%3AENINV_ADCQ">ENINV_ADCQ</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enables/disables inversion of the Q-channel stream of samples from the RX A/D Converters.
    </li><li>
This functionality is provided for engineering evaluation and diagnostic purposes;    it is not recommended for customer use.     Specifically, this bit does not automatically result in selection of the opposite Mixer     sideband (e.g., high-side injection instead of the normal low-side injection scheme).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not invert ADC Q channel.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Invert ADC Q channel.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_DSM_CTRL">MODEM_DSM_CTRL</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x02</li>
<li>Summary: Miscellaneous control bits for the Delta-Sigma Modulator (DSM) in the PLL Synthesizer.</li>
<li>Purpose:</li>
<ul><li>
This property provides several miscellaneous control bits for DSM functions such as clock source, dithering, and modulator order.     These control bits are primarily intended for engineering diagnostic purposes,     and Silicon Labs does not recommend altering the values suggested by the WDS Calculator     (with the possible exception of the DSM_LSB bit).
    </li><li>
Some DSM Fractional-N PLL Synthesizers may exhibit discrete tones or pattern-related spurs for certain fractional values of the frequency control word.     A common method of breaking up these tones or patterns is to add a noise-like (pseudo-random)     bit sequence to the LSB of the frequency control word; this is known as "dithering".    The chip provides for enabling dithering and selection of two different types of dithering;    however, Silicon Labs has not observed a need to enable this functionality and recommends that dithering remain disabled. </li><li>
The fractional frequency values that commonly give rise to pattern-related spurs in many DSMs are exact powers-of-2 (e.g., 0.5, 0.25, 0.125, etc).     In addition to dithering, another common method of eliminating pattern-related spurs is to simply ensure that the frequency control word is always an odd value,     and thus can never be an exact power-of-2.     The chip provides for internally forcing the LSB of the frequency control word to always be set high,     thus resulting in an odd value (regardless of the frequency control word programmed by the user).     This functionality is controlled by the DSM_LSB bit.     The downside of obtaining only odd values of the frequency control word is that the frequency tuning resolution is effectively degraded by a factor of 2x     (e.g., 57.22 Hz tuning resolution in the 915M band instead of 28.61 Hz tuning resolution).    Silicon Labs is not aware of a need for enabling this functionality as no significant pattern-related spurs have been observed;     however, the WDS Calculator currently suggests setting this bit and absent a need for extremely fine frequency tuning resolution,     Silicon Labs recommends not altering this setting.
</li></ul>
<li>Defaults: 0x07</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_DSM_CTRL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="1">DSMCLK_SEL</td>
<td colspan="1">DSM_MODE</td>
<td colspan="1">DSMDT_EN</td>
<td colspan="1">DSMDTTP</td>
<td colspan="1">DSM_RST</td>
<td colspan="1">DSM_LSB</td>
<td colspan="2">DSM_ORDER</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x1</td>
<td colspan="2">0x3</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_DSM_CTRL">MODEM_DSM_CTRL</a><ul>
<li><a name="field-MODEM_DSM_CTRL%3ADSMCLK_SEL">DSMCLK_SEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the clock source for the DSM.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
DSM clock comes from 30 MHz PLL feedback clock.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
DSM clock comes from 30 MHz crystal clock.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSM_CTRL%3ADSM_MODE">DSM_MODE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the type of DSM used in the PLL Synthesizer.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
MASH 1-1-1 DSM will be selected.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
A single loop DSM will be selected.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSM_CTRL%3ADSMDT_EN">DSMDT_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether dithering is enabled in the DSM.
    </li><li>
When enabled, the type of dithering is controlled by the DSMDTTP bit.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
DSM dithering is disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
DSM dithering is enabled.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSM_CTRL%3ADSMDTTP">DSMDTTP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the type of dithering added to the DSM.     </li><li>
The bits of the pseudo-random dithering sequence may be viewed as +1/0 bits or as +1/-1 bits;     the latter method is DC-balanced while the former method effectively adds  LSB of frequency offset to the frequency control word.     </li><li>
This bit has no effect unless dithering is enabled by setting the DSMDT_EN bit. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
+1/0 is added to DSM input LSB.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
+1/-1 is added to DSM input LSB.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSM_CTRL%3ADSM_RST">DSM_RST</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Provides a method of resetting the DSM.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENABLE</td><td>0</td><td align="left">
<ul><li>
DSM is in operational state (reset is not active).</li></ul>
</td></tr>
<tr valign="top"><td align="left">RESET</td><td>1</td><td align="left">
<ul><li>
DSM will be in reset state until it is clear.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSM_CTRL%3ADSM_LSB">DSM_LSB</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether the LSB of the DSM frequency control word is always forced high, resulting in odd values of the frequency control word.
    </li><li>
If enabled, the effective frequency tuning resolution is degraded.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
The LSB of the DSM input is unaltered</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
The LSB of the DSM input is internally forced high (i.e., the frequency control word is forced to always be an odd value).</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSM_CTRL%3ADSM_ORDER">DSM_ORDER</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the order of the DSM. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
0 order, with 0 output continuously.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
1st order, with no noise shaping.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
2nd order, MASH 1-1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
3rd order, MASH 1-1-1.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_DATA_RATE">MODEM_DATA_RATE</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x03 ... 0x05</li>
<li>Summary: Unsigned 24-bit value used to determine the TX data rate</li>
<li>Purpose:</li>
<ul><li>
The TX data rate is derived from an internal clock signal from the TX Numerically Controlled Oscillator (NCO).    </li><li>
The TX NCO provides a clock signal at a configurable multiple of the final desired TX data rate;     the exact oversampling ratio depends upon the modulation mode (OOK / FSK / GFSK) and selected data rate.
    </li><li>
The value of the <a href="#prop-MODEM_DATA_RATE">MODEM_DATA_RATE</a>
 property works in conjunction with the <a href="#prop-MODEM_TX_NCO_MODE">MODEM_TX_NCO_MODE</a>
 property and TXOSR field to provide the desired data rate.     As a result, the units of the <a href="#prop-MODEM_DATA_RATE">MODEM_DATA_RATE</a>
 property are not fixed.    However, as a general guideline, the value of the <a href="#prop-MODEM_DATA_RATE">MODEM_DATA_RATE</a>
 property will be either 1x, 2x, 4x, 10x, 20x, or 40x the desired data rate (in bits per second).     </li><li>
Please refer to the text description for <a href="#prop-MODEM_TX_NCO_MODE">MODEM_TX_NCO_MODE</a>
 for more details regarding the TX Numerically Controlled Oscillator (NCO),    and the roles of the <a href="#prop-MODEM_TX_NCO_MODE">MODEM_TX_NCO_MODE</a>
 and <a href="#prop-MODEM_DATA_RATE">MODEM_DATA_RATE</a>
 properties in setting the TX data rate.
    </li><li>
The default values of the <a href="#prop-MODEM_DATA_RATE">MODEM_DATA_RATE</a>
 and <a href="#prop-MODEM_TX_NCO_MODE">MODEM_TX_NCO_MODE</a>
 properties result in a data rate of 100 kbps. </li></ul>
<li>Defaults: 0x0f, 0x42, 0x40</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_DATA_RATE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="8">DATA_RATE[23:16]</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">DATA_RATE[15:8]</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">DATA_RATE[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="8">0xf</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">0x42</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">0x40</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_DATA_RATE">MODEM_DATA_RATE</a><ul>
<li><a name="field-MODEM_DATA_RATE%3ADATA_RATE">DATA_RATE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Data rate</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xffffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_TX_NCO_MODE">MODEM_TX_NCO_MODE</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x06 ... 0x09</li>
<li>Summary: TX Gaussian filter oversampling ratio and Byte 3 of unsigned 26-bit TX Numerically Controlled Oscillator (NCO) modulus.</li>
<li>Purpose:</li>
<ul><li>
The chip contains a TX Numerically Controlled Oscillator (NCO) for the purpose of creating an internal clock signal at a configurable multiple of the desired data rate.	</li><li>
For 2GFSK and 4GFSK modes of operation, the oversampling ratio is configured by the TXOSR field and is selectable between 10x, 20x, and 40x.     The oversampled NCO clock signal is used to synthesize the individual deviation steps of the Gaussian filtered modulation waveform,    and thus necessarily must be at a higher multiple of the desired data rate.	</li><li>
For OOK, 2FSK, and 4FSK modes of operation, there is no inherent need to create an oversampled clock;     the only required signal is the TXCLK signal at the desired data rate.      However, it is convenient to use the same NCO clock circuitry and thus the TXCLK data rate signal is obtained by first     generating an NCO clock signal at an oversampling ratio of 10x and then subsequently dividing-by-10.	</li><li>
The NCO is comprised of an accumulator that is clocked by the crystal oscillator frequency (Fxtal),     has a maximum count limit (modulus) equal to the value of the <a href="#prop-MODEM_TX_NCO_MODE">MODEM_TX_NCO_MODE</a>
 property,     and on each clock tick accumulates a value set by the <a href="#prop-MODEM_DATA_RATE">MODEM_DATA_RATE</a>
 property.    Thus the accumulator wraps over its maximum count limit at a rate given by the formula:    <br />[LATEX equation: NCO\_CLK\_FREQ = (\frac{MODEM\_DATA\_RATE \times Fxtal\_Hz}{MODEM\_TX\_NCO\_MODE})]
     The overflow pulses generated by the accumulator are the TX NCO clock signal.	</li><li>
The actual TX data rate (and frequency of the TXCLK signal) is given by the formula:    <br />[LATEX equation: TX\_DATA\_RATE = (\frac{NCO\_CLK\_FREQ}{TXOSR})]
 	</li><li>
In 2GFSK or 4GFSK mode, the TXOSR value may be increased to 20x or 40x (from its nominal value of 10x).      This increase in oversampling rate results in a Gaussian filtered modulation waveform with finer deviation steps,    and thus reduces the modulation sideband artifacts.     The 20x or 40x oversampling rate options are only available at lower data rates;    the WDS Calculator will automatically suggest the highest possible value of TXOSR for the selected data rate.    If an oversampling rate of 20x or 40x is selected, the value entered for the <a href="#prop-MODEM_DATA_RATE">MODEM_DATA_RATE</a>
 property should also be scaled by 2x or 4x (respectively),    in order to maintain the desired TX data rate. 	</li><li>
The value entered for the <a href="#prop-MODEM_TX_NCO_MODE">MODEM_TX_NCO_MODE</a>
 property is recommended to be either Fxtal or Fxtal/10     (e.g., 0x1C9C380 = 30M decimal, or 0x02DC6C0 =3M decimal, assuming the crystal frequency is 30 MHz).      The WDS Calculator will automatically suggest the appropriate value as a function of data rate    (Fxtal for DR > 200kbps, and Fxtal/10 for DR  200kbps).     This provides a different adjustment resolution of the data rate. 	</li><li>
The <a href="#prop-MODEM_TX_NCO_MODE">MODEM_TX_NCO_MODE</a>
 and <a href="#prop-MODEM_DATA_RATE">MODEM_DATA_RATE</a>
 properties affect only the TX data rate,    and have no effect in configuring the data rate in RX mode. 	</li><li>
The default values of the <a href="#prop-MODEM_DATA_RATE">MODEM_DATA_RATE</a>
 and <a href="#prop-MODEM_TX_NCO_MODE">MODEM_TX_NCO_MODE</a>
 properties result in a data rate of 100 kbps.</li></ul>
<li>Defaults: 0x01, 0xc9, 0xc3, 0x80</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_TX_NCO_MODE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x06</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="2">TXOSR</td>
<td colspan="2">NCOMOD[25:24]</td>
</tr>
<tr><td>0x07</td>
<td colspan="8">NCOMOD[23:16]</td>
</tr>
<tr><td>0x08</td>
<td colspan="8">NCOMOD[15:8]</td>
</tr>
<tr><td>0x09</td>
<td colspan="8">NCOMOD[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x06</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="2">0x0</td>
<td colspan="2">0x1</td>
</tr>
<tr><td>0x07</td>
<td colspan="8">0xc9</td>
</tr>
<tr><td>0x08</td>
<td colspan="8">0xc3</td>
</tr>
<tr><td>0x09</td>
<td colspan="8">0x80</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_TX_NCO_MODE">MODEM_TX_NCO_MODE</a><ul>
<li><a name="field-MODEM_TX_NCO_MODE%3ATXOSR">TXOSR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Sets the oversampling ratio of the internal NCO clock signal used to synthesize the Gaussian filtered modulation waveform.     This field is only effective in GFSK mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
TX Gaussian filter oversampling ratio is 10x.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
TX Gaussian filter oversampling ratio is 40x.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
TX Gaussian filter oversampling ratio is 20x.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
Reserved, do not use.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_TX_NCO_MODE%3ANCOMOD">NCOMOD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Sets the modulus (maximum count value) of the accumulator used in the TX NCO clock generation circuitry.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x3ffffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_FREQ_DEV">MODEM_FREQ_DEV</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x0a ... 0x0c</li>
<li>Summary: 17-bit unsigned TX frequency deviation word.</li>
<li>Purpose:</li>
<ul><li>
The TX frequency deviation is specified by an unsigned 17-bit value.     This property defines the frequency deviation value.
    </li><li>
The units of the MODEM_FREQ_DEV property are in increments of the LSB tuning resolution of the PLL Synthesizer,     and are therefore a function of the crystal frequency and output frequency band.     The formula for calculating the value of the MODEM_FREQ_DEV property is given by the following equation:

    <br />[LATEX equation: MODEM\_FREQ\_DEV=\left(\frac{2^{19} \times outdiv \times Desired\_Dev\_Hz}{N_{PRESC} \times freq\_xo}\right)]

    </li><li>
The output divider value OUTDIV is configured as a function of the desired frequency band, and is specified in property <a href="#field-MODEM_CLKGEN_BAND%3ABAND">MODEM_CLKGEN_BAND:BAND</a>
.
    </li><li>
The prescaler divider value NPRESC is configured as a function of the selected synthesizer performance mode and may take on the values NPRESC=2 or NPRESC=4,     as specified in property <a href="#field-MODEM_CLKGEN_BAND%3ASY_SEL">MODEM_CLKGEN_BAND:SY_SEL</a>
.
    </li><li>
For 2(G)FSK mode, the specified value is the peak deviation.  For 4(G)FSK mode (if supported),    the specified value is the inner deviation (i.e., between channel center frequency and the nearest symbol deviation level).
    </li><li>
The MODEM_FREQ_DEV property are only used in TX mode.</li></ul>
<li>Defaults: 0x00, 0x06, 0xd3</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_FREQ_DEV</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0a</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">FREQDEV[16:16]</td>
</tr>
<tr><td>0x0b</td>
<td colspan="8">FREQDEV[15:8]</td>
</tr>
<tr><td>0x0c</td>
<td colspan="8">FREQDEV[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0a</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
</tr>
<tr><td>0x0b</td>
<td colspan="8">0x6</td>
</tr>
<tr><td>0x0c</td>
<td colspan="8">0xd3</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_FREQ_DEV">MODEM_FREQ_DEV</a><ul>
<li><a name="field-MODEM_FREQ_DEV%3AFREQDEV">FREQDEV</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_FREQ_OFFSET">MODEM_FREQ_OFFSET</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x0d ... 0x0e</li>
<li>Summary: Frequency offset adjustment (a 16-bit signed number).</li>
<li>Purpose:</li>
<ul><li>
In TX mode, the MODEM_FREQ_OFFSET value is used to provide an offset to the programmed TX frequency.         This allows fine tuning of the TX frequency to account for the variability of the TX reference frequency (e.g., crystal oscillator frequency error).
    </li><li>
In RX mode when PLL AFC is disabled, the MODEM_FREQ_OFFSET value is used to provide an offset for the programmed RX frequency.         This property has no function in RX mode with PLL AFC enabled.         Specifically, reading this property does NOT return the estimated AFC frequency error in RX mode;        that frequency error value may be obtained from the <a href="#cmd-GET_MODEM_STATUS"><code>GET_MODEM_STATUS</code></a>
 command.
    </li><li>
The frequency offset adjustment is a signed 16-bit value.         This property defines the frequency offset value.
    </li><li>
The units of the MODEM_FREQ_OFFSET property are in increments of the LSB tuning resolution of the PLL Synthesizer,        and are therefore a function of the crystal reference frequency and output frequency band.         The formula for calculating the value of the MODEM_FREQ_OFFSET property is given by the following equation:

        <br />[LATEX equation: MODEM\_FREQ\_OFFSET=\left(\frac{2^{19} \times outdiv \times Desired\_Offset\_Hz}{N_{PRESC} \times freq\_xo}\right)]

    </li><li>
Please refer to the text description for <a href="#prop-FREQ_CONTROL_INTE">FREQ_CONTROL_INTE</a>
 for more details regarding frequency calculation.
        </li><li>
The absolute range of this property expressed in Hz is a function of the crystal reference frequency and output frequency band,             but ranges from +/-937.5 kHz in the 915M band to +/-468.7 kHz in the 450M band, etc.</li></ul>
<li>Defaults: 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_FREQ_OFFSET</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0d</td>
<td colspan="8">FREQOFFSET[15:8]</td>
</tr>
<tr><td>0x0e</td>
<td colspan="8">FREQOFFSET[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0d</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x0e</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_FREQ_OFFSET">MODEM_FREQ_OFFSET</a><ul>
<li><a name="field-MODEM_FREQ_OFFSET%3AFREQOFFSET">FREQOFFSET</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_TX_FILTER_COEFF_8">MODEM_TX_FILTER_COEFF_8</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x0f</li>
<li>Summary: The 8th coefficient of TX spectral shaping filter.</li>
<li>Purpose:</li>
<ul><li>
The chip can apply a spectral shaping filter function (e.g., Gaussian filtering) to the TX data stream.    The filter is implemented as a 17-tap digital FIR filter, and thus internally there are a total of 17 filter coefficients.     However, the values of the tap coefficients are symmetrical: Coeff16=Coeff0, Coeff15=Coeff1, etc.     Thus it is only necessary to store a total of 9 coefficients (Coeff8 thru Coeff0);     the internal circuitry obtains the remaining coefficients through symmetry.
    </li><li>
This property specifies the 8th coefficient of the TX shaping filter.
    </li><li>
The filtering function provided by the default suggested coefficient values is Gaussian filtering with B*T=0.5.     Other filtering functions are possible; please contact Silicon Labs for filter coefficient values.
    </li><li>
The spectral shaping filter function is used only in TX mode, and is not available when using TX Direct Asynchronous mode.</li></ul>
<li>Defaults: 0x67</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_TX_FILTER_COEFF_8</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0f</td>
<td colspan="8">TXCOE8</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0f</td>
<td colspan="8">0x67</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_TX_FILTER_COEFF_8">MODEM_TX_FILTER_COEFF_8</a><ul>
<li><a name="field-MODEM_TX_FILTER_COEFF_8%3ATXCOE8">TXCOE8</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_TX_FILTER_COEFF_7">MODEM_TX_FILTER_COEFF_7</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x10</li>
<li>Summary: The 7th coefficient of TX spectral shaping filter.</li>
<li>Purpose:</li>
<ul><li>
This property specifies the 7th coefficient of the TX shaping filter.
    </li><li>
Please refer to the text description for <a href="#prop-MODEM_TX_FILTER_COEFF_8">MODEM_TX_FILTER_COEFF_8</a>
     for more details regarding TX spectral shaping filtering.</li></ul>
<li>Defaults: 0x60</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_TX_FILTER_COEFF_7</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x10</td>
<td colspan="8">TXCOE7</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x10</td>
<td colspan="8">0x60</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_TX_FILTER_COEFF_7">MODEM_TX_FILTER_COEFF_7</a><ul>
<li><a name="field-MODEM_TX_FILTER_COEFF_7%3ATXCOE7">TXCOE7</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_TX_FILTER_COEFF_6">MODEM_TX_FILTER_COEFF_6</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x11</li>
<li>Summary: The 6th coefficient of TX spectral shaping filter.</li>
<li>Purpose:</li>
<ul><li>
This property specifies the 6th coefficient of the TX shaping filter.
    </li><li>
Please refer to the text description for <a href="#prop-MODEM_TX_FILTER_COEFF_8">MODEM_TX_FILTER_COEFF_8</a>
 for more details regarding TX spectral shaping filtering.</li></ul>
<li>Defaults: 0x4d</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_TX_FILTER_COEFF_6</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x11</td>
<td colspan="8">TXCOE6</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x11</td>
<td colspan="8">0x4d</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_TX_FILTER_COEFF_6">MODEM_TX_FILTER_COEFF_6</a><ul>
<li><a name="field-MODEM_TX_FILTER_COEFF_6%3ATXCOE6">TXCOE6</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_TX_FILTER_COEFF_5">MODEM_TX_FILTER_COEFF_5</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x12</li>
<li>Summary: The 5th coefficient of TX spectral shaping filter.</li>
<li>Purpose:</li>
<ul><li>
This property specifies the 5th coefficient of the TX shaping filter.
    </li><li>
Please refer to the text description for <a href="#prop-MODEM_TX_FILTER_COEFF_8">MODEM_TX_FILTER_COEFF_8</a>
     for more details regarding TX spectral shaping filtering.</li></ul>
<li>Defaults: 0x36</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_TX_FILTER_COEFF_5</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x12</td>
<td colspan="8">TXCOE5</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x12</td>
<td colspan="8">0x36</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_TX_FILTER_COEFF_5">MODEM_TX_FILTER_COEFF_5</a><ul>
<li><a name="field-MODEM_TX_FILTER_COEFF_5%3ATXCOE5">TXCOE5</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_TX_FILTER_COEFF_4">MODEM_TX_FILTER_COEFF_4</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x13</li>
<li>Summary: The 4th coefficient of TX spectral shaping filter.</li>
<li>Purpose:</li>
<ul><li>
This property specifies the 4th coefficient of the TX shaping filter.
    </li><li>
Please refer to the text description for <a href="#prop-MODEM_TX_FILTER_COEFF_8">MODEM_TX_FILTER_COEFF_8</a>
     for more details regarding TX spectral shaping filtering.</li></ul>
<li>Defaults: 0x21</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_TX_FILTER_COEFF_4</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x13</td>
<td colspan="8">TXCOE4</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x13</td>
<td colspan="8">0x21</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_TX_FILTER_COEFF_4">MODEM_TX_FILTER_COEFF_4</a><ul>
<li><a name="field-MODEM_TX_FILTER_COEFF_4%3ATXCOE4">TXCOE4</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_TX_FILTER_COEFF_3">MODEM_TX_FILTER_COEFF_3</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x14</li>
<li>Summary: The 3rd coefficient of TX spectral shaping filter.</li>
<li>Purpose:</li>
<ul><li>
This property specifies the 3rd coefficient of the TX shaping filter.
    </li><li>
Please refer to the text description for <a href="#prop-MODEM_TX_FILTER_COEFF_8">MODEM_TX_FILTER_COEFF_8</a>
         for more details regarding TX spectral shaping filtering.</li></ul>
<li>Defaults: 0x11</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_TX_FILTER_COEFF_3</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x14</td>
<td colspan="8">TXCOE3</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x14</td>
<td colspan="8">0x11</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_TX_FILTER_COEFF_3">MODEM_TX_FILTER_COEFF_3</a><ul>
<li><a name="field-MODEM_TX_FILTER_COEFF_3%3ATXCOE3">TXCOE3</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_TX_FILTER_COEFF_2">MODEM_TX_FILTER_COEFF_2</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x15</li>
<li>Summary: The 2nd coefficient of TX spectral shaping filter.</li>
<li>Purpose:</li>
<ul><li>
This property specifies the 2nd coefficient of the TX shaping filter.
    </li><li>
Please refer to the text description for <a href="#prop-MODEM_TX_FILTER_COEFF_8">MODEM_TX_FILTER_COEFF_8</a>
     for more details regarding TX spectral shaping filtering.</li></ul>
<li>Defaults: 0x08</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_TX_FILTER_COEFF_2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x15</td>
<td colspan="8">TXCOE2</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x15</td>
<td colspan="8">0x8</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_TX_FILTER_COEFF_2">MODEM_TX_FILTER_COEFF_2</a><ul>
<li><a name="field-MODEM_TX_FILTER_COEFF_2%3ATXCOE2">TXCOE2</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_TX_FILTER_COEFF_1">MODEM_TX_FILTER_COEFF_1</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x16</li>
<li>Summary: The 1st coefficient of TX spectral shaping filter.</li>
<li>Purpose:</li>
<ul><li>
This property specifies the 1st coefficient of the TX shaping filter.
    </li><li>
Please refer to the text description for <a href="#prop-MODEM_TX_FILTER_COEFF_8">MODEM_TX_FILTER_COEFF_8</a>
    for more details regarding TX spectral shaping filtering.</li></ul>
<li>Defaults: 0x03</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_TX_FILTER_COEFF_1</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x16</td>
<td colspan="8">TXCOE1</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x16</td>
<td colspan="8">0x3</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_TX_FILTER_COEFF_1">MODEM_TX_FILTER_COEFF_1</a><ul>
<li><a name="field-MODEM_TX_FILTER_COEFF_1%3ATXCOE1">TXCOE1</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_TX_FILTER_COEFF_0">MODEM_TX_FILTER_COEFF_0</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x17</li>
<li>Summary: The 0th coefficient of TX spectral shaping filter.</li>
<li>Purpose:</li>
<ul><li>
This property specifies the 0th coefficient of the TX shaping filter.
    </li><li>
Please refer to the text description for <a href="#prop-MODEM_TX_FILTER_COEFF_8">MODEM_TX_FILTER_COEFF_8</a>
        for more details regarding TX spectral shaping filtering.</li></ul>
<li>Defaults: 0x01</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_TX_FILTER_COEFF_0</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x17</td>
<td colspan="8">TXCOE0</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x17</td>
<td colspan="8">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_TX_FILTER_COEFF_0">MODEM_TX_FILTER_COEFF_0</a><ul>
<li><a name="field-MODEM_TX_FILTER_COEFF_0%3ATXCOE0">TXCOE0</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_TX_RAMP_DELAY">MODEM_TX_RAMP_DELAY</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x18</li>
<li>Summary: TX ramp-down delay setting.</li>
<li>Purpose:</li>
<ul><li>
This property specifies the delay time between transmission of the final symbol    of a 2(G)FSK or 4(G)FSK packet and the start of the ramp-down of the PA output power.     This configurable delay time ensures that all symbols have been fully transmitted before any reduction in output power occurs.
    </li><li>
This property applies only in TX mode, and has no effect when using OOK modulation.
    </li><li>
Units of the delay are in bit/symbol periods.  The WDS Calculator suggests an appropriate delay value as a function of the selected modulation type and data rate.
    </li></ul>
<li>Defaults: 0x01</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_TX_RAMP_DELAY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x18</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="3">RAMP_DLY</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x18</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="3">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_TX_RAMP_DELAY">MODEM_TX_RAMP_DELAY</a><ul>
<li><a name="field-MODEM_TX_RAMP_DELAY%3ARAMP_DLY">RAMP_DLY</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x1</dd></dl>
<dl><dt>Max:</dt><dd>0x7</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_MDM_CTRL">MODEM_MDM_CTRL</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x19</li>
<li>Summary: MDM control.</li>
<li>Purpose:</li>
<ul><li>
Detector selection and PM pattern configuration.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_MDM_CTRL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x19</td>
<td colspan="1">PH_SRC_SEL</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">FIFO_SRC_SEL</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x19</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_MDM_CTRL">MODEM_MDM_CTRL</a><ul>
<li><a name="field-MODEM_MDM_CTRL%3APH_SRC_SEL">PH_SRC_SEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
BCR/Slicer phase source selection.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Input from phase computer output.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Input from detector's output.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_MDM_CTRL%3AFIFO_SRC_SEL">FIFO_SRC_SEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
FIFO source selection.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">PH</td><td>0</td><td align="left">
<ul><li>
FIFO contents come from the packet handler.</li></ul>
</td></tr>
<tr valign="top"><td align="left">PHASE</td><td>1</td><td align="left">
<ul><li>
FIFO contents are phase samples taken on the oversampled bit clock.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_IF_CONTROL">MODEM_IF_CONTROL</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x1a</li>
<li>Summary: Selects Fixed-IF, Scaled-IF, or Zero-IF mode of RX Modem operation.</li>
<li>Purpose:</li>
<ul><li>
</li><li>
The chip normally operates with a fixed IF frequency of Fxtal     / 64 (e.g., 30.0 MHz / 64 = 468.75 kHz).  As a low-side Mixer injection         scheme is used, this places the image response at 2*468.75 kHz = 937.5 kHz      below the desired channel.                                                                                                                                      </li><li>
It is possible to configure the chip to operate with a lower IF             frequency, given by the formula:  Fif = Fxtal / (64 * N).  As this value is     related to the fixed IF frequency by the scale factor 'N', it is referred       to as Scaled-IF mode.                                                                                                                                           </li><li>
The scale factor 'N' (and thus also the resulting scaled IF frequency)      is automatically suggested by the WDS Calculator as a function of the           selected data rate, with lower IF frequencies resulting for lower data          rates.  The scale factor 'N' is always an integer value, and is usually         (but not always) a power of 2 (e.g.,N = 2^M).                                                                                                                   </li><li>
Scaled-IF mode may be useful when it is desired to position the image       response at a frequency other than that normally resulting from the             Fixed-IF mode of operation.                                                                                                                                     </li><li>
It is also possible to configure the chip to operate with zero IF           frequency, with the benefit that image response frequency is eliminated.        However, the RX sensitivity of the chip is somewhat degraded in Zero-IF         mode.  Also, the RFIC currently does not support reception of an OOK            modulated signal in Zero-IF mode.                                                                                                                               </li><li>
The value of the MODEM_IF_FREQ property should set be in accordance         with this property (i.e., to the appropriate value of IF frequency for          Fixed-IF or Scaled-IF mode, or to a value of zero for Zero-IF mode).                                                                                            </li><li>
If the ZEROIF bit is set, the FIXIF bit should be cleared.                  </li></ul>
<li>Defaults: 0x08</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_IF_CONTROL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1a</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">ZEROIF</td>
<td colspan="1">FIXIF</td>
<td>0</td>
<td colspan="2">ETSI_MODE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1a</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x1</td>
<td>0x0</td>
<td colspan="2">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_IF_CONTROL">MODEM_IF_CONTROL</a><ul>
<li><a name="field-MODEM_IF_CONTROL%3AZEROIF">ZEROIF</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NORMAL</td><td>0</td><td align="left">
<ul><li>
Non zero-IF mode (i.e., fixed IF or scalable IF mode).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ZERO</td><td>1</td><td align="left">
<ul><li>
Zero-IF mode.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_IF_CONTROL%3AFIXIF">FIXIF</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SCALED</td><td>0</td><td align="left">
<ul><li>
Scaled-IF mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">FIXED</td><td>1</td><td align="left">
<ul><li>
Fixed-IF mode.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_IF_CONTROL%3AETSI_MODE">ETSI_MODE</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Disables ETSI mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ETSI_868</td><td>1</td><td align="left">
<ul><li>
Enables ETSI mode for the 868 MHz frequency band low phase noise.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ETSI_169</td><td>2</td><td align="left">
<ul><li>
Enables ETSI mode for the 169 MHz frequency band without SAW.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_IF_FREQ">MODEM_IF_FREQ</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x1b ... 0x1d</li>
<li>Summary: the IF frequency setting (an 18-bit signed number).</li>
<li>Purpose:</li>
<ul><li>
	In RX mode, the chip uses a low-side Mixer injection scheme (except when in Zero-IF mode).     The <a href="#prop-FREQ_CONTROL_INTE">FREQ_CONTROL_INTE</a>
 and <a href="#prop-FREQ_CONTROL_FRAC">FREQ_CONTROL_FRAC</a>
 properties define the channel center frequency;    in order to receive on this frequency the chip automatically shifts the RX LO frequency downwards by an amount equal to the IF frequency.
    </li><li>
 The <a href="#prop-MODEM_IF_FREQ">MODEM_IF_FREQ</a>
 property defines the amount by which the RX LO frequency is shifted.
    </li><li>
 This value is a signed 18-bit number.     It is summed with the frequency control word for the PLL Synthesizer, and thus must contain a negative value in order to provide a downwards shift in frequency.
    </li><li>
In Fixed-IF and Scaled-IF mode, the IF frequency is given by the following equation:
    <br />[LATEX equation: IF\_FREQ\_Hz = (\frac{freq\_xo}{64\times{N}})]

    where N=1 for Fixed-IF mode and N=2,3,4... for Scaled-IF mode.      Example:  in Fixed-IF mode with the nominal crystal frequency of 30.0 MHz, the IF frequency is 30 MHz / 64 = 468.75 kHz.      In Scaled-IF mode, the scale factor 'N' is always an integer value and is usually (but not always) a power of 2 (e.g., N = 2<sup>M</sup>).
    </li><li>
In Zero-IF mode, the <a href="#prop-MODEM_IF_FREQ">MODEM_IF_FREQ</a>
 should be set = 0x00000.
    </li><li>
The units of the <a href="#prop-MODEM_IF_FREQ">MODEM_IF_FREQ</a>
 property are in increments of the LSB tuning resolution of the PLL Synthesizer,     and are therefore a function of the crystal reference frequency and output frequency band.    The formula for calculating the positive representation of the <a href="#prop-MODEM_IF_FREQ">MODEM_IF_FREQ</a>
 property is given by the following equation:
    <br />[LATEX equation: MODEM\_IF\_FREQ = (\frac{2^{19}\times{outdiv}\times{IF\_FREQ\_HZ}}{Npresc\times{freq\_xo}})]

    </li><li>
The output divider value OUTDIV is configured as a function of the desired frequency band, and is specified in property <a href="#field-MODEM_CLKGEN_BAND%3ABAND">MODEM_CLKGEN_BAND:BAND</a>
.
    </li><li>
The prescaler divider value NPRESC is configured as a function of the selected synthesizer performance mode and may take on the values NPRESC=2 or NPRESC=4, as specified in property <a href="#field-MODEM_CLKGEN_BAND%3ASY_SEL">MODEM_CLKGEN_BAND:SY_SEL</a>
.
    </li><li>
Example:  for the nominal Fixed-IF mode IF frequency of 468.75kHz when operating in the 915 MHz band (OUTDIV=4) with a 30 MHz crystal, the calculated positive representation of MODEM_IF_FREQ = 16384 = 0x4000.
    </li><li>
The appropriate value to program into the <a href="#prop-MODEM_IF_FREQ">MODEM_IF_FREQ</a>
 property is the complement of the calculated positive representation, e.g., 0x3C000.</li></ul>
<li>Defaults: 0x03, 0xc0, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_IF_FREQ</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1b</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="2">IF_FREQ[17:16]</td>
</tr>
<tr><td>0x1c</td>
<td colspan="8">IF_FREQ[15:8]</td>
</tr>
<tr><td>0x1d</td>
<td colspan="8">IF_FREQ[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1b</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="2">0x3</td>
</tr>
<tr><td>0x1c</td>
<td colspan="8">0xc0</td>
</tr>
<tr><td>0x1d</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_IF_FREQ">MODEM_IF_FREQ</a><ul>
<li><a name="field-MODEM_IF_FREQ%3AIF_FREQ">IF_FREQ</a>
<dl><dt>Description:</dt><dd>
<ul><li>
18-bit IF frequency.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_DECIMATION_CFG1">MODEM_DECIMATION_CFG1</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x1e</li>
<li>Summary: Specifies three decimator ratios for the Cascaded Integrator Comb (CIC) filter.</li>
<li>Purpose:</li>
<ul><li>
The RX channel selection bandpass filtering is provided by a digital filter within the RX Modem circuit block.     The filter bandwidth is a function of the filter tap coefficients and the clock or sample rate of the filter.     That is, using the same set of filter tap coefficients with different filter clock rates will result in different filter bandwidths.
    </li><li>
The high-speed I/Q data samples from the RX A/D Converters are decimated by a programmable ratio in order to provide the desired sample rate at the input of the digital filter.     The decimation ratio is determined by the NDEC0, NDEC1, and NDEC2 values in this property,     and thus these values (in conjunction with the filter tap coefficients specified in MODEM_CHFLT_RX1_CHFLT_COEXX)     determine the RX channel selection filter bandwidth.
    </li><li>
The decimation ratio of each decimator circuit block is 2<sup>NDEC</sup>.     In (G)FSK mode the RX data samples pass through two cascaded decimator blocks, and thus the decimation ratio is 2<sup>(NDEC1+NDEC2)</sup>.     In OOK mode, the post-demodulated RX data samples pass through an additional decimator block with decimation ratio 2<sup>NDEC0</sup>.     If not in OOK mode, this decimation coefficient should be set NDEC0 = 0.
    </li><li>
There is an additional polyphase filter and decimator circuit block, located prior to the decimators controlled by the NDEC0/1/2 coefficients.     The decimation ratio of this "pre-decimator" block is controlled by bits within the MODEM_DECIMATION_CFG0 property.     The total decimation ratio is the product of the ratios of the individual circuit blocks.
</li></ul>
<li>Defaults: 0x10</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_DECIMATION_CFG1</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1e</td>
<td colspan="2">NDEC2</td>
<td colspan="2">NDEC1</td>
<td colspan="3">NDEC0</td>
<td>0</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1e</td>
<td colspan="2">0x0</td>
<td colspan="2">0x1</td>
<td colspan="3">0x0</td>
<td>0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_DECIMATION_CFG1">MODEM_DECIMATION_CFG1</a><ul>
<li><a name="field-MODEM_DECIMATION_CFG1%3ANDEC2">NDEC2</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Decimation coefficient for the second of two cascaded decimation circuit blocks in the CIC filter.
    </li><li>
Decimating rate is 2<sup>NDEC2</sup>. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Decimate by 1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Decimate by 2.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
Decimate by 4.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
Decimate by 8.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DECIMATION_CFG1%3ANDEC1">NDEC1</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Decimation coefficient for the first of two cascading decimation circuit blocks in the CIC filter.
    </li><li>
Decimating rate is 2<sup>NDEC1</sup>.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Decimate by 1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Decimate by 2.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
Decimate by 4.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
Decimate by 8.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DECIMATION_CFG1%3ANDEC0">NDEC0</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Decimation coefficient for the additional decimation circuit block used in the RX Modem during OOK reception.
</li><li>
Decimating rate is 2<sup>NDEC0</sup>.
</li><li>
NDEC0 should be set to 0 when not in OOK mode.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Decimate by 1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Decimate by 2.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
Decimate by 4.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
Decimate by 8.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_4</td><td>4</td><td align="left">
<ul><li>
Decimate by 16.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_5</td><td>5</td><td align="left">
<ul><li>
Decimate by 32.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_6</td><td>6</td><td align="left">
<ul><li>
Decimate by 64.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_7</td><td>7</td><td align="left">
<ul><li>
Decimate by 128.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_DECIMATION_CFG0">MODEM_DECIMATION_CFG0</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x1f</li>
<li>Summary: Specifies miscellaneous parameters and decimator ratios for the Cascaded Integrator Comb (CIC) filter.</li>
<li>Purpose:</li>
<ul><li>
The RX channel selection bandpass filter is a digital filter that is nominally 27 taps in length.     By setting the CHFLT_LOPW bit, it is possible to configure the filter with only 15 taps;     the advantage of the 15-tap filter is a reduction in current consumption and filter processing delay at the expense of reduced filtering performance     (e.g., adjacent channel selectivity).     The reduction in current consumption depends upon the selected data rate, but is typically ~100 to 200 uA.
</li><li>
As the channel selection bandpass filter is a digital filter,    it inherently has a SIN(X)/X response which introduces some slope in amplitude across the passband.     The effect is negligible for low bandwidth filters; for higher bandwidth filters the amplitude slope across the passband can approach 1 dB.     The chip has a droop compensation filter that provides an inverse SIN(X)/X response;     when enabled (by clearing the DROOPFLTBYP bit), this compensation filter effectively flattens the amplitude response across the passband.     This bit is cleared by default (compensation filter is enabled), and Silicon Labs does not recommend altering this configuration.
    </li><li>
The RFIC provides a configurable polyphase filter that is located prior to the decimation circuit blocks and CIC digital filter.     This "pre-decimation" filter may be configured (by the DWN3BYP and DWN2BYP) bits to select an additional decimation factor of 2 or 3     (in addition to the decimation factor selected by the NDEC0/1/2 coefficients in the MODEM_DECIMATION_CFG1 property).     If no additional decimation factor is desired, both the decimate-by-2 and decimate-by-3 circuits may be bypassed by setting both the DWN2BYP and DWN3BYP bits.
    </li><li>
At very low data rates, the sensitivity may be improved by increasing the digital gain of the RX Modem.     Setting the RXGAINX2 bit accomplishes this by doubling the gain of the fixed decimate-by-8 stage that immediately follows the RX A/D Converters.     The WDS Calculator automatically suggests setting this bit when working with data rates below 1 kbps.
</li></ul>
<li>Defaults: 0x20</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_DECIMATION_CFG0</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1f</td>
<td colspan="1">CHFLT_LOPW</td>
<td colspan="1">DROOPFLTBYP</td>
<td colspan="1">DWN3BYP</td>
<td colspan="1">DWN2BYP</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">RXGAINX2</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1f</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x1</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_DECIMATION_CFG0">MODEM_DECIMATION_CFG0</a><ul>
<li><a name="field-MODEM_DECIMATION_CFG0%3ACHFLT_LOPW">CHFLT_LOPW</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the operating mode of the channel selection filter (normal mode, or low-power mode with reduced performance).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Normal mode (27 tap filter)</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Low power mode with reduced performance (15 tap filter)</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DECIMATION_CFG0%3ADROOPFLTBYP">DROOPFLTBYP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enables or bypasses the droop compensation filter. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Enables the droop compensation filter.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Bypass the droop compensation filter.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DECIMATION_CFG0%3ADWN3BYP">DWN3BYP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects or bypasses the decimate-by-3 polyphase filter (located prior to the normal decimation stages and CIC filter).
</li><li>
The DWN3BYP and DWN2BYP bits may be simultaneously set (both filters bypassed), but the bits should not be simultaneously cleared.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Enables the decimate-by-3 polyphase filter</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Bypass the decimate-by-3 polyphase filter.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DECIMATION_CFG0%3ADWN2BYP">DWN2BYP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects or bypasses the decimate-by-2 polyphase filter (located prior to the normal decimation stages and CIC filter).
</li><li>
The DWN3BYP and DWN2BYP bits may be simultaneously set (both filters bypassed), but the bits should not be simultaneously cleared. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Select the decimate-by-2 polyphase filter.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Bypass the decimate-by-2 polyphase filter.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DECIMATION_CFG0%3ARXGAINX2">RXGAINX2</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Doubles the gain of the fixed decimate-by-8 filter stage (following the RX A/D Converters) for the purpose of improving sensitivity at low data rates. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Normal decimate-by-8 filter gain.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Doubel the decimate-by-8 filter gain</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_RESERVED_20_20">MODEM_RESERVED_20_20</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x20</li>
<li>Summary: Reserved.</li>
<li>Purpose:</li>
<ul><li>
Reserved.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_RESERVED_20_20</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x20</td>
<td colspan="8">RESERVED_20_20</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x20</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_RESERVED_20_20">MODEM_RESERVED_20_20</a><ul>
<li><a name="field-MODEM_RESERVED_20_20%3ARESERVED_20_20">RESERVED_20_20</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reserved_20_20</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_RESERVED_20_21">MODEM_RESERVED_20_21</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x21</li>
<li>Summary: Reserved.</li>
<li>Purpose:</li>
<ul><li>
Reserved.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_RESERVED_20_21</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x21</td>
<td colspan="8">RESERVED_20_21</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x21</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_RESERVED_20_21">MODEM_RESERVED_20_21</a><ul>
<li><a name="field-MODEM_RESERVED_20_21%3ARESERVED_20_21">RESERVED_20_21</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reserved_20_21</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_BCR_OSR">MODEM_BCR_OSR</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x22 ... 0x23</li>
<li>Summary: RX BCR/Slicer oversampling rate (12-bit unsigned number).</li>
<li>Purpose:</li>
<ul><li>
The RX Modem in the chip contains a Numerically Controlled Oscillator (NCO) for the purpose of synchronizing a local bit clock to the received data stream.      The timing of this NCO is maintained by a feedback loop called the Bit Clock Recovery (BCR) loop.    </li><li>
The BCR loop is sampled at a rate higher than the RX data rate.    The ratio between the sampling rate and the RX data rate is called the BCR oversampling rate (OSR),    with typical values of OSR = 8 to 12.     The desired value of OSR is calculated as a function of the channel filter bandwidth and RX data rate,     and reflects a compromise between low clock jitter (high sample rate)    and lower current consumption and improved adjacent channel filter attenuation (low sample rate).     </li><li>
The BCR loop sampling clock is derived from the crystal oscillator through a series of decimations,    and thus the sampling rate is controlled by the NDEC2, NDEC1, NDEC0, DWN3BYP, and DWN2BYP bits in the <a href="#prop-MODEM_DECIMATION_CFG">MODEM_DECIMATION_CFG</a>
 properties.    In (G)FSK mode, the channel filter and BCR loop use the same sampling clock rate;     in OOK mode, the BCR loop uses a lower sampling clock rate by additionally configuring the NDEC0 parameter.    </li><li>
The 12-bit value programmed into the <a href="#prop-MODEM_BCR_OSR">MODEM_BCR_OSR</a>
 properties represents the target value of OSR multiplied by 8x     (alternatively, the 12-bit value may be viewed as a 9-bit integer portion and 3-bit fractional portion).     Example:  for a target value of OSR = 11.75, the value of <a href="#prop-MODEM_BCR_OSR">MODEM_BCR_OSR</a>
 = 0x5E.    </li><li>
This property defines the RX BCR/Slicer oversampling rate. </li></ul>
<li>Defaults: 0x00, 0x4b</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_BCR_OSR</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x22</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="4">RXOSR[11:8]</td>
</tr>
<tr><td>0x23</td>
<td colspan="8">RXOSR[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x22</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="4">0x0</td>
</tr>
<tr><td>0x23</td>
<td colspan="8">0x4b</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_BCR_OSR">MODEM_BCR_OSR</a><ul>
<li><a name="field-MODEM_BCR_OSR%3ARXOSR">RXOSR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
RX symbol oversampling rate at the BCR/Slicer.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_BCR_NCO_OFFSET">MODEM_BCR_NCO_OFFSET</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x24 ... 0x26</li>
<li>Summary: RX BCR NCO offset value (an unsigned 22-bit number).</li>
<li>Purpose:</li>
<ul><li>
The RX Modem in the chip contains a Numerically Controlled Oscillator (NCO) for the purpose of synchronizing a local bit clock to the received data stream.     The timing of this NCO is maintained by a feedback loop called the Bit Clock Recovery (BCR) loop.    </li><li>
The NCO operates by accumulating a programmed offset value on each tick of the BCR oversampling clock signal     (see <a href="#prop-MODEM_BCR_OSR">MODEM_BCR_OSR</a>
 for more details of the BCR/Slicer oversampling clock).     The rate at which the accumulator overflows is therefore a function of the word-width of the accumulator,    the programmed offset value, and the BCR oversampling clock rate.    </li><li>
The NCO accumulator generates a pulse each time it overflows;     the programmed offset value is selected such that the rate of pulses produced by the accumulator equals the desired RX data rate.    </li><li>
The 22-bit value programmed into the <a href="#prop-MODEM_BCR_NCO_OFFSET">MODEM_BCR_NCO_OFFSET</a>
 property represents the target offset value multiplied by 64x     (alternatively, the 22-bit value may be viewed as a 16-bit integer portion and 6-bit fractional portion).     Example:  for a target offset value of OFFSET = 5592.40625, the value of <a href="#prop-MODEM_BCR_NCO_OFFSET">MODEM_BCR_NCO_OFFSET</a>
 = 0x05761A.</li></ul>
<li>Defaults: 0x06, 0xd3, 0xa0</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_BCR_NCO_OFFSET</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x24</td>
<td>0</td>
<td>0</td>
<td colspan="6">NCOFF[21:16]</td>
</tr>
<tr><td>0x25</td>
<td colspan="8">NCOFF[15:8]</td>
</tr>
<tr><td>0x26</td>
<td colspan="8">NCOFF[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x24</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="6">0x6</td>
</tr>
<tr><td>0x25</td>
<td colspan="8">0xd3</td>
</tr>
<tr><td>0x26</td>
<td colspan="8">0xa0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_BCR_NCO_OFFSET">MODEM_BCR_NCO_OFFSET</a><ul>
<li><a name="field-MODEM_BCR_NCO_OFFSET%3ANCOFF">NCOFF</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The RX BCR NCO offset value.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_BCR_GAIN">MODEM_BCR_GAIN</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x27 ... 0x28</li>
<li>Summary: The unsigned 11-bit RX BCR loop gain value.</li>
<li>Purpose:</li>
<ul><li>
The RX Modem in the chip contains a Numerically Controlled Oscillator (NCO) for the purpose of synchronizing a local bit clock to the received data stream.     The timing of this NCO is maintained by a feedback loop called the Bit Clock Recovery (BCR) loop.      (Please refer to the text description for <a href="#prop-MODEM_BCR_NCO_OFFSET">MODEM_BCR_NCO_OFFSET</a>
 for more details regarding the BCR NCO.)    </li><li>
The BCR NCO provides a local clock signal that is at the desired data rate;    however, a method of synchronizing the phase of the local clock signal to that of the received data stream is also required.     This phase alignment is accomplished by measuring the phase difference between the local bit clock and the received data stream,    and adjusting the phase of the bit clock by means of a feedback loop.
    </li><li>
This property adjusts the gain of the BCR feedback loop.    A large value of gain results in fast acquisition of timing but increased clock jitter,    while a low value of gain provides lower clock jitter but slower timing acquisition.
    </li><li>
The chip provides for switching the loop gain (i.e., "gear shifting") at a configurable point during the packet.     This allows the chip to initially use a high loop gain value (resulting in fast acquisition of timing during reception of the Preamble),    followed by a lower loop gain value (resulting in low clock jitter during reception of the Payload).
    </li><li>
The clock recovery gain in <a href="#prop-MODEM_BCR_GAIN">MODEM_BCR_GAIN</a>
 is an unsigned 11-bit value that serves as a common "baseline" gain value;    it is further scaled by individually selectable scale factors to determine the effective loop gain values to be used prior to and after gear shifting.     These scale factors are specified by <a href="#field-MODEM_BCR_GEAR%3ACRFAST">MODEM_BCR_GEAR:CRFAST</a>
 and <a href="#field-MODEM_BCR_GEAR%3ACRSLOW">MODEM_BCR_GEAR:CRSLOW</a>
. </li></ul>
<li>Defaults: 0x06, 0xd3</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_BCR_GAIN</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x27</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="3">CRGAIN[10:8]</td>
</tr>
<tr><td>0x28</td>
<td colspan="8">CRGAIN[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x27</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="3">0x6</td>
</tr>
<tr><td>0x28</td>
<td colspan="8">0xd3</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_BCR_GAIN">MODEM_BCR_GAIN</a><ul>
<li><a name="field-MODEM_BCR_GAIN%3ACRGAIN">CRGAIN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The clock recovery timing loop gain.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_BCR_GEAR">MODEM_BCR_GEAR</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x29</li>
<li>Summary: RX BCR loop gear control.</li>
<li>Purpose:</li>
<ul><li>
RX BCR loop gear control.</li><li>
A reduced value of bit clock recovery gain is often desired after gear shifting (to reduce clock jitter).     The BCR loop gain in both gear modes is obtained from a baseline clock recovery gain value (crgain in the MODEM_BCR_GAIN_x properties),    scaled by the crfast and crslow values specified in this property.     NOTE:  larger values of crfast or crslow result in lower values of bit clock recovery gain.</li></ul>
<li>Defaults: 0x02</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_BCR_GEAR</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x29</td>
<td>0</td>
<td>0</td>
<td colspan="3">CRFAST</td>
<td colspan="3">CRSLOW</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x29</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="3">0x0</td>
<td colspan="3">0x2</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_BCR_GEAR">MODEM_BCR_GEAR</a><ul>
<li><a name="field-MODEM_BCR_GEAR%3ACRFAST">CRFAST</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The fast timing gain applies before gear switching occurs.  The effective BCR loop gain is calculated as: crgain/(2^crfast).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_BCR_GEAR%3ACRSLOW">CRSLOW</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The slow timing gain applies after gear switching occurs. The effective BCR loop gain is calculated as: crgain/(2^crslow).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_BCR_MISC1">MODEM_BCR_MISC1</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x2a</li>
<li>Summary: Miscellaneous control bits for the RX BCR loop.</li>
<li>Purpose:</li>
<ul><li>
This property configures miscellaneous options within the RX BCR loop.</li></ul>
<li>Defaults: 0xc0</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_BCR_MISC1</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2a</td>
<td colspan="1">BCRFBBYP</td>
<td colspan="1">SLICEFBBYP</td>
<td>0</td>
<td colspan="1">RXNCOCOMP</td>
<td colspan="1">RXCOMP_LAT</td>
<td colspan="1">CRGAINX2</td>
<td colspan="1">DIS_MIDPT</td>
<td colspan="1">ESC_MIDPT</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2a</td>
<td colspan="1">0x1</td>
<td colspan="1">0x1</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_BCR_MISC1">MODEM_BCR_MISC1</a><ul>
<li><a name="field-MODEM_BCR_MISC1%3ABCRFBBYP">BCRFBBYP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The frequency of the down-converted signal in the IF may not be perfectly centered in the IF (e.g. PLL-based AFC correction is disabled or settles with some small residual frequency error).    </li><li>
If left uncompensated, this residual frequency error may degrade the ability of the BCR and Slicer to track and slice the data bits (respectively).    </li><li>
In normal operation, the measured residual frequency error is provided as feedback to the BCR and Slicer to compensate their performance.    </li><li>
This bit disables the feedback term to the BCR tracking loop.  This is normally used only for diagnostics purposes or during reception of special test signals (e.g., BER tests).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENABLED</td><td>0</td><td align="left">
<ul><li>
Feedback of the compensation term to the BCR tracking loop is enabled (normal operation). </li></ul>
</td></tr>
<tr valign="top"><td align="left">DISABLED</td><td>1</td><td align="left">
<ul><li>
Feedback of the compensation term to the BCR tracking loop is bypassed (disabled).</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_BCR_MISC1%3ASLICEFBBYP">SLICEFBBYP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Please refer to the text description for <a href="#field-MODEM_BCR_MISC1%3ABCRFBBYP">MODEM_BCR_MISC1:BCRFBBYP</a>
 for further details regarding this functionality.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENABLED</td><td>0</td><td align="left">
<ul><li>
Feedback of the compensation term to the slicer is enabled (normal operation). </li></ul>
</td></tr>
<tr valign="top"><td align="left">DISABLED</td><td>1</td><td align="left">
<ul><li>
Feedback of the compensation term to the slicer is bypassed (disabled).</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_BCR_MISC1%3ARXNCOCOMP">RXNCOCOMP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The RX Modem in the chip contains a Numerically Controlled Oscillator (NCO) for the purpose of synchronizing a local bit clock to the received data stream.  (Please refer to the text description for <a href="#prop-MODEM_BCR_NCO_OFFSET">MODEM_BCR_NCO_OFFSET</a>
 for more details regarding the BCR NCO.)    </li><li>
The free-running frequency of the NCO is normally set to a fixed value (appropriate for the selected data rate) and used throughout the entire packet.
    </li><li>
In the event of receiving a packet with a large error in the data rate, the BCR loop may not be able to maintain tracking without first obtaining a more accurate estimate of the actual received data rate.
    </li><li>
This bit allows the chip to compensate for data rate error by acquiring a new estimate for the NCO frequency from the received data itself.  This new NCO frequency estimate is obtained during the Preamble field, and then used for the remainder of the packet.
    </li><li>
This compensation is typically needed only when the data rate error is greater than 1%.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Compensation of the BCR NCO frequency is disabled (normal operation).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Compensation of the BCR NCO frequency is enabled.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_BCR_MISC1%3ARXCOMP_LAT">RXCOMP_LAT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit determines the location in the packet at which the new estimation of BCR NCO frequency is taken.    </li><li>
This bit has no effect if RXNCOCOMP is not also set; please refer to the text description for RXNCOCOMP for further details.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SAMP_PREAMBLE_END</td><td>0</td><td align="left">
<ul><li>
BCR NCO compensation is sampled upon detection of the end of the Preamble (i.e., boundary between Preamble and Sync Word).</li></ul>
</td></tr>
<tr valign="top"><td align="left">SAMP_PREAMBLE_VALID</td><td>1</td><td align="left">
<ul><li>
BCR NCO compensation is sampled upon detection of PREAMBLE_VALID.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_BCR_MISC1%3ACRGAINX2">CRGAINX2</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether the BCR loop gain will be increased by a factor of 2x.    </li><li>
This gain increase applies to all modes of operation (i.e., both high-gear and low-gear modes).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NORMAL</td><td>0</td><td align="left">
<ul><li>
BCR loop gain is not doubled (normal operation).</li></ul>
</td></tr>
<tr valign="top"><td align="left">DOUBLED</td><td>1</td><td align="left">
<ul><li>
BCR loop gain is doubled.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_BCR_MISC1%3ADIS_MIDPT">DIS_MIDPT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The BCR loop attempts to synchronize the local RX bit clock to the edge transitions of the received data bits by sampling the phase at 1*Tb intervals.    </li><li>
The sensitivity of the phase sampling process may be reduced if the BCR loop accidentally aligns to sampling at the mid-point of the data bits instead of at bit boundaries.  In extreme conditions, the sampled phase information may not be sufficient to drive the BCR loop away from the mid-point condition and towards the optimal bit boundary sampling condition.    </li><li>
This mid-point sampling condition may be detected and corrected by deliberately "kicking" the BCR loop slightly.    </li><li>
This functionality only applies to demodulation of a 2(G)FSK signal with a standard '1010...' Preamble pattern using the Synchronous Demodulator.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENABLED</td><td>0</td><td align="left">
<ul><li>
Correction of a BCR mid-point phase sampling condition by resetting the NCO is enabled (normal operation).</li></ul>
</td></tr>
<tr valign="top"><td align="left">DISABLED</td><td>1</td><td align="left">
<ul><li>
Correction of a BCR mid-point phase sampling condition by resetting the NCO is disabled.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_BCR_MISC1%3AESC_MIDPT">ESC_MIDPT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the method of "kicking" the BCR loop to escape a mid-point phase sampling condition, as described for the DIS_MIDPT bit.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ESCAPE_1CLK</td><td>0</td><td align="left">
<ul><li>
Upon detection of a BCR mid-point phase sampling condition, the NCO will stop running for one sample clock to escape.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ESCAPE_PHASE_ERR</td><td>1</td><td align="left">
<ul><li>
Upon detection of a BCR mid-point phase sampling condition, the current phase error is added to the NCO to escape.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_BCR_MISC0">MODEM_BCR_MISC0</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x2b</li>
<li>Summary: Miscellaneous RX BCR loop controls.</li>
<li>Purpose:</li>
<ul><li>
This property configures miscellaneous options within the RX BCR loop.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_BCR_MISC0</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2b</td>
<td colspan="1">ADCWATCH</td>
<td colspan="1">ADCRST</td>
<td colspan="1">DISTOGG</td>
<td colspan="1">PH0SIZE</td>
<td colspan="1">RES_LOCKUP_BYP</td>
<td>0</td>
<td>0</td>
<td colspan="1">DSA_BCR_RST</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2b</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_BCR_MISC0">MODEM_BCR_MISC0</a><ul>
<li><a name="field-MODEM_BCR_MISC0%3AADCWATCH">ADCWATCH</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
ADC watch dog is disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
ADC watch dog is enabled. If the invalid preamble is detected and  no 1010 pattern is detected, ADC reset will be generated.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_BCR_MISC0%3AADCRST">ADCRST</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
ADC watch dog is disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable ADC reset from AGC loop.  If IF-PD's current and previous high threshold exceed,  ADC reset will be generated.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_BCR_MISC0%3ADISTOGG">DISTOGG</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Normal.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enabled. If the phase differential output is zero,  the discriminator output will be toggling.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_BCR_MISC0%3APH0SIZE">PH0SIZE</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
5 consecutive zeros of phase differential output will cause RX machine reset.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
3 consecutive zeros of phase differential output will cause RX machine reset.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_BCR_MISC0%3ARES_LOCKUP_BYP">RES_LOCKUP_BYP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Needs to be set during BER testing.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable lockup detector.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable lockup detector.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_BCR_MISC0%3ADSA_BCR_RST">DSA_BCR_RST</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Needs to be set if signal arrival is enabled for BCR loop's NCO reset during BER testing.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable BCR reset from phase difference zero checking block.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable BCR reset from phase difference zero checking block.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_AFC_GEAR">MODEM_AFC_GEAR</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x2c</li>
<li>Summary: RX AFC loop gear control.</li>
<li>Purpose:</li>
<ul><li>
Selection of gear switching source for both RX AFC and BCR.</li><li>
Control of gain for RX AFC in both FAST and SLOW modes (i.e., before and after gear switching)</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_AFC_GEAR</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2c</td>
<td colspan="2">GEAR_SW</td>
<td colspan="3">AFC_FAST</td>
<td colspan="3">AFC_SLOW</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2c</td>
<td colspan="2">0x0</td>
<td colspan="3">0x0</td>
<td colspan="3">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_AFC_GEAR">MODEM_AFC_GEAR</a><ul>
<li><a name="field-MODEM_AFC_GEAR%3AGEAR_SW">GEAR_SW</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the event upon which gear switching will occur.    Gear switching simultaneously affects the BCR tracking loop as well as the PLL-based AFC loop (if enabled).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Preamble detection - switch gears after detection of Preamble.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Sync word detection - switch gears after detection of Sync Word.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
Mid-Point frequency error detection - switch gears when the estimated frequency error of the Min-Max detector in the Asynchronous     Demodulator is less than the half eye-threshold for a consecutive number of search periods.     NOTE: The consecutive number of search periods is defined <a href="#field-MODEM_RAW_SEARCH%3ASCH_FRZTH">MODEM_RAW_SEARCH:SCH_FRZTH</a>
,    while the length of each search period (in bits) is defined by <a href="#field-MODEM_RAW_SEARCH%3ASCHPRD_HI">MODEM_RAW_SEARCH:SCHPRD_HI</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
Preamble detection - switch gears after detection of Preamble (same as gear_sw = 0)</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AFC_GEAR%3AAFC_FAST">AFC_FAST</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Sets the gain of the PLL-based AFC acquisition loop prior to gear switching (i.e., during Fast tracking mode).
    </li><li>
The gain of the AFC loop is the product of a baseline gain value and a scale factor that differs according to gear switching.     The baseline gain value is specified by <a href="#prop-MODEM_AFC_GAIN">MODEM_AFC_GAIN</a>
 while the scale factors are held by the AFC_FAST and AFC_SLOW parameters.    </li><li>
The gain of the AFC loop in Fast tracking mode is MODEM_AFC_GAIN * 2<sup>-AFC_FAST</sup>,    and thus a larger value of AFC_FAST results in slower AFC tracking speed prior to gear switching. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7</dd></dl>
</li>
<li><a name="field-MODEM_AFC_GEAR%3AAFC_SLOW">AFC_SLOW</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Sets the gain of the PLL-based AFC acquisition loop after gear switching (i.e., during Slow tracking mode).
    </li><li>
The gain of the AFC loop is the product of a baseline gain value and a scale factor that differs according to gear switching.     The baseline gain value is specified by <a href="#prop-MODEM_AFC_GAIN">MODEM_AFC_GAIN</a>
 while the scale factors are held by the AFC_FAST and AFC_SLOW parameters.    </li><li>
The gain of the AFC loop in Slow tracking mode is MODEM_AFC_GAIN * 2<sup>-AFC_SLOW</sup>,    and thus a larger value of AFC_SLOW results in slower AFC tracking speed after gear switching. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_AFC_WAIT">MODEM_AFC_WAIT</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x2d</li>
<li>Summary: RX AFC loop wait time control.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for Automatic Frequency Correction (AFC) in RX mode to improve reception of the signal in the presence of frequency error in the link.  The frequency error is measured and corrected during the initial acquisition of the packet (e.g., during the Preamble), allowing optimized reception of the remainder of the packet.     </li><li>
One form of AFC provided by the chip operates by adjusting the frequency of the RX LO signal from the PLL Synthesizer, and strives to position the down-converted IF signal in the center of the IF passband.  This PLL-based form of AFC thus operates in the analog domain; the chip also provides for other forms of AFC that operate in the digital domain of the RX Modem.  The SHWAIT and LGWAIT parameters in the MODEM_AFC_WAIT property affect only PLL-based AFC.    </li><li>
Each AFC correction cycle consists of:  a) measuring the frequency error, b) adjusting the frequency of the PLL, and c) allowing the PLL to settle prior to taking another measurement of frequency error.    </li><li>
The SHWAIT and LGWAIT parameters determine the periods of time allowed for the PLL to settle after each AFC adjustment cycle.  Two different waiting periods (short and long) are provided, depending upon whether the AFC algorithm is operating before or after gear switching.    </li><li>
The waiting time is in multiples of the symbol period, and thus changes as a function of the data rate.  At higher data rates (i.e., shorter symbol periods), the values of the SHWAIT and LGWAIT parameters may need to be increased to provide sufficient time for the PLL to re-settle after correction.  The WDS Calculator automatically suggests appropriate values as a function of the selected data rate.</li></ul>
<li>Defaults: 0x23</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_AFC_WAIT</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2d</td>
<td colspan="4">SHWAIT</td>
<td colspan="4">LGWAIT</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2d</td>
<td colspan="4">0x2</td>
<td colspan="4">0x3</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_AFC_WAIT">MODEM_AFC_WAIT</a><ul>
<li><a name="field-MODEM_AFC_WAIT%3ASHWAIT">SHWAIT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This specifies the wait period per PLL AFC correction cycle before gear switching has occurred.  The SHWAIT parameter is typically set to a value smaller than the LGWAIT parameter, as fast acquisition speed prior to gear switching is usually desirable.    </li><li>
The effective wait time is (SHWAIT+1)*2Tb.    </li><li>
When set to '0' then no PLL AFC correction will occur before gear switching, i.e., PLL AFC is disabled before gear switching.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
<li><a name="field-MODEM_AFC_WAIT%3ALGWAIT">LGWAIT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This specifies the wait period per PLL AFC correction cycle after gear switching has occurred.  The LGWAIT parameter is typically set to a value larger than the SHWAIT parameter, as robust tracking of unbalanced data after gear switching is usually desirable.    </li><li>
The effective wait time is (LGWAIT+1)*2Tb.    </li><li>
When set to '0' then no PLL AFC correction will occur after gear switching, i.e., PLL AFC is disabled after gear switching.    </li><li>
If <a href="#field-MODEM_AFC_MISC%3AENAFCFRZ">MODEM_AFC_MISC:ENAFCFRZ</a>
 is set, there will be no PLL AFC correction after gear switching, regardless of the value of LGWAIT.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_AFC_GAIN">MODEM_AFC_GAIN</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x2e ... 0x2f</li>
<li>Summary: Sets the gain of the PLL-based AFC acquisition loop, and provides miscellaneous control bits for AFC functionality.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for Automatic Frequency Correction (AFC) functionality in which the frequency error of the received signal is measured     and used to adjust the PLL Synthesizer to position the down-converted IF signal in the center of the IF bandwidth.    </li><li>
The AFC algorithm uses a feedback loop to track the frequency of the incoming signal.    The gain of the AFC loop is the product of a baseline gain value and a scale factor that differs according to gear switching.    The baseline gain value is specified by this property (an unsigned 13-bit value)    while the scale factors are held by the <a href="#field-MODEM_AFC_GEAR%3AAFC_FAST">MODEM_AFC_GEAR:AFC_FAST</a>
 and <a href="#field-MODEM_AFC_GEAR%3AAFC_SLOW">MODEM_AFC_GEAR:AFC_SLOW</a>
 parameters.
    </li><li>
The ENAFC parameter enables the frequency error estimation circuitry.
    </li><li>
The AFCBD parameter enables dynamic switching of the RX bandwidth during the packet.    Please refer to <a href="#prop-MODEM_CHFLT_RX2_CHFLT_COE">MODEM_CHFLT_RX2_CHFLT_COE</a>
 for further details regarding the use of adaptive RX bandwidth. </li></ul>
<li>Defaults: 0x83, 0x69</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_AFC_GAIN</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2e</td>
<td colspan="1">ENAFC</td>
<td colspan="1">AFCBD</td>
<td colspan="1">AFC_GAIN_DIV</td>
<td colspan="5">AFCGAIN[12:8]</td>
</tr>
<tr><td>0x2f</td>
<td colspan="8">AFCGAIN[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2e</td>
<td colspan="1">0x1</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="5">0x3</td>
</tr>
<tr><td>0x2f</td>
<td colspan="8">0x69</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_AFC_GAIN">MODEM_AFC_GAIN</a><ul>
<li><a name="field-MODEM_AFC_GAIN%3AENAFC">ENAFC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
When set, enables estimation of the frequency error.
    </li><li>
Estimated frequency error is made available to feedback to the Frac-N PLL, BCR and Slicer.     NOTE:  enabling of each individual AFC function is performed in the <a href="#prop-MODEM_BCR_MISC1">MODEM_BCR_MISC1</a>
 and <a href="#prop-MODEM_AFC_MISC">MODEM_AFC_MISC</a>
 properties.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Estimation of frequency error is disabled.  This effectively disables all forms of AFC (both PLL-based AFC as well as Slicer and BCR compensation).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Estimation of frequency error is enabled.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AFC_GAIN%3AAFCBD">AFCBD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, enables the use of adaptive RX bandwidth across the packet. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Adaptive RX bandwidth is disabled.      The RX channel filter coefficients specified in <a href="#prop-MODEM_CHFLT_RX1_CHFLT_COE">MODEM_CHFLT_RX1_CHFLT_COE</a>
 are used across the entire packet. </li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Adaptive RX bandwidth is enabled.     The RX channel filter coefficients specified in <a href="#prop-MODEM_CHFLT_RX1_CHFLT_COE">MODEM_CHFLT_RX1_CHFLT_COE</a>
 are used prior to gear switching,    and the coefficients specified in <a href="#prop-MODEM_CHFLT_RX2_CHFLT_COE">MODEM_CHFLT_RX2_CHFLT_COE</a>
 are used after gear switching.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AFC_GAIN%3AAFC_GAIN_DIV">AFC_GAIN_DIV</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Reduces AFC loop gain by half when set.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NO_REDUCTION</td><td>0</td><td align="left">
<ul><li>
AFC loop gain is not reduced (normal operation).</li></ul>
</td></tr>
<tr valign="top"><td align="left">REDUCTION_BY_HALF</td><td>1</td><td align="left">
<ul><li>
AFC loop gain is reduced by half.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AFC_GAIN%3AAFCGAIN">AFCGAIN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
13-bit AFC loop gain value.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1fff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_AFC_LIMITER">MODEM_AFC_LIMITER</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x30 ... 0x31</li>
<li>Summary: Set the AFC limiter value.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for Automatic Frequency Correction (AFC) functionality in which the frequency error of the received signal is measured     and used to adjust the PLL Synthesizer to position the down-converted IF signal in the center of the IF bandwidth.    </li><li>
This property provides a "watchdog" upper limit on how far the AFC tracking loop may vary from the commanded channel center frequency (i.e., due to tracking on noise).    Upon reaching this limit, the AFC algorithm is reset to begin reacquisition from the channel center frequency. </li></ul>
<li>Defaults: 0x00, 0x40</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_AFC_LIMITER</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x30</td>
<td>0</td>
<td colspan="7">AFCLIM[14:8]</td>
</tr>
<tr><td>0x31</td>
<td colspan="8">AFCLIM[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x30</td>
<td>0x0</td>
<td colspan="7">0x0</td>
</tr>
<tr><td>0x31</td>
<td colspan="8">0x40</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_AFC_LIMITER">MODEM_AFC_LIMITER</a><ul>
<li><a name="field-MODEM_AFC_LIMITER%3AAFCLIM">AFCLIM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
15-bit AFC limiter value.     If the frequency error measured by the AFC correction algorithm exceeds this value,     the AFC algorithm is reset to begin reacquisition from channel center frequency.
    </li><li>
The AFC limiter value should be viewed as a 14-bit value plus an additional bit that enables an 8x scale factor.     If AFCLIM[14] = '0', then the AFC limiter value is AFCLIM[13:0].     If AFCLIM[14] = '1', then the AFC limiter value is AFCLIM[13:0]*8.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7fff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_AFC_MISC">MODEM_AFC_MISC</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x32</li>
<li>Summary: Specifies miscellaneous AFC control bits.</li>
<li>Purpose:</li>
<ul><li>
Specifies miscellaneous bits for control of AFC functionality.</li></ul>
<li>Defaults: 0xa0</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_AFC_MISC</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x32</td>
<td colspan="1">ENAFCFRZ</td>
<td colspan="1">ENFBPLL</td>
<td colspan="1">EN2TB_EST</td>
<td colspan="1">ENFZPMEND</td>
<td colspan="1">ENAFC_CLKSW</td>
<td colspan="1">OOK_ZEROG</td>
<td colspan="1">NON_FRZEN</td>
<td colspan="1">LARGE_FREQ_ERR</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x32</td>
<td colspan="1">0x1</td>
<td colspan="1">0x0</td>
<td colspan="1">0x1</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_AFC_MISC">MODEM_AFC_MISC</a><ul>
<li><a name="field-MODEM_AFC_MISC%3AENAFCFRZ">ENAFCFRZ</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether the AFC will operate over the entire packet, or will be frozen after gear switching.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">AFC_PKT</td><td>0</td><td align="left">
<ul><li>
AFC will operate over the entire packet.</li></ul>
</td></tr>
<tr valign="top"><td align="left">AFC_FRZN_AFTER_GEAR_SW</td><td>1</td><td align="left">
<ul><li>
AFC will be frozen after the gear switching.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AFC_MISC%3AENFBPLL">ENFBPLL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether the estimation of frequency error (i.e., AFC correction value) will be provided as feedback to adjust the PLL Synthesizer frequency.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE_AFC_COR_PLL</td><td>0</td><td align="left">
<ul><li>
Disable AFC correction value feedback to the PLL.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE_AFC_COR_PLL</td><td>1</td><td align="left">
<ul><li>
Enable AFC correction value feedback to the PLL.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AFC_MISC%3AEN2TB_EST">EN2TB_EST</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether AFC correction uses the estimation of frequency error developed by the Moving Average or Min-Max detector in the Asynchronous Demodulator, or the 2*Tb estimator in the Synchronous Demodulator.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">AFC_COR_MA</td><td>0</td><td align="left">
<ul><li>
AFC correction uses the frequency estimation developed by the Moving Average or Min-Max detector in the Asynchronous Demodulator.</li></ul>
</td></tr>
<tr valign="top"><td align="left">AFC_COR_2TB</td><td>1</td><td align="left">
<ul><li>
AFC correction uses the frequency estimation developed by the 2*Tb estimator in the Synchronous Demodulator.  This bit must be set for proper reception of a standard packet using the Synchronous Demodulator.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AFC_MISC%3AENFZPMEND">ENFZPMEND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether the AFC will freeze at the end of the '...10101...' Preamble pattern (i.e., boundary between Preamble and Sync Word).        </li><li>
This functionality may be useful if a very long Preamble is used and very good frequency error correction is desired.          Setting the ENAFCFRZ bit will take precedence over setting this bit (i.e., the AFC may be frozen earlier, as determined by the gear switching source).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NO_AFC_FRZN</td><td>0</td><td align="left">
<ul><li>
AFC will not be frozen at the end of the Preamble.</li></ul>
</td></tr>
<tr valign="top"><td align="left">AFC_FRZN_PREAMBLE</td><td>1</td><td align="left">
<ul><li>
AFC will be frozen at the end of the Preamble.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AFC_MISC%3AENAFC_CLKSW">ENAFC_CLKSW</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether the clock source for the 2*Tb frequency estimator is switched from a free-running bit clock to the BCR's bit clock upon detection of PREAMBLE_VALID. </li><li>
This bit is most useful when used together with the ENFZPMEND bit; that is, when a long Preamble is available and very good frequency error correction is desired. </li><li>
This bit has no effect if the EN2TB_EST bit is not also set (i.e., if the Asynchronous Demodulator is in use.)</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NO_CLK_SW</td><td>0</td><td align="left">
<ul><li>
The clock source for the 2*Tb frequency estimator is not switched.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CLK_SW_TO_BCR_BCLK</td><td>1</td><td align="left">
<ul><li>
The clock source for the 2*Tb frequency estimator is switched to the BCR's bit clock upon detection of PREAMBLE_VALID.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AFC_MISC%3AOOK_ZEROG">OOK_ZEROG</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip is capable of receiving an OOK signal while operating in zero-IF mode.  (Note:  this feature is currently disabled in firmware.)        </li><li>
It is important that the received OOK signal not be located precisely at zero frequency, as signals near DC are removed by filtering. </li><li>
To guard against this, pseudo-random (G)FSK modulation is added to the RX LO, thus ensuring that the received signal is not statically positioned near DC.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">FSK_MOD</td><td>0</td><td align="left">
<ul><li>
FSK modulation will be added to the RX LO in OOK zero-IF mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">GFSK_LO_MOD</td><td>1</td><td align="left">
<ul><li>
GFSK LO modulation will be added to the RX LO in OOK zero-IF mode.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AFC_MISC%3ANON_FRZEN">NON_FRZEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether AFC correction to the PLL is frozen. </li><li>
This bit only has an effect for a very specific chip configuration: a) the Asynchronous Demodulator is in use, b) the modulation type is not OOK, and c) the Min-Max detector is used to develop the slicing threshold level (as configured in the <a href="#prop-MODEM_OOK_MISC">MODEM_OOK_MISC</a>
 property).        </li><li>
When configured in this fashion, the chip will normally freeze AFC correction to the PLL when a sufficient length of consecutive 1's or 0's is encountered, as the chip may not be able to correctly estimate the frequency error within the given search period.    </li><li>
The consecutive number of search periods is defined by <a href="#field-MODEM_RAW_SEARCH%3ASCH_FRZTH">MODEM_RAW_SEARCH:SCH_FRZTH</a>
, while the length of each search period is defined by <a href="#field-MODEM_RAW_SEARCH%3ASCHPRD_HI">MODEM_RAW_SEARCH:SCHPRD_HI</a>
.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">AFC_FRZN_CONSEC_BITS</td><td>0</td><td align="left">
<ul><li>
AFC correction of the PLL will be frozen if a consecutive string of 1's or 0's that exceed the search period is encountered.</li></ul>
</td></tr>
<tr valign="top"><td align="left">AFC_ALWAYS_EN</td><td>1</td><td align="left">
<ul><li>
AFC correction of the PLL will remain enabled if a consecutive string of 1's or 0's that exceed the search period is encountered.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AFC_MISC%3ALARGE_FREQ_ERR">LARGE_FREQ_ERR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Setting this bit expands the range of the AFC acquisition algorithm.  It is recommended to set this bit when the expected frequency error is larger than 12*Symbol_Rate.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Expected range of frequency error is normal (less than 12*Symbol_Rate)</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Expected range of frequency error is large (greater than 12*Symbol_Rate)</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_AFC_ZIFOFF">MODEM_AFC_ZIFOFF</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x33</li>
<li>Summary: AFC fixed frequency offset in zero IF mode.</li>
<li>Purpose:</li>
<ul><li>
AFC fixed frequency offset in zero IF mode.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_AFC_ZIFOFF</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x33</td>
<td colspan="8">ZEROFF</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x33</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_AFC_ZIFOFF">MODEM_AFC_ZIFOFF</a><ul>
<li><a name="field-MODEM_AFC_ZIFOFF%3AZEROFF">ZEROFF</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_ADC_CTRL">MODEM_ADC_CTRL</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x34</li>
<li>Summary: Sigma Delta ADC controls.</li>
<li>Purpose:</li>
<ul><li>
This property configures various options in the sigma delta ADC.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_ADC_CTRL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x34</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">HGAIN</td>
<td colspan="1">EN_DRST</td>
<td>0</td>
<td colspan="1">REALADC</td>
<td>0</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x34</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_ADC_CTRL">MODEM_ADC_CTRL</a><ul>
<li><a name="field-MODEM_ADC_CTRL%3AHGAIN">HGAIN</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Adds 12 dB gain to ADC input for IR calibration.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_ADC_CTRL%3AEN_DRST">EN_DRST</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
 Disable direct reset by modem.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Enable direct reset by modem.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_ADC_CTRL%3AREALADC">REALADC</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">COMPLEX</td><td>0</td><td align="left">
<ul><li>
ADC complex mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">REAL</td><td>1</td><td align="left">
<ul><li>
ADC real mode.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_AGC_CONTROL">MODEM_AGC_CONTROL</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x35</li>
<li>Summary: Miscellaneous control bits for the Automatic Gain Control (AGC) function in the RX Chain.</li>
<li>Purpose:</li>
<ul><li>
This property provides several miscellaneous control bits for the AGC functionality.     These control bits are primarily intended for engineering diagnostic purposes;    Silicon Labs does not recommend altering the values suggested by the WDS Calculator,    unless required to accommodate unusual customer applications.</li></ul>
<li>Defaults: 0xe0</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_AGC_CONTROL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x35</td>
<td colspan="1">AGCOVPKT</td>
<td colspan="1">IFPDSLOW</td>
<td colspan="1">RFPDSLOW</td>
<td colspan="1">SGI_N</td>
<td colspan="1">AGC_SLOW</td>
<td colspan="1">FORCE_ADC_GAIN_LOW</td>
<td colspan="1">ADC_GAIN_COR_EN</td>
<td colspan="1">RST_PKDT_PERIOD</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x35</td>
<td colspan="1">0x1</td>
<td colspan="1">0x1</td>
<td colspan="1">0x1</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_AGC_CONTROL">MODEM_AGC_CONTROL</a><ul>
<li><a name="field-MODEM_AGC_CONTROL%3AAGCOVPKT">AGCOVPKT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether the AGC operates over the entire packet, or only during acquisition of the Preamble.
    </li><li>
Reductions in gain (in the event of signal level increases) are always allowed at any time, regardless of the state of this bit.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
The full AGC operates only during acquisition of the Preamble.    Gain increases (in the event of a decrease in signal level) over the remainder of packet are not allowed. </li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
AGC function operates over the entire packet.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AGC_CONTROL%3AIFPDSLOW">IFPDSLOW</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip contains peak detectors in the IF chain for the purpose of sensing the signal level at the outputs of the IF PGAs.      The information from these peak detectors is used by the AGC algorithm to adjust the gain of the RX chain (PGA and LNA).
    </li><li>
	In the event the signal level increases abruptly, it is desirable to decrease the gain rapidly else compression may occur in the RX chain.      The IFPDSLOW bit controls the step size of gain reductions to the PGA, and thus affects the slope or speed of the AGC attack time.
    </li><li>
This bit affects only the rate of gain decreases; increases in gain are always performed in 3 dB steps.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
The IF programmable gain loop will perform the first required gain decrease in a -3 dB step,    but if further gain reductions are required (due to successive indications of the signal level exceeding the peak detector threshold)    will switch to -6 dB steps.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
The IF programmable gain loop will always perform gain decreases in -3 dB steps.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AGC_CONTROL%3ARFPDSLOW">RFPDSLOW</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip contains RF peak detectors for the purpose of sensing the signal level at the output of the LNA.     The information from these peak detectors is used by the AGC algorithm to adjust the gain of the RX chain (PGA and LNA).
    </li><li>
In the event the signal level increases abruptly, it is desirable to decrease the gain rapidly else compression may occur in the RX chain.     The RFPDSLOW bit controls the step size of gain reductions to the LNA, and thus affects the slope or speed of the AGC attack time.
    </li><li>
This bit affects only the rate of gain decreases; increases in gain are always performed in 3 dB steps.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
The RF programmable gain loop will perform the first required gain decrease in a -3 dB step,     but if further gain reductions are required (due to successive indications of the signal level exceeding the peak detector threshold) will switch to -6 dB steps.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
The RF programmable gain loop will always perform gain decreases in -3 dB steps. </li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AGC_CONTROL%3ASGI_N">SGI_N</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether gain increases are allowed due to selection of a weak antenna during the Antenna Diversity algorithm.
    </li><li>
This bit is effective only in ANT-DIV mode, and only during acquisition of the Preamble (when the signal strength of the two antennas is being evaluated).
    </li><li>
This functionality is provided to prevent temporary overload of the RX Chain due to final selection of a strong antenna,    after first adjusting the gain to a high value as a result of evaluation of a low signal on a weak antenna.
    </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
AGC gain increases during signal reductions are prevented.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
AGC gain increases during signal reductions are allowed.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AGC_CONTROL%3AAGC_SLOW">AGC_SLOW</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The period of the AGC cycle (including both a measurement window period and a gain settling window period)     is normally configured by the <a href="#prop-MODEM_AGC_WINDOW_SIZE">MODEM_AGC_WINDOW_SIZE</a>
 property.
    </li><li>
In the event that the AGC cycle speed cannot be configured to a sufficiently low value,    the AGC speed may be reduced by an additional factor of 8x by setting the AGC_SLOW bit.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Normal AGC speed.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
AGC speed is reduced by a factor of 8.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AGC_CONTROL%3AFORCE_ADC_GAIN_LOW">FORCE_ADC_GAIN_LOW</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Forces the ADC input gain to be reduced by 6dB.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DO_NOTHING</td><td>0</td><td align="left">
<ul><li>
Does not modify the ADC GAIN.</li></ul>
</td></tr>
<tr valign="top"><td align="left">FORCE_LOW</td><td>1</td><td align="left">
<ul><li>
ADC input gain reduced by 6dB.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AGC_CONTROL%3AADC_GAIN_COR_EN">ADC_GAIN_COR_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether the input gain of the RX A/D Converter is reduced when the condition of minimum AGC gain is detected.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ADC_GAIN_DIS</td><td>0</td><td align="left">
<ul><li>
Adjustment of the ADC input gain is disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ADC_GAIN_VIA_AGC</td><td>1</td><td align="left">
<ul><li>
ADC input gain is reduced by 6 dB, when the condition of minimum AGC gain is detected.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_AGC_CONTROL%3ARST_PKDT_PERIOD">RST_PKDT_PERIOD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the period at which the IF and RF peak detectors are reset. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
The peak detectors are reset only when a change in gain is indicated by the peak detector output. </li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
The peak detectors are reset on each and every cycle of the AGC algorithm. </li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_RESERVED_20_36">MODEM_RESERVED_20_36</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x36</li>
<li>Summary: Reserved.</li>
<li>Purpose:</li>
<ul><li>
Reserved.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_RESERVED_20_36</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x36</td>
<td colspan="8">RESERVED_20_36</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x36</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_RESERVED_20_36">MODEM_RESERVED_20_36</a><ul>
<li><a name="field-MODEM_RESERVED_20_36%3ARESERVED_20_36">RESERVED_20_36</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reserved_20_36</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_RESERVED_20_37">MODEM_RESERVED_20_37</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x37</li>
<li>Summary: Reserved.</li>
<li>Purpose:</li>
<ul><li>
Reserved.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_RESERVED_20_37</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x37</td>
<td colspan="8">RESERVED_20_37</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x37</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_RESERVED_20_37">MODEM_RESERVED_20_37</a><ul>
<li><a name="field-MODEM_RESERVED_20_37%3ARESERVED_20_37">RESERVED_20_37</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reserved_20_37</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_AGC_WINDOW_SIZE">MODEM_AGC_WINDOW_SIZE</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x38</li>
<li>Summary: Specifies the size of the measurement and settling windows for the AGC algorithm. </li>
<li>Purpose:</li>
<ul><li>
One cycle of the AGC algorithm consists of a measurement window period, a (potential) gain adjustment, and a gain settling window period.
    </li><li>
	During the measurement window period, the signal level is measured by peak detectors located at the outputs of the LNA and PGA gain stages.        Gain adjustments (up or down) are performed depending upon whether the measured signal level falls within an amplitude threshold window.
    </li><li>
	The periods of both the measurement window and the gain settling window are adjustable.         It is necessary that the measurement window is sufficient in length to allow capture of a peak of the sinusoidal IF signal.         As the IF frequency used by the chip is configurable, the measurement window must also be configurable.
    </li><li>
	The units of the MEASWIN and SETTLEWIN fields are in periods of the oversampling clock for the Bit Clock Recovery (BCR) loop        (e.g., typically 8 to 12 times the received data rate).
    </li><li>
	In the event that the window times obtained for the maximum values of MEASWIN and SETTLEWIN are not sufficiently long,        their effective values may be simultaneously increased by a factor of 8x by setting the AGC_SLOW bit in the <a href="#prop-MODEM_AGC_CONTROL">MODEM_AGC_CONTROL</a>
 property.        (This need is unlikely to occur.)
</li></ul>
<li>Defaults: 0x11</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_AGC_WINDOW_SIZE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x38</td>
<td colspan="4">MEASWIN</td>
<td colspan="4">SETTLEWIN</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x38</td>
<td colspan="4">0x1</td>
<td colspan="4">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_AGC_WINDOW_SIZE">MODEM_AGC_WINDOW_SIZE</a><ul>
<li><a name="field-MODEM_AGC_WINDOW_SIZE%3AMEASWIN">MEASWIN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
 Size of the signal level measurement window for the AGC algorithm.
    </li><li>
Effective measurement time is: <br />[LATEX equation: MEAS\_TIME = (\frac{MEASWIN \times 2^{3 \times AGCSLOW}}{F_{S BCR}})]
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x1</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
<li><a name="field-MODEM_AGC_WINDOW_SIZE%3ASETTLEWIN">SETTLEWIN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
 Size of the gain settling window for the AGC algorithm.
    </li><li>
 Effective settling time is: <br />[LATEX equation: SETTLE\_TIME = (\frac{SETTLEWIN \times 2^{3 \times AGCSLOW}}{F_{S BCR}})]
 </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x1</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_AGC_RFPD_DECAY">MODEM_AGC_RFPD_DECAY</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x39</li>
<li>Summary: Sets the decay time of the RF peak detectors. </li>
<li>Purpose:</li>
<ul><li>
The chip contains RF peak detectors in the LNA for the purpose of sensing the signal level at the output of the LNA.          The information from these peak detectors is used by the AGC algorithm to adjust the gain of the RX chain (PGA and LNA).
    </li><li>
	It is usually desirable for AGC circuitry to attack quickly (rapidly decrease the gain when the signal level increases)        but decay slowly (slowly increase the gain when the signal level decreases).
    </li><li>
	To accomplish the slow decay, the chip requires that the peak detectors indicate a consecutive number of "signal below threshold" conditions before the gain is increased.         The requirement for consistent indication for gain increase is advisable to prevent gain chattering.        The required number of consecutive indications is set by the RFPD_DECAY value.
</li><li>
	It is usually recommended to set the MODEM_AGC_IFPD_DECAY and MODEM_AGC_RFPD_DECAY properties to identical values.
</li></ul>
<li>Defaults: 0x10</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_AGC_RFPD_DECAY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x39</td>
<td colspan="8">RFPD_DECAY</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x39</td>
<td colspan="8">0x10</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_AGC_RFPD_DECAY">MODEM_AGC_RFPD_DECAY</a><ul>
<li><a name="field-MODEM_AGC_RFPD_DECAY%3ARFPD_DECAY">RFPD_DECAY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Specifies the consecutive number of AGC cycles for which the RF peak detectors must give a consistent increase gain indication, before the gain increase is allowed.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x1</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_AGC_IFPD_DECAY">MODEM_AGC_IFPD_DECAY</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x3a</li>
<li>Summary: Sets the decay time of the IF peak detectors.</li>
<li>Purpose:</li>
<ul><li>
The chip contains peak detectors in the IF chain for the purpose of sensing the signal level at the outputs of the IF PGAs.          The information from these peak detectors is used by the AGC algorithm to adjust the gain of the RX chain (PGA and LNA).
    </li><li>
	It is usually desirable for AGC circuitry to attack quickly (rapidly decrease the gain when the signal level increases)        but decay slowly (slowly increase the gain when the signal level decreases).
    </li><li>
	To accomplish the slow decay, the chip requires that the peak detectors indicate a consecutive number of "signal below threshold" conditions before the gain is increased.        The requirement for consistent indication for gain increase is advisable to prevent gain chattering.          The required number of consecutive indications is set by the IFPD_DECAY value.
    </li><li>
	It is usually recommended to set the MODEM_AGC_IFPD_DECAY and MODEM_AGC_RFPD_DECAY properties to identical values.
</li></ul>
<li>Defaults: 0x10</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_AGC_IFPD_DECAY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x3a</td>
<td colspan="8">IFPD_DECAY</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x3a</td>
<td colspan="8">0x10</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_AGC_IFPD_DECAY">MODEM_AGC_IFPD_DECAY</a><ul>
<li><a name="field-MODEM_AGC_IFPD_DECAY%3AIFPD_DECAY">IFPD_DECAY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Specifies the consecutive number of AGC cycles for which the IF peak detectors must give a consistent increase gain indication, before the gain increase is allowed.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x1</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_FSK4_GAIN1">MODEM_FSK4_GAIN1</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x3b</li>
<li>Summary: Specifies the gain factor of the secondary branch in 4(G)FSK ISI-suppression.</li>
<li>Purpose:</li>
<ul><li>
Controls 4(G)FSK suppression gain.</li></ul>
<li>Defaults: 0x0b</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_FSK4_GAIN1</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x3b</td>
<td colspan="1">4FSK_ISIS_DISABLE</td>
<td colspan="7">4FSK_GAIN1</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x3b</td>
<td colspan="1">0x0</td>
<td colspan="7">0xb</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_FSK4_GAIN1">MODEM_FSK4_GAIN1</a><ul>
<li><a name="field-MODEM_FSK4_GAIN1%3A4FSK_ISIS_DISABLE">4FSK_ISIS_DISABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Second phase compensation factor for 4(G)FSK.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Normal.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Disable 4(G)FSK ISI-suppression.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_FSK4_GAIN1%3A4FSK_GAIN1">4FSK_GAIN1</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Gain factor of the secondary branch in 4(G)FSK ISI-suppression.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_FSK4_GAIN0">MODEM_FSK4_GAIN0</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x3c</li>
<li>Summary: Specifies the gain factor of the primary branch in 4(G)FSK ISI-suppression.</li>
<li>Purpose:</li>
<ul><li>
Controls 4(G)FSK suppression gain.</li></ul>
<li>Defaults: 0x1c</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_FSK4_GAIN0</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x3c</td>
<td colspan="1">PHASE_COMP_2FSK</td>
<td colspan="7">4FSK_GAIN0</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x3c</td>
<td colspan="1">0x0</td>
<td colspan="7">0x1c</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_FSK4_GAIN0">MODEM_FSK4_GAIN0</a><ul>
<li><a name="field-MODEM_FSK4_GAIN0%3APHASE_COMP_2FSK">PHASE_COMP_2FSK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, phase compensation is enabled.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable phase compenstation for 2fsk..</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable phase compenstation for 2fsk..</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_FSK4_GAIN0%3A4FSK_GAIN0">4FSK_GAIN0</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_FSK4_TH">MODEM_FSK4_TH</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x3d ... 0x3e</li>
<li>Summary: 16 bit 4(G)FSK slicer threshold.</li>
<li>Purpose:</li>
<ul><li>
16 bit4(G)FSK slicer threshold.</li></ul>
<li>Defaults: 0x40, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_FSK4_TH</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x3d</td>
<td colspan="8">4FSKTH[15:8]</td>
</tr>
<tr><td>0x3e</td>
<td colspan="8">4FSKTH[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x3d</td>
<td colspan="8">0x40</td>
</tr>
<tr><td>0x3e</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_FSK4_TH">MODEM_FSK4_TH</a><ul>
<li><a name="field-MODEM_FSK4_TH%3A4FSKTH">4FSKTH</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_FSK4_MAP">MODEM_FSK4_MAP</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x3f</li>
<li>Summary: 4(G)FSK symbol mapping code.</li>
<li>Purpose:</li>
<ul><li>
The chip is capable of transmitting and receiving 4(G)FSK modulation.    In this type of modulation, pairs of data bits are encoded/decoded into 1-of-4 possible frequency deviation levels.     This property controls the mapping of bit pairs into deviation levels.    </li><li>
The four deviation levels are evenly spaced and symmetrical around the channel center frequency.     As an example, the deviation levels for a 4(G)FSK modulation protocol with 10kHz spacing between levels would be:  -15kHz, -5kHz, +5 kHz, and +15 kHz.     </li><li>
By convention, these four deviation levels are often referred to as the -3F, -1F, +1F, and +3F levels.     This naming convention arises from the fact that the outer deviation    (i.e., the difference between channel center frequency and the outer-most deviation levels) is always 3x the inner deviation.    </li><li>
There are 24 unique ways in which pairs of bits may be mapped to the four deviation levels.     These methods are enumerated below.    The coding of the enumerations is read (left to right) as:  -3F, -1F, +1F, and +3F.    </li><li>
Using MODEM_FSK4_MAP = 0x00 as an example, the bit pair '00' would be mapped to the -3F level,     the bit pair '01' would be mapped to the -1F level, the bit pair '11' to the +1F level, and the '10' bit pair to the +3F level.    </li><li>
It is important that the TX and RX sides of the link use the same 4(G)FSK symbol mapping, else establishment of the link may not be possible.      Also, test equipment vendors may not all use the same default symbol mapping; settings that work with one piece of lab test equipment may not work with another.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_FSK4_MAP</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x3f</td>
<td colspan="8">4FSKMAP</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x3f</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_FSK4_MAP">MODEM_FSK4_MAP</a><ul>
<li><a name="field-MODEM_FSK4_MAP%3A4FSKMAP">4FSKMAP</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
`00 `01 `11 `10</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
`00 `01 `10 `11</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
`00 `11 `01 `10</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
`00 `11 `10 `01</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_4</td><td>4</td><td align="left">
<ul><li>
`00 `10 `01 `11</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_5</td><td>5</td><td align="left">
<ul><li>
`00 `10 `11 `01</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_6</td><td>6</td><td align="left">
<ul><li>
`01 `00 `11 `10</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_7</td><td>7</td><td align="left">
<ul><li>
`01 `00 `10 `11</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_8</td><td>8</td><td align="left">
<ul><li>
`01 `11 `00 `10</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_9</td><td>9</td><td align="left">
<ul><li>
`01 `11 `10 `00</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_10</td><td>10</td><td align="left">
<ul><li>
`01 `10 `00 `11</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_11</td><td>11</td><td align="left">
<ul><li>
`01 `10 `11 `00</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_12</td><td>12</td><td align="left">
<ul><li>
`11 `00 `01 `10</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_13</td><td>13</td><td align="left">
<ul><li>
`11 `00 `10 `01</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_14</td><td>14</td><td align="left">
<ul><li>
`11 `01 `00 `10</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_15</td><td>15</td><td align="left">
<ul><li>
`11 `01 `10 `00</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_16</td><td>16</td><td align="left">
<ul><li>
`11 `10 `00 `01</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_17</td><td>17</td><td align="left">
<ul><li>
`11 `10 `01 `00</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_18</td><td>18</td><td align="left">
<ul><li>
`10 `00 `01 `11</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_19</td><td>19</td><td align="left">
<ul><li>
`10 `00 `11 `01</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_20</td><td>20</td><td align="left">
<ul><li>
`10 `01 `00 `11</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_21</td><td>21</td><td align="left">
<ul><li>
`10 `01 `11 `00</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_22</td><td>22</td><td align="left">
<ul><li>
`10 `11 `00 `01</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_23</td><td>23</td><td align="left">
<ul><li>
`10 `11 `01 `00</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_OOK_PDTC">MODEM_OOK_PDTC</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x40</li>
<li>Summary: Configures the attack and decay times of the OOK Peak Detector.</li>
<li>Purpose:</li>
<ul><li>
The chip provides two different methods of developing the slicing reference level for demodulation of an OOK signal:     Peak Detection, and a Moving Average Filter.    This property configures the attack and decay times of the OOK peak detector.
    </li><li>
The rate at which the peak detector charges or discharges is proportional to 2<sup>-ATTACK</sup> or 2<sup>-DECAY</sup>.    As a result, larger values of the ATTACK and DECAY parameters result in slower attack and decay times, respectively.     </li><li>
Please refer to <a href="#prop-MODEM_OOK_MISC">MODEM_OOK_MISC</a>
 for more details regarding configuration of the detector(s) used in OOK demodulation. </li></ul>
<li>Defaults: 0x2b</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_OOK_PDTC</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x40</td>
<td>0</td>
<td colspan="3">ATTACK</td>
<td colspan="4">DECAY</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x40</td>
<td>0x0</td>
<td colspan="3">0x2</td>
<td colspan="4">0xb</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_OOK_PDTC">MODEM_OOK_PDTC</a><ul>
<li><a name="field-MODEM_OOK_PDTC%3AATTACK">ATTACK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selection of the attack time of the OOK peak detector.     The peak detector charges at a rate proportional to 2<sup>-ATTACK</sup>.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7</dd></dl>
</li>
<li><a name="field-MODEM_OOK_PDTC%3ADECAY">DECAY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selection of the decay time of the OOK peak detector.     The peak detector discharges at a rate proportional to 2<sup>-DECAY</sup>.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_OOK_BLOPK">MODEM_OOK_BLOPK</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x41</li>
<li>Summary: Configures the slicing reference level of the OOK Peak Detector.</li>
<li>Purpose:</li>
<ul><li>
The chip provides two different methods of developing the slicing reference level for demodulation of an OOK signal:     Peak Detection, and a Moving Average Filter.      This property configures the slicing reference level of the OOK peak detector.     </li><li>
The slicing reference level is defined as a selectable number of dB below the peak measured signal level. </li></ul>
<li>Defaults: 0x0c</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_OOK_BLOPK</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x41</td>
<td colspan="8">BW_PK</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x41</td>
<td colspan="8">0xc</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_OOK_BLOPK">MODEM_OOK_BLOPK</a><ul>
<li><a name="field-MODEM_OOK_BLOPK%3ABW_PK">BW_PK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Sets the slicing reference level of the OOK peak detector at a selectable number of dB below the peak measured level.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_OOK_CNT1">MODEM_OOK_CNT1</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x42</li>
<li>Summary: OOK control.</li>
<li>Purpose:</li>
<ul><li>
OOK control.</li></ul>
<li>Defaults: 0xa4</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_OOK_CNT1</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x42</td>
<td colspan="2">S2P_MAP</td>
<td colspan="1">OOKFRZEN</td>
<td colspan="1">MA_FREQDWN</td>
<td colspan="1">RAW_SYN</td>
<td colspan="1">SLICER_FAST</td>
<td colspan="2">SQUELCH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x42</td>
<td colspan="2">0x2</td>
<td colspan="1">0x1</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x1</td>
<td colspan="2">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_OOK_CNT1">MODEM_OOK_CNT1</a><ul>
<li><a name="field-MODEM_OOK_CNT1%3AS2P_MAP">S2P_MAP</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
S2p_mapping 0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
S2p_mapping 1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
S2p_mapping 2.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
S2p_mapping 3.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_OOK_CNT1%3AOOKFRZEN">OOKFRZEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit only has an effect after preamble is detected.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Normal.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
AGC and OOK moving average detector's  threshold output will be frozen after the preamble is detected.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_OOK_CNT1%3AMA_FREQDWN">MA_FREQDWN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, estimated frequency from MA detector  will be trunked 4 bits to avoid overflow.
    </li><li>
AFC gain should be increased 16 times if this  bit is set.
    </li><li>
It is recommended to set this bit for  Rb smaller than 1kbps and/or hModInd greater than 50  if MA detector's frequency error estimator is  selected.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_OOK_CNT1%3ARAW_SYN">RAW_SYN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, raw data output is synchronized to bit clock.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_OOK_CNT1%3ASLICER_FAST">SLICER_FAST</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit effects 2(G)FSK/OOK mode only.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Discriminator's slicer output is  de-glitched by bit clock.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Discriminator's slicer output is  de-glitched by sample clock to reduce  turn-around time.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_OOK_CNT1%3ASQUELCH">SQUELCH</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Squelch function is off.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
When no signal is received, there is  no toggling of RX data output.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
When PM is not detected, there is no  toggling of RX data output.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
When no signal or PM is not detected,  there is no toggling of RX data output.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_OOK_MISC">MODEM_OOK_MISC</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x43</li>
<li>Summary: Selects the detector(s) used for demodulation of an OOK signal, or for demodulation of a (G)FSK signal when using the asynchronous demodulator.</li>
<li>Purpose:</li>
<ul><li>
The chip internally implements two different types of demodulator circuits:  a synchronous demodulator and an asynchronous demodulator.  The synchronous demodulator is typically used for reception of (G)FSK signals with a standard Preamble and packet structure, while the asynchronous demodulator is typically used for reception of (G)FSK signals with non-standard Preamble and packet structures, as well as for all OOK signals.    </li><li>
Within the asynchronous demodulator, several different types of detectors may be selected to establish the voltage reference level for slicing the received data bits.    </li><li>
This property is used to select among the following types of detectors:  a moving average filter, a peak detector, and a min-max detector.    </li><li>
The moving average filter detector establishes the slicing threshold level based upon the average of the previous data bits, and thus works best when the data stream is balanced and contains numerous bit transitions (e.g., a Preamble pattern or Manchester-coded data).  This type of detector may be used with both OOK and (G)FSK signals.    </li><li>
The peak detector establishes the slicing threshold level as a selectable number of dB below the peak measured signal level.  This type of detector is applicable only for OOK signals.    </li><li>
The min-max detector establishes the slicing threshold level as the mid-point between the maximum and minimum detected frequency deviation levels.  This type of detector is applicable only for (G)FSK signals.
</li></ul>
<li>Defaults: 0x03</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_OOK_MISC</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x43</td>
<td colspan="1">OOKFASTMA</td>
<td>0</td>
<td colspan="1">OOK_LIMIT_DISCHG</td>
<td colspan="1">OOK_SQUELCH_EN</td>
<td colspan="2">OOK_DISCHG_DIV</td>
<td colspan="2">DETECTOR</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x43</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="2">0x0</td>
<td colspan="2">0x3</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_OOK_MISC">MODEM_OOK_MISC</a><ul>
<li><a name="field-MODEM_OOK_MISC%3AOOKFASTMA">OOKFASTMA</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether the length of the moving average filter window (used to establish the slicing threshold value from the previous data bits) is as specified directly by the MODEM_RAW_SEARCH property, or the value in <a href="#prop-MODEM_RAW_SEARCH">MODEM_RAW_SEARCH</a>
 is effectively increased by 2x.    </li><li>
This bit is effective only when demodulating an OOK signal, and allows trading off accuracy of the slicing threshold with response time to the first bit(s) of the OOK packet.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NORMAL_MA_WINDOW</td><td>0</td><td align="left">
<ul><li>
Normal.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LONG_MA_WINDOW</td><td>1</td><td align="left">
<ul><li>
Deploy longer MA filter window.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_OOK_MISC%3AOOK_LIMIT_DISCHG">OOK_LIMIT_DISCHG</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Configures if the peak detector discharge is limited.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ALWAYS_DISCHG</td><td>0</td><td align="left">
<ul><li>
Peak detector discharges always.</li></ul>
</td></tr>
<tr valign="top"><td align="left">LIMIT_DISCHG</td><td>1</td><td align="left">
<ul><li>
Peak detector discharge is disabled when the detected peak is lower than the input signal for low input levels.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_OOK_MISC%3AOOK_SQUELCH_EN">OOK_SQUELCH_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
When set, squelches the RXDATA bit stream output in real-time on a selected GPIO pin until signal arrival is detected.  This squelch functionality is only applicable when demodulating an OOK signal.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable OOK Squelch functionality..</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable OOK Squelch functionality..</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_OOK_MISC%3AOOK_DISCHG_DIV">OOK_DISCHG_DIV</a>
<dl><dt>Description:</dt><dd>
<ul><li>
OOK Peak Detector discharge divider.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NO_DISCHG_DIV</td><td>0</td><td align="left">
<ul><li>
Does not affect OOK decay rate specified in decay[3:0] in <a href="#prop-MODEM_OOK_PDTC">MODEM_OOK_PDTC</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DISCHG_HALF</td><td>1</td><td align="left">
<ul><li>
OOK PK Detector discharges at half of the OOK decay rate specified in decay[3:0] in <a href="#prop-MODEM_OOK_PDTC">MODEM_OOK_PDTC</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DISCHG_QUARTER</td><td>2</td><td align="left">
<ul><li>
OOK PK Detector discharges at a quarter of the OOK decay rate specified in decay[3:0] in <a href="#prop-MODEM_OOK_PDTC">MODEM_OOK_PDTC</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DISCHG_EIGHTH</td><td>3</td><td align="left">
<ul><li>
OOK PK Detector discharges at an 8th of the decay rate specified in decay[3:0] in <a href="#prop-MODEM_OOK_PDTC">MODEM_OOK_PDTC</a>
.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_OOK_MISC%3ADETECTOR">DETECTOR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the type of detector used to establish the slicing threshold for asynchronous demodulation of the data.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">MA_PK</td><td>0</td><td align="left">
<ul><li>
Both the peak detector and the moving average filter detector are used; the outputs of the two detectors are logically AND'ed together to provide the final RX data stream.  This option is applicable only when demodulating an OOK signal.</li></ul>
</td></tr>
<tr valign="top"><td align="left">PK</td><td>1</td><td align="left">
<ul><li>
PThe peak detector is selected to establish the slicing threshold level.  Selection of the peak detector is only applicable when demodulating an OOK signal.  The attack and decay times of the peak detector are controlled through the <a href="#prop-MODEM_OOK_PDTC">MODEM_OOK_PDTC</a>
 property.</li></ul>
</td></tr>
<tr valign="top"><td align="left">MA</td><td>2</td><td align="left">
<ul><li>
The moving average filter detector is selected to establish the slicing threshold level.  Selection of the MA filter detector is appropriate for demodulation of either an OOK signal or a (G)FSK signal with an unconventional (i.e., "legacy") packet structure.  The MA filter window length is configured through the MODEM_RAW_SEARCH property. </li></ul>
</td></tr>
<tr valign="top"><td align="left">MEAN</td><td>3</td><td align="left">
<ul><li>
The min-max detector is selected to establish the slicing threshold level as the mid-point between the measured extreme frequency deviation levels.  Selection of the min-max detector is applicable when demodulating a (G)FSK signal with an unconventional (i.e., "legacy") packet structure.  The search window length (over which the min-max frequency values are measured) is configured through the <a href="#prop-MODEM_RAW_SEARCH">MODEM_RAW_SEARCH</a>
 property.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_RAW_SEARCH">MODEM_RAW_SEARCH</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x44</li>
<li>Summary: Defines and controls the search period length for the Moving Average and Min-Max detectors.</li>
<li>Purpose:</li>
<ul><li>
The chip internally implements two different types of demodulator circuits:  a synchronous demodulator and an asynchronous demodulator.  The synchronous demodulator is typically used for reception of (G)FSK signals with a standard Preamble and packet structure, while the asynchronous demodulator is typically used for reception of (G)FSK signals with non-standard Preamble and packet structures, as well as for all OOK signals.    </li><li>
Within the asynchronous demodulator, several different types of detectors may be selected to establish the voltage reference level for slicing the received data bits, including a moving average filter, a peak detector, and a min-max detector.  The type of detector used in the asynchronous demodulator is selected in the MODEM_OOK_MISC property.
    The moving average filter and min-max detectors both establish the slicing threshold level based upon the values of the previous data bits.  This property is used to configure the number of previous data bits (i.e., search window length) over which the moving average and min-max detectors establish the slicing threshold level.    </li><li>
The search period length may be configured for different values before gear switching and after gear switching.  A shorter search period window is typically selected prior to gear switching, as the Preamble field usually contains regular bit transitions and fast acquisition is desirable.  A longer search period window is typically selected after gear switching, as the Payload fields may contain highly unbalanced data and irregular bit transitions; as a result, a longer search period may be required to capture both polarities of data bits for accurate establishment of the slicing threshold level.    </li><li>
Alternatively, the slicing threshold search engine may be "frozen" upon gear switching, such that no further adjustments to the slicing threshold level are made across the remainder of the packet.</li></ul>
<li>Defaults: 0x56</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_RAW_SEARCH</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x44</td>
<td colspan="1">SCH_FRZEN</td>
<td colspan="3">SCH_FRZTH</td>
<td colspan="2">SCHPRD_HI</td>
<td colspan="2">SCHPRD_LOW</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x44</td>
<td colspan="1">0x0</td>
<td colspan="3">0x5</td>
<td colspan="2">0x1</td>
<td colspan="2">0x2</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_RAW_SEARCH">MODEM_RAW_SEARCH</a><ul>
<li><a name="field-MODEM_RAW_SEARCH%3ASCH_FRZEN">SCH_FRZEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether the Moving Average or Min-Max slicing threshold search engine is frozen upon gear switching. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Do not freeze the Moving Average or Min-Max slicing threshold search engine upon switching to low gear.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Freeze the Moving Average or Min-Max slicing threshold search engine upon switching to low gear.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_RAW_SEARCH%3ASCH_FRZTH">SCH_FRZTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This field only has an effect for a very specific chip configuration:     a) The Asynchronous Demodulator is in use.     b) The modulation type is not OOK.     c)The Min-Max detector is used to develop the slicing threshold level (as configured in the <a href="#prop-MODEM_OOK_MISC">MODEM_OOK_MISC</a>
 property).     d) Gear switching upon frequency settling is selected (as configured in the <a href="#prop-MODEM_AFC_GEAR">MODEM_AFC_GEAR</a>
 property).     </li><li>
When configured in this fashion, the chip will gear switch when the estimated frequency error of the Min-Max detector remains within a window equal to 0.5*<a href="#prop-MODEM_RAW_EYE">MODEM_RAW_EYE</a>
 for a consecutive number of search periods.    </li><li>
The consecutive number of search periods is defined by SCH_FRZTH, while the length of each search period is defined by SCHPRD_HI.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x1</dd></dl>
<dl><dt>Max:</dt><dd>0x7</dd></dl>
</li>
<li><a name="field-MODEM_RAW_SEARCH%3ASCHPRD_HI">SCHPRD_HI</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the search period window length (in bit periods) over which the Moving Average filter or Min-Max detector establishes the slicing threshold level, prior to gear switching (i.e., during high gear).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SEARCH_2TB</td><td>0</td><td align="left">
<ul><li>
Search window period = 2*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_4TB</td><td>1</td><td align="left">
<ul><li>
Search window period = 4*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_8TB</td><td>2</td><td align="left">
<ul><li>
Search window period = 8*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_16TB</td><td>3</td><td align="left">
<ul><li>
Search window period = 16*TB</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_RAW_SEARCH%3ASCHPRD_LOW">SCHPRD_LOW</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the search period window length (in bit periods) over which the Moving Average filter or Min-Max detector establishes the slicing threshold level, after gear switching (i.e., during low gear).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SEARCH_2TB</td><td>0</td><td align="left">
<ul><li>
Search window period = 2*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_4TB</td><td>1</td><td align="left">
<ul><li>
Search window period = 4*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_8TB</td><td>2</td><td align="left">
<ul><li>
Search window period = 8*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_16TB</td><td>3</td><td align="left">
<ul><li>
Search window period = 16*TB</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_RAW_CONTROL">MODEM_RAW_CONTROL</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x45</li>
<li>Summary: Defines gain and enable controls for raw / nonstandard mode.</li>
<li>Purpose:</li>
<ul><li>
Defines gain and enable controls for raw / nonstandard mode.</li></ul>
<li>Defaults: 0x02</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_RAW_CONTROL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x45</td>
<td colspan="1">UNSTDPK</td>
<td colspan="1">CONSCHK_BYP</td>
<td>0</td>
<td>0</td>
<td colspan="2">PM_PATTERN</td>
<td colspan="2">RAWGAIN</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x45</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="2">0x0</td>
<td colspan="2">0x2</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_RAW_CONTROL">MODEM_RAW_CONTROL</a><ul>
<li><a name="field-MODEM_RAW_CONTROL%3AUNSTDPK">UNSTDPK</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Standard packet mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
MA or mean frequency error estimator.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_RAW_CONTROL%3ACONSCHK_BYP">CONSCHK_BYP</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
If unstdpk is '1', and conschk_byp= '0', the  consecutive '1' or '0' of payload data during 'Sch_Period' will stop the mean  value being updated.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Normal.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_RAW_CONTROL%3APM_PATTERN">PM_PATTERN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
PM pattern configuration.  The preamble detection is done inside modem.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">1010</td><td>0</td><td align="left">
<ul><li>
If preamble has '1010' pattern, modem  is recommended to work on standard packet mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONSECUTIVE_ONE</td><td>1</td><td align="left">
<ul><li>
If preamble has more than 32-bit  consecutive '1' pattern, modem is recommended  to work on un-standard packet mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONSECUTIVE_ZERO</td><td>2</td><td align="left">
<ul><li>
If preamble has more than 32-bit  consecutive '0' pattern, modem is recommended  work on un-standard packet mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RANDOM</td><td>3</td><td align="left">
<ul><li>
If preamble is random data, modem is  recommended to work on un-standard packet mode.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_RAW_CONTROL%3ARAWGAIN">RAWGAIN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Raw data MA filter gain.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Gain = 8.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Gain = 4.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
Gain = 2.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
Gain = 1.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_RAW_EYE">MODEM_RAW_EYE</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x46 ... 0x47</li>
<li>Summary: 11 bit eye-open detector threshold.</li>
<li>Purpose:</li>
<ul><li>
11 bit eye-open detector threshold.</li></ul>
<li>Defaults: 0x00, 0xa3</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_RAW_EYE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x46</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="3">RAWEYE[10:8]</td>
</tr>
<tr><td>0x47</td>
<td colspan="8">RAWEYE[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x46</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="3">0x0</td>
</tr>
<tr><td>0x47</td>
<td colspan="8">0xa3</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_RAW_EYE">MODEM_RAW_EYE</a><ul>
<li><a name="field-MODEM_RAW_EYE%3ARAWEYE">RAWEYE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Eye-open detector threshold.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_ANT_DIV_MODE">MODEM_ANT_DIV_MODE</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x48</li>
<li>Summary: Antenna diversity mode settings.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic Antenna Diversity (AntDiv) functionality.     During AntDiv operation, the signal strength on two spatially-separated antennas is evaluated    and the stronger antenna is selected for reception over the remainder of the packet,     thus improving link quality in the presence of fading due to multi-path propagation.      This property configures various control bits for the AntDiv algorithm.    </li><li>
AntDiv functionality is only possible during reception of a packet with a Standard Preamble (i.e., 1010 or 0101 pattern).    </li><li>
Enabling the AntDiv algorithm creates the signals required for control of an external RF switch, but does not output them on GPIO pin(s).     It remains necessary to additionally configure the appropriate GPIO pin(s) to output the ANTENNA_1_SW and ANTENNA_2_SW control signals.    </li><li>
As the stronger antenna is not known prior to the arrival of the packet,    the AntDiv algorithm toggles between antennas with a period determined by the ANWAIT parameter.     This toggling action continues until a PREAMBLE_VALID signal is detected on one of the antennas.    </li><li>
The RSSI level for that antenna is evaluated and stored in memory.     The algorithm then briefly selects the alternate antenna and again evaluates the RSSI level.     The two RSSI levels are compared and the chip selects the stronger antenna for the remainder of the packet.    </li><li>
As there may be some slight loss of bit synchronization during the antenna switching process,    the chip qualifies the Preamble for a second time after selection of the good antenna.     During this 2<sup>nd</sup> phase evaluation, the Preamble detection threshold is reduced to a smaller value as specified in the <a href="#field-MODEM_ANT_DIV_CONTROL%3AANT2PM_THD">MODEM_ANT_DIV_CONTROL:ANT2PM_THD</a>
 parameter.    </li><li>
If the signal strength on the 1<sup>st</sup> antenna is sufficiently strong,    there is no need to evaluate the signal strength on the alternate antenna as no further improvement in link quality would be gained by selecting an even stronger signal.     In such a case, the evaluation phase on the 2<sup>nd</sup> antenna may be skipped entirely, as controlled by the SKIP2PH and SKIP2PHTH parameters. </li></ul>
<li>Defaults: 0x02</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_ANT_DIV_MODE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x48</td>
<td colspan="2">SWANT_TIMER</td>
<td colspan="1">BYP1P5</td>
<td colspan="1">SKIP2PH</td>
<td colspan="1">SKIP2PHTH</td>
<td colspan="3">ANWAIT</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x48</td>
<td colspan="2">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="3">0x2</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_ANT_DIV_MODE">MODEM_ANT_DIV_MODE</a><ul>
<li><a name="field-MODEM_ANT_DIV_MODE%3ASWANT_TIMER">SWANT_TIMER</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the number of bit periods to wait for the RSSI value to stabilize during the 2<sup>nd</sup> phase antenna evaluation of the AntDiv algorithm.    </li><li>
Some amount of delay is necessary to allow the new signal level on the 2<sup>nd</sup> antenna to travel through the entire RX chain and to become stable (i.e., RX processing delay).    </li><li>
This field has no effect if not in AntDiv mode of operation.    </li><li>
The delay time (in bit periods) depends upon the amount of averaging performed on the RSSI signal     (selected by the <a href="#field-MODEM_ANT_DIV_CONTROL%3AMATAP">MODEM_ANT_DIV_CONTROL:MATAP</a>
 bit) and is given by the following formulas:
    <br />[LATEX equation: T = (SWANT\_TIMER \times 2) + 9 bit periods]
(MATAP = 0)
    <br />[LATEX equation: T = (SWANT\_TIMER \times 2) + 13 bit periods]
(MATAP = 1) </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
9 bit periods (MATAP = 0), 13 bit periods (MATAP = 1)</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
11 bit periods (MATAP = 0), 15 bit periods (MATAP = 1)</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
13 bit periods (MATAP = 0), 17 bit periods (MATAP = 1)</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
15 bit periods (MATAP = 0), 19 bit periods (MATAP = 1)</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_ANT_DIV_MODE%3ABYP1P5">BYP1P5</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enables/disables a bias against the 2<sup>nd</sup> phase antenna evaluation.    </li><li>
By definition, a PREAMBLE_VALID signal was detected during the initial (1<sup>st</sup> phase) antenna evaluation,    and indicates the signal strength on that antenna is likely sufficient to receive the packet.     With this parameter, the chip may be configured to select the alternate antenna only if the 2<sup>nd</sup> phase antenna evaluation exceeds the signal strength on the 1<sup>st</sup> antenna by the selected amount of bias. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Bias = 0 dB (2<sup>nd</sup> antenna will be selected if its signal strength exceeds the 1<sup>st</sup> antenna by any amount).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Bias = 1.5 dB (2<sup>nd</sup> antenna will be selected if its signal strength exceeds the 1<sup>st</sup> antenna by more than 1.5 dB).</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_ANT_DIV_MODE%3ASKIP2PH">SKIP2PH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enables skipping of the 2<sup>nd</sup> phase of antenna evaluation on packets where the relative signal strength    of the 1<sup>st</sup> phase of antenna evaluation exceeds the threshold value selected in SKIP2PHTH,    thus reducing packet acquisition time.
    </li><li>
If the signal strength of the 1<sup>st</sup> phase of antenna evaluation does not exceed the threshold value,     the AntDiv algorithm proceeds with the 2<sup>nd</sup> phase of antenna evaluation. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
The AntDiv algorithm always evaluates the signal strength on both antennas.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
The AntDiv algorithm evaluates the signal strength on the initial antenna     (i.e., the antenna on which a PREAMBLE_VALID signal is first detected),    but skips evaluation of the alternate antenna when the relative signal strength     (above background noise level) exceeds the threshold specified in SKIP2PHTH.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_ANT_DIV_MODE%3ASKIP2PHTH">SKIP2PHTH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the signal strength threshold for determining when the 2<sup>nd</sup> phase of antenna evaluation may be skipped.    </li><li>
This threshold is not an absolute value, but is a relative value measured between the RSSI on the initial antenna     (i.e., on which the 1<sup>st</sup> PREAMBLE_VALID indication was found) and the RSSI value on the previous antenna     (presumably taken on noise prior to the arrival of the packet).      As a result, this value serves as an approximate "dB above background noise level" threshold.
    </li><li>
This parameter has no effect if the SKIP2PH bit is not also set.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
16 dB threshold is set for skipping 2<sup>nd</sup> phase antenna detection.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
11 dB threshold is set for skipping 2<sup>nd</sup> phase antenna detection.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_ANT_DIV_MODE%3AANWAIT">ANWAIT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Configures the time period between toggling selection of antennas prior to arrival of the packet.      (Periodic toggling is necessary during the initial search phase as the stronger antenna is not known prior to arrival of the packet.)    </li><li>
This field has no effect if not in AntDiv mode of operation.    </li><li>
The time period between antenna toggling is in increments of bit periods, and depends upon whether AFC is enabled in <a href="#field-MODEM_AFC_GAIN%3AENAFC">MODEM_AFC_GAIN:ENAFC</a>
 according to the following formulas:
<br />[LATEX equation: T = (ANWAIT + 2) \times 4 + 3 bit periods]
 (AFC enabled)
<br />[LATEX equation: T = (ANWAIT + 2) \times 2 + 3 bit periods]
 (AFC disabled)
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_ANT_DIV_CONTROL">MODEM_ANT_DIV_CONTROL</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x49</li>
<li>Summary: Specifies controls for the Antenna Diversity algorithm.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic Antenna Diversity (AntDiv) functionality.  This property configures various control bits for the AntDiv algorithm.
    </li><li>
Please refer to the text description for <a href="#prop-MODEM_ANT_DIV_MODE">MODEM_ANT_DIV_MODE</a>
 for more details regarding the Antenna Diversity functionality. </li></ul>
<li>Defaults: 0x80</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_ANT_DIV_CONTROL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x49</td>
<td colspan="4">ANT2PM_THD</td>
<td colspan="1">MATAP</td>
<td colspan="2">ANTDIV</td>
<td colspan="1">RESERVED</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x49</td>
<td colspan="4">0x8</td>
<td colspan="1">0x0</td>
<td colspan="2">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_ANT_DIV_CONTROL">MODEM_ANT_DIV_CONTROL</a><ul>
<li><a name="field-MODEM_ANT_DIV_CONTROL%3AANT2PM_THD">ANT2PM_THD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Some slight loss of bit synchronization may be introduced during the antenna switching process.    As a result, it is necessary to re-acquire bit timing and re-qualify the Preamble after final selection of the best antenna.    </li><li>
During this re-qualification process, the Preamble detection threshold is reduced     (from the value specified in the <a href="#field-PREAMBLE_CONFIG_STD_1%3ARX_THRESH">PREAMBLE_CONFIG_STD_1:RX_THRESH</a>
 field) to the smaller value specified in the ANT2PM_THD parameter.    </li><li>
This field has no effect if not in AntDiv mode of operation. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
<li><a name="field-MODEM_ANT_DIV_CONTROL%3AMATAP">MATAP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Configures the amount of averaging performed on the RSSI measurement by selecting the number of taps for a moving average.
    </li><li>
Greater averaging allows for reduced noise variation on the measured RSSI value, but results in a longer required measurement time.
    </li><li>
This bit has no effect if not in AntDiv mode of operation. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Moving average filter tap length is 8*Tb prior to acquisition of the first PREAMBLE_VALID signal, and 4*Tb thereafter. </li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Moving average filter tap length is 8*Tb. </li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_ANT_DIV_CONTROL%3AANTDIV">ANTDIV</a>
<dl><dt>Description:</dt><dd>
<ul><li>
"Enables/disables operation of the AntDiv algorithm, resulting in generation of control signals appropriate for control of an antenna switch.                </li><li>
GPIO pin(s) must be additionally configured using <a href="#cmd-GPIO_PIN_CFG"><code>GPIO_PIN_CFG</code></a>
 to output the ANTENNA_1_SW and ANTENNA_2_SW control signals generated by the AntDiv algorithm.                </li><li>
The functionality of the ANTENNA_1_SW and ANTENNA_2_SW control signals also depends upon the operating mode of the chip (i.e., in RX mode, non-RX mode, or SLEEP mode). </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">RX_AUTO</td><td>2</td><td align="left">
<ul><li>
RX state: ANTENNA_1_SW and ANTENNA_2_SW = AntDiv algorithm               </li><li>
Non-RX state: ANTENNA_1_SW=1 and ANTENNA_2_SW = 0               </li><li>
SLEEP state:  ANTENNA_1_SW=0 and ANTENNA_2_SW=0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">FIXED</td><td>0</td><td align="left">
<ul><li>
RX state: ANTENNA_1_SW=1 and ANTENNA_2_SW=0               </li><li>
Non-RX state: ANTENNA_1_SW=1 and ANTENNA_2_SW = 0               </li><li>
SLEEP state:  ANTENNA_1_SW=0 and ANTENNA_2_SW=0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">FIXED_INV</td><td>1</td><td align="left">
<ul><li>
RX state: ANTENNA_1_SW=1 and ANTENNA_2_SW=0
              </li><li>
Non-RX state: ANTENNA_1_SW=0 and ANTENNA_2_SW = 1
              </li><li>
SLEEP state:  ANTENNA_1_SW=0 and ANTENNA_2_SW=0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">AUTO</td><td>2</td><td align="left">
<ul><li>
RX state: ANTENNA_1_SW and ANTENNA_2_SW = AntDiv algorithm
              </li><li>
Non-RX state: ANTENNA_1_SW and ANTENNA_2_SW = Selected Antenna
              </li><li>
SLEEP state:  ANTENNA_1_SW=0 and ANTENNA_2_SW=0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">AUTO_INV</td><td>3</td><td align="left">
<ul><li>
RX state: ANTENNA_1_SW and ANTENNA_2_SW = AntDiv algorithm
              </li><li>
Non-RX state: ANTENNA_1_SW and ANTENNA_2_SW = Inverse of selected Antenna
              </li><li>
SLEEP state:  ANTENNA_1_SW=0 and ANTENNA_2_SW=0.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_ANT_DIV_CONTROL%3ARESERVED">RESERVED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Reserved bits (should always be written to 0).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x4a</li>
<li>Summary: Configures the RSSI threshold. </li>
<li>Purpose:</li>
<ul><li>
Selects the threshold for Clear Channel Assessment (CCA) and generation of the RSSI interrupt.
    </li><li>
If the Current RSSI value is above this threshold, a GPIO pin configured to output the CCA signal will be high.
    </li><li>
If the Current RSSI value crosses above this threshold, the RSSI interrupt will be generated. </li><li>
If enabled in the <a href="#prop-MODEM_RSSI_CONTROL">MODEM_RSSI_CONTROL</a>
 property,    the Latched RSSI value may also be compared against this threshold.     The purpose of the comparison is to determine if the Latched RSSI value is below     (not above) the threshold;    if so, the chip proceeds to the specified <a href="#field-START_RX%3ANEXT_STATE1%3ARXTIMEOUT_STATE">START_RX:NEXT_STATE1:RXTIMEOUT_STATE</a>
 and generates a PREAMBLE_INVALID interrupt.</li></ul>
<li>Defaults: 0xff</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_RSSI_THRESH</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x4a</td>
<td colspan="8">RSSI_THRESH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x4a</td>
<td colspan="8">0xff</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a><ul>
<li><a name="field-MODEM_RSSI_THRESH%3ARSSI_THRESH">RSSI_THRESH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects threshold for Clear Channel Assessment and generation of the RSSI interrupt (based upon comparison with the Current RSSI value).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_RSSI_JUMP_THRESH">MODEM_RSSI_JUMP_THRESH</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x4b</li>
<li>Summary: Configures the RSSI Jump Detection threshold.</li>
<li>Purpose:</li>
<ul><li>
The chip provides the ability to detect a jump change in RSSI, and to take action as a result.    Please refer to <a href="#prop-MODEM_RSSI_CONTROL2">MODEM_RSSI_CONTROL2</a>
 for more details regarding configuration of RSSI Jump Detection functionality.
    </li><li>
This property configures the threshold value for RSSI Jump Detection, in steps of 1dB.    If the change in RSSI level (measured over a configurable amount of time) exceeds this threshold value,    an RSSI Jump Detect interrupt event will be generated. </li></ul>
<li>Defaults: 0x0c</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_RSSI_JUMP_THRESH</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x4b</td>
<td>0</td>
<td colspan="7">RSSIJMPTHD</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x4b</td>
<td>0x0</td>
<td colspan="7">0xc</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_RSSI_JUMP_THRESH">MODEM_RSSI_JUMP_THRESH</a><ul>
<li><a name="field-MODEM_RSSI_JUMP_THRESH%3ARSSIJMPTHD">RSSIJMPTHD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Sets the threshold value for RSSI Jump Detection, in steps of 1dB.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_RSSI_CONTROL">MODEM_RSSI_CONTROL</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x4c</li>
<li>Summary: Control of the averaging modes and latching time for reporting RSSI value(s).</li>
<li>Purpose:</li>
<ul><li>
Selects if the RSSI value is latched, and at what point in the packet it is latched.     The Latched RSSI value may be read by a Fast Response Register, or returned by the <a href="#cmd-GET_MODEM_STATUS"><code>GET_MODEM_STATUS</code></a>
 command.
    </li><li>
o	Selects the number of bit periods over which the RSSI value is measured or averaged.
    </li><li>
Selects if the Latched RSSI value is compared against the <a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a>
     value, for the purpose of exiting to the RXTIMEOUT_STATE if below threshold.</li></ul>
<li>Defaults: 0x01</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_RSSI_CONTROL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x4c</td>
<td>0</td>
<td>0</td>
<td colspan="1">CHECK_THRESH_AT_LATCH</td>
<td colspan="2">AVERAGE</td>
<td colspan="3">LATCH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x4c</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="2">0x0</td>
<td colspan="3">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_RSSI_CONTROL">MODEM_RSSI_CONTROL</a><ul>
<li><a name="field-MODEM_RSSI_CONTROL%3ACHECK_THRESH_AT_LATCH">CHECK_THRESH_AT_LATCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If this bit is enabled, the Latched RSSI value is compared against the <a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a>
 value.               If the Latched RSSI is below threshold, the chip will transition to the specified               <a href="#arg-START_RX%3ARXTIMEOUT_STATE">START_RX:RXTIMEOUT_STATE</a>
 and the INVALID_PREAMBLE interrupt will be asserted.              If the Latched RSSI is above threshold, the chip will continue reception. </li><li>
The Latched RSSI exceeding the threshold will not generate an RSSI interrupt event; the RSSI interrupt                       is generated by the Current RSSI exceeding the threshold.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Disable RSSI threshold check after latch.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Enable RSSI threshold check after latch.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_RSSI_CONTROL%3AAVERAGE">AVERAGE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
"Selects the number of bit periods over which the RSSI value is measured and averaged.                </li><li>
The setting of this bit affects both Current RSSI and Latched RSSI values.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">AVERAGE4</td><td>0</td><td align="left">
<ul><li>
The RSSI value is updated at 1*Tb bit period intervals but always reflects the average value over the previous 4*Tb bit periods. </li></ul>
</td></tr>
<tr valign="top"><td align="left">AVERAGE2</td><td>1</td><td align="left">
<ul><li>
The RSSI value is updated at 1*Tb bit period intervals but always reflects the average value over the previous 2*Tb bit periods.</li></ul>
</td></tr>
<tr valign="top"><td align="left">BIT1</td><td>2</td><td align="left">
<ul><li>
The RSSI value is updated every 1*Tb bit period.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SAMPLE1</td><td>3</td><td align="left">
<ul><li>
The RSSI value is updated every 1*Ts period (where Ts is the period of the RXDATA oversampling clock). When selected, the latching               instant is no longer set by the LATCH field but instead specified by the <a href="#prop-MODEM_FAST_RSSI_DELAY">MODEM_FAST_RSSI_DELAY</a>
.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_RSSI_CONTROL%3ALATCH">LATCH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the time in the packet at which the Latched RSSI value is latched.
              </li><li>
Certain latching instants are available only if averaging is enabled by setting AVERAGE = 0.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Latch is disabled.  The returned value of the Latched RSSI will always read 0.</li></ul>
</td></tr>
<tr valign="top"><td align="left">PREAMBLE</td><td>1</td><td align="left">
<ul><li>
Latches RSSI at Preamble detect.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SYNC</td><td>2</td><td align="left">
<ul><li>
Latches RSSI at Sync Word detect.</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_STATE1</td><td>3</td><td align="left">
<ul><li>
Latches RSSI at 4*Tb after RX is enabled (7*Tb if AVERAGE = 0).</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_STATE2</td><td>4</td><td align="left">
<ul><li>
(only with AVERAGE=0) Latches RSSI at 11*Tb after RX is enabled. (3*Tb garbage + 8*Tb)</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_STATE3</td><td>5</td><td align="left">
<ul><li>
  (only with AVERAGE=0) Latches RSSI at 15*Tb after RX is enabled. (3*Tb garbage + 12*Tb)</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_STATE4</td><td>6</td><td align="left">
<ul><li>
(only with AVERAGE=0) Latches RSSI at 19*Tb after RX is enabled. (3*Tb garbage + 16*Tb)</li></ul>
</td></tr>
<tr valign="top"><td align="left">RX_STATE5</td><td>7</td><td align="left">
<ul><li>
(only with AVERAGE=0) Latches RSSI at 23*Tb after RX is enabled. (3*Tb garbage + 20*Tb)</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_RSSI_CONTROL2">MODEM_RSSI_CONTROL2</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x4d</li>
<li>Summary: RSSI Jump Detection control.</li>
<li>Purpose:</li>
<ul><li>
The chip provides the ability to detect a jump change in RSSI, and to take action as a result.     This functionality may be useful in detection of interference or a "collision" from a secondary incoming packet.    </li><li>
This property configures various aspects of RSSI Jump Detection.     The chip is capable of detecting a jump change in RSSI in either direction (i.e., either a signal increase or a signal decrease).     Both polarities of jump detection may be enabled simultaneously, resulting in detection of a Jump-Up or Jump-Down.
    </li><li>
The change in RSSI must exceed the threshold value set in <a href="#prop-MODEM_RSSI_JUMP_THRESH">MODEM_RSSI_JUMP_THRESH</a>
 before being reported as an RSSI Jump event.    The chip may be configured to reset the RX state machine upon detection of an RSSI Jump,     and thus to automatically begin re-acquisition of the packet.      The chip may also be configured to generate an interrupt,    as enabled through the <a href="#field-INT_CTL_MODEM_ENABLE%3ARSSI_JUMP_EN">INT_CTL_MODEM_ENABLE:RSSI_JUMP_EN</a>
 bit.    </li><li>
This functionality is intended to detect an abrupt change in RSSI level,     and to not respond to a slow gradual change in RSSI level.      This is accomplished by comparing the difference in RSSI level over a programmable time period (selected by the JMPDLYLEN parameter).      In this fashion, the chip effectively evaluates the slope of the change in RSSI level.    </li><li>
The arrival of a desired packet (i.e., the transition from receiving noise to receiving a valid signal) will likely be detected as an RSSI Jump event.      For this reason, it is recommended to enable this feature in mid-packet (i.e., after signal qualification such as PREAMBLE_VALID.) </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_RSSI_CONTROL2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x4d</td>
<td>0</td>
<td>0</td>
<td colspan="1">RSSIJMP_DWN</td>
<td colspan="1">RSSIJMP_UP</td>
<td colspan="1">ENRSSIJMP</td>
<td colspan="1">JMPDLYLEN</td>
<td colspan="1">ENJMPRX</td>
<td>0</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x4d</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_RSSI_CONTROL2">MODEM_RSSI_CONTROL2</a><ul>
<li><a name="field-MODEM_RSSI_CONTROL2%3ARSSIJMP_DWN">RSSIJMP_DWN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enables/disables detection of an RSSI jump in the downwards direction.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Detection of RSSI Jump-Down is disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Detection of RSSI Jump-Down is enabled.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_RSSI_CONTROL2%3ARSSIJMP_UP">RSSIJMP_UP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enables/disables detection of an RSSI jump in the upwards direction</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Detection of RSSI Jump-Up is disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Detection of RSSI Jump-Up is enabled.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_RSSI_CONTROL2%3AENRSSIJMP">ENRSSIJMP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enables/disables RSSI jump detection.     This bit must be enabled before the jump direction bits (RSSIJMP_UP and RSSIJMP_DWN) have effect.    </li><li>
An RSSI Jump Detect interrupt event will be generated when the RSSI difference    (measured between time intervals of 2*Tb or 4*Tb) exceeds the <a href="#prop-MODEM_RSSI_JUMP_THRESH">MODEM_RSSI_JUMP_THRESH</a>
 value. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
RSSI Jump Detection is disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
RSSI Jump Detection is enabled.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_RSSI_CONTROL2%3AJMPDLYLEN">JMPDLYLEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the time period over which the difference in RSSI level is measured.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
RSSI Jump Detection is measured between time intervals of 2*Tb.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
RSSI Jump Detection is measured between time intervals of 4*Tb.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_RSSI_CONTROL2%3AENJMPRX">ENJMPRX</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, RSSI jumping detection will force  RX machine to reset.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
RX state machine will not be reset upon RSSI Jump Detect.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
RX state machine will be reset upon RSSI Jump Detect. </li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_RSSI_COMP">MODEM_RSSI_COMP</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x4e</li>
<li>Summary: RSSI compensation value.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for returning the Received Signal Strength Indication (RSSI) value through the <a href="#cmd-GET_MODEM_STATUS"><code>GET_MODEM_STATUS</code></a>
 command.     The returned RSSI value is an 8-bit unsigned word whose value is proportional to the strength of the received signal.    The RSSI value returned by the <a href="#cmd-GET_MODEM_STATUS"><code>GET_MODEM_STATUS</code></a>
 command is in increments of approximately 0.5 dB per bit.	</li><li>
Silicon Labs cannot be aware of the exact RX matching topology and matching component values in use by all customers.    Customer applications may vary in the presence or absence of preselection filtering, an external LNA, or RF switch.    As a result, Silicon Labs does not guarantee that a given RSSI value corresponds to an exact RF input power level (in dBm).
	</li><li>
The chip provides for an RSSI compensation (or offset) value,    in the event that the user desires to calibrate the returned RSSI value to an exact RF input level.     The value of the <a href="#prop-MODEM_RSSI_COMP">MODEM_RSSI_COMP</a>
 property is added to the internally measured RSSI level,    and thus changes the RSSI value returned by the <a href="#cmd-GET_MODEM_STATUS"><code>GET_MODEM_STATUS</code></a>
 command.     The <a href="#prop-MODEM_RSSI_COMP">MODEM_RSSI_COMP</a>
 value is in increments of 1 dB,    and thus changing the compensation value by 1 code will result in the RSSI value returned by the <a href="#cmd-GET_MODEM_STATUS"><code>GET_MODEM_STATUS</code></a>
 command changing by 2 codes.    The returned RSSI value may be converted to an approximate RF input level (in dBm) by the following formula:
    <br />[LATEX equation: RF\_LEVEL\_dBm = \frac{RSSI\_VALUE}{2}-MODEM\_RSSI\_COMP-70]

	</li><li>
The default value of the <a href="#prop-MODEM_RSSI_COMP">MODEM_RSSI_COMP</a>
 property is 0x40 = 64 decimal.      This is a sufficient offset value such that the returned RSSI value for measuring noise (i.e., no signal) is slightly greater than zero.     A larger compensation value will adjust the returned RSSI value upwards, and a lower value will adjust the RSSI value downwards. </li></ul>
<li>Defaults: 0x32</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_RSSI_COMP</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x4e</td>
<td>0</td>
<td colspan="7">RSSI_COMP</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x4e</td>
<td>0x0</td>
<td colspan="7">0x32</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_RSSI_COMP">MODEM_RSSI_COMP</a><ul>
<li><a name="field-MODEM_RSSI_COMP%3ARSSI_COMP">RSSI_COMP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Compensation (or offset) to the measured RSSI value.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_DC_CONTROL">MODEM_DC_CONTROL</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x4f</li>
<li>Summary: Modem DC cancellation controls.</li>
<li>Purpose:</li>
<ul><li>
Modem DC cancellation controls.</li></ul>
<li>Defaults: 0x03</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_DC_CONTROL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x4f</td>
<td>0</td>
<td>0</td>
<td colspan="1">DC_FOLLOW</td>
<td colspan="1">DC_RST</td>
<td colspan="1">DC_FREEZ</td>
<td colspan="3">DC_GEAR</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x4f</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="3">0x3</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_DC_CONTROL">MODEM_DC_CONTROL</a><ul>
<li><a name="field-MODEM_DC_CONTROL%3ADC_FOLLOW">DC_FOLLOW</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
No effect.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
DC Following is turned on. In this mode,  when a valid sync word is detected, the current DC offset is saved,     this value is then used as the initial DC offset for next RX.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DC_CONTROL%3ADC_RST">DC_RST</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
No effect.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Reset DC value.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DC_CONTROL%3ADC_FREEZ">DC_FREEZ</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
No effect.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
freeze estimated DC value to the current filter output.         If both dc-rst and dc-frz are set, the digital DC cancellation filter is skipped.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DC_CONTROL%3ADC_GEAR">DC_GEAR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
the forgetting factor in the integrator inside DC cancellation.         Decimating rate is 2^ndec0. ndec0 should be set to 0 for non-OOK modem. Effective forgetting factor is 2^(-9+dc_gear)</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_RAW_SEARCH2">MODEM_RAW_SEARCH2</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x50</li>
<li>Summary: Defines and controls the search period length for the Moving Average and Min-Max detectors.</li>
<li>Purpose:</li>
<ul><li>
The chip internally implements two different types of demodulator circuits:  a synchronous demodulator and an asynchronous demodulator.  The synchronous demodulator is typically used for reception of (G)FSK signals with a standard Preamble and packet structure, while the asynchronous demodulator is typically used for reception of (G)FSK signals with non-standard Preamble and packet structures, as well as for all OOK signals.    </li><li>
Within the asynchronous demodulator, several different types of detectors may be selected to establish the voltage reference level for slicing the received data bits, including a moving average filter, a peak detector, and a min-max detector.  The type of detector used in the asynchronous demodulator is selected in the MODEM_OOK_MISC property.
    The moving average filter and min-max detectors both establish the slicing threshold level based upon the values of the previous data bits.  This property is used to configure the number of previous data bits (i.e., search window length) over which the moving average and min-max detectors establish the slicing threshold level.    </li><li>
The search period length may be configured for different values before gear switching and after gear switching.  A shorter search period window is typically selected prior to gear switching, as the Preamble field usually contains regular bit transitions and fast acquisition is desirable.  A longer search period window is typically selected after gear switching, as the Payload fields may contain highly unbalanced data and irregular bit transitions; as a result, a longer search period may be required to capture both polarities of data bits for accurate establishment of the slicing threshold level.    </li><li>
Alternatively, the slicing threshold search engine may be "frozen" upon gear switching, such that no further adjustments to the slicing threshold level are made across the remainder of the packet.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_RAW_SEARCH2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x50</td>
<td colspan="1">SCH_FRZEN</td>
<td colspan="1">RAWFLT_SEL</td>
<td colspan="3">SCHPRD_HI</td>
<td colspan="3">SCHPRD_LOW</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x50</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="3">0x0</td>
<td colspan="3">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_RAW_SEARCH2">MODEM_RAW_SEARCH2</a><ul>
<li><a name="field-MODEM_RAW_SEARCH2%3ASCH_FRZEN">SCH_FRZEN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether the Moving Average or Min-Max slicing threshold search engine is frozen upon gear switching. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Do not freeze the Moving Average or Min-Max slicing threshold search engine upon switching to low gear.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Freeze the Moving Average or Min-Max slicing threshold search engine upon switching to low gear.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_RAW_SEARCH2%3ARAWFLT_SEL">RAWFLT_SEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, enable 4-tap MA for raw data filter.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable raw data filter to use the 4-tap MA filter..</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable raw data filter to use the 4-tap MA filter..</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_RAW_SEARCH2%3ASCHPRD_HI">SCHPRD_HI</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the search period window length (in bit periods) over which the Moving Average filter or Min-Max detector establishes the slicing threshold level, prior to gear switching (i.e., during high gear).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SEARCH_2TB</td><td>0</td><td align="left">
<ul><li>
Search window period = 2*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_3TB</td><td>1</td><td align="left">
<ul><li>
Search window period = 3*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_4TB</td><td>2</td><td align="left">
<ul><li>
Search window period = 4*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_5TB</td><td>3</td><td align="left">
<ul><li>
Search window period = 5*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_8TB</td><td>4</td><td align="left">
<ul><li>
Search window period = 8*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_12TB</td><td>5</td><td align="left">
<ul><li>
Search window period = 12*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_14TB</td><td>6</td><td align="left">
<ul><li>
Search window period = 14*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_16TB</td><td>7</td><td align="left">
<ul><li>
Search window period = 16*TB</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_RAW_SEARCH2%3ASCHPRD_LOW">SCHPRD_LOW</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the search period window length (in bit periods) over which the Moving Average filter or Min-Max detector establishes the slicing threshold level, after gear switching (i.e., during low gear).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SEARCH_2TB</td><td>0</td><td align="left">
<ul><li>
Search window period = 2*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_3TB</td><td>1</td><td align="left">
<ul><li>
Search window period = 3*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_4TB</td><td>2</td><td align="left">
<ul><li>
Search window period = 4*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_5TB</td><td>3</td><td align="left">
<ul><li>
Search window period = 5*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_8TB</td><td>4</td><td align="left">
<ul><li>
Search window period = 8*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_12TB</td><td>5</td><td align="left">
<ul><li>
Search window period = 12*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_14TB</td><td>6</td><td align="left">
<ul><li>
Search window period = 14*TB</li></ul>
</td></tr>
<tr valign="top"><td align="left">SEARCH_16TB</td><td>7</td><td align="left">
<ul><li>
Search window period = 16*TB</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_CLKGEN_BAND">MODEM_CLKGEN_BAND</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x51</li>
<li>Summary: Select PLL Synthesizer output divider ratio as a function of frequency band.</li>
<li>Purpose:</li>
<ul><li>
Selects the divide ratio of the configurable divider at the output of the PLL Synthesizer as a function of the desired operating frequency band.
    </li><li>
Configures the PLL Synthesizer for High Performance or Low Power operating mode, allowing a tradeoff between tuning resolution and current consumption.</li></ul>
<li>Defaults: 0x08</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_CLKGEN_BAND</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x51</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">FORCE_SY_RECAL</td>
<td colspan="1">SY_SEL</td>
<td colspan="3">BAND</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x51</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x1</td>
<td colspan="3">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_CLKGEN_BAND">MODEM_CLKGEN_BAND</a><ul>
<li><a name="field-MODEM_CLKGEN_BAND%3AFORCE_SY_RECAL">FORCE_SY_RECAL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Controls whether synthesizer recalibration is forced during state transitions if the frequency is not changed.                e.g. RX to RX between packets on the same frequency.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">FORCE</td><td>0</td><td align="left">
<ul><li>
Force Recalibration.</li></ul>
</td></tr>
<tr valign="top"><td align="left">SKIP</td><td>1</td><td align="left">
<ul><li>
Skip recalibration if frequency is not changed.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_CLKGEN_BAND%3ASY_SEL">SY_SEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the value of the fixed prescaler modulus in the PLL divider feedback path,        allowing a tradeoff between improved tuning resolution and synthesizer quantization noise at the expense of slightly increased current consumption.         The published formula for calculating <a href="#prop-FREQ_CONTROL_INTE">FREQ_CONTROL_INTE</a>
 and <a href="#prop-FREQ_CONTROL_FRAC">FREQ_CONTROL_FRAC</a>
 assumes this bit is set to '1';         contact Silicon Labs for assistance with frequency calculations when clearing this bit.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Low-power mode (fixed prescaler = Div-by-4).         Approximately 200 uA less current than High Performance mode, but with coarser tuning resolution of the PLL Synthesizer.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
High Performance mode (fixed prescaler = Div-by-2).</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_CLKGEN_BAND%3ABAND">BAND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the PLL Synthesizer output divider ratio appropriate for the desired frequency band.         The VCO in the PLL Synthesizer operates at approximately 3.6 GHz;         operation across a wide range of frequency bands is obtained by switching in a configurable divider (OUTDIV) at the output of the PLL Synthesizer,        e.g., OUTDIV = Div-by-4 for 900 MHz band.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">FVCO_DIV_4</td><td>0</td><td align="left">
<ul><li>
Output is FVCO/4.</li></ul>
</td></tr>
<tr valign="top"><td align="left">FVCO_DIV_6</td><td>1</td><td align="left">
<ul><li>
Output is FVCO/6.</li></ul>
</td></tr>
<tr valign="top"><td align="left">FVCO_DIV_8</td><td>2</td><td align="left">
<ul><li>
Output is FVCO/8.</li></ul>
</td></tr>
<tr valign="top"><td align="left">FVCO_DIV_12</td><td>3</td><td align="left">
<ul><li>
Output is FVCO/12.</li></ul>
</td></tr>
<tr valign="top"><td align="left">FVCO_DIV_16</td><td>4</td><td align="left">
<ul><li>
Output is FVCO/16.</li></ul>
</td></tr>
<tr valign="top"><td align="left">FVCO_DIV_24</td><td>5</td><td align="left">
<ul><li>
Output is FVCO/24.</li></ul>
</td></tr>
<tr valign="top"><td align="left">FVCO_DIV_24_2</td><td>6</td><td align="left">
<ul><li>
Output is FVCO/24.</li></ul>
</td></tr>
<tr valign="top"><td align="left">FVCO_DIV_24_3</td><td>7</td><td align="left">
<ul><li>
Output is FVCO/24.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_RESERVED_20_52">MODEM_RESERVED_20_52</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x52</li>
<li>Summary: Reserved.</li>
<li>Purpose:</li>
<ul><li>
Reserved.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_RESERVED_20_52</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x52</td>
<td colspan="8">RESERVED_20_52</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x52</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_RESERVED_20_52">MODEM_RESERVED_20_52</a><ul>
<li><a name="field-MODEM_RESERVED_20_52%3ARESERVED_20_52">RESERVED_20_52</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reserved_20_52</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_PLL_SETTLE_TIME">MODEM_PLL_SETTLE_TIME</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x53</li>
<li>Summary: Configures an internal timer for the expected PLL Synthesizer settling time.</li>
<li>Purpose:</li>
<ul><li>
After a frequency change or VCO calibration, the PLL Synthesizer requires a certain amount of time to achieve lock (typically about 40 usec).
    </li><li>
The chip does not provide for lock detect circuitry to indicate when the PLL Synthesizer has achieved lock.     Instead, an internal timer is configured with a time period value and the chip is assumed to have achieved lock after expiration of this timer.
    </li><li>
This property determines the length of time allowed for the PLL Synthesizer to obtain lock. This property does not affect the settling time of the PLL Synthesizer;     it simply determines the time delay allowed for PLL settling before sequencing to the next state or operating mode.
    </li><li>
The units of this field are in usec.      Due to some overhead processes in internal firmware, setting a value less than 40 usec (PLL_SETTLE = 0x28) will not result in delay times less than 40 usec.</li></ul>
<li>Defaults: 0x28</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_PLL_SETTLE_TIME</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x53</td>
<td colspan="8">PLL_SETTLE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x53</td>
<td colspan="8">0x28</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_PLL_SETTLE_TIME">MODEM_PLL_SETTLE_TIME</a><ul>
<li><a name="field-MODEM_PLL_SETTLE_TIME%3APLL_SETTLE">PLL_SETTLE</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x28</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_SPIKE_DET">MODEM_SPIKE_DET</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x54</li>
<li>Summary: Configures the threshold for (G)FSK SPike Detection.</li>
<li>Purpose:</li>
<ul><li>
Refer to <a href="#prop-MODEM_DSA_CTRL1">MODEM_DSA_CTRL1</a>
 for an overview of the Signal Arrival Detection (DSA) funciton.
            </li><li>
The DSA circuit contains a block that calculates the difference in phase between adjacent samples in the RX Modem; an excessive difference in the phase of adjacent samples is equivalent to a "spike" in the frequency domain and indicates a noisey or weak signal. This property is used to configure the threshold above which an excessive phase difference is considered a spike.
            </li><li>
The DSA algorithm counts the number of spikes over a programmable search period of time; the signal is considered to have arrived if the spike count value is less than a programmable tolerance limit. THe tolerance limit is set in <a href="#field-MODEM_DSA_CTRL1%3AADJ_SAMP_ERR_TOLERANCE">MODEM_DSA_CTRL1:ADJ_SAMP_ERR_TOLERANCE</a>
, while the length and number of search period windows is set in <a href="#field-MODEM_RAW_SEARCH%3ASCHPRD_HI">MODEM_RAW_SEARCH:SCHPRD_HI</a>
 and <a href="#field-MODEM_DSA_CTRL2%3AARRIVAL_THD">MODEM_DSA_CTRL2:ARRIVAL_THD</a>
.
            </li><li>
This property also allows for rmoval of such detected spikes from teh signal path. When enabled, the Modem replaces the "spike" frequency data sample with a value that is interpolated from the frequency samples on either side of the spike.
            </li><li>
This property is only applicable when receiving a (G)FSK signal and should not be used when receiving an OOK signal.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_SPIKE_DET</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x54</td>
<td colspan="1">SPIKE_DETECT_EN</td>
<td colspan="7">SPIKE_THRESHOLD</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x54</td>
<td colspan="1">0x0</td>
<td colspan="7">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_SPIKE_DET">MODEM_SPIKE_DET</a><ul>
<li><a name="field-MODEM_SPIKE_DET%3ASPIKE_DETECT_EN">SPIKE_DETECT_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enable/Disable bit for the Sike Removal function for (G)FSK signals. When enabled, the RX Modem replaces the frequency sample for the detected "spike" with a value that is interpolated from data samples on either side of the spike.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable (G)FSK Spike Removal Function.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable (G)FSK Spike Removal Function.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_SPIKE_DET%3ASPIKE_THRESHOLD">SPIKE_THRESHOLD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This parameter sets the threshold of phase difference between adjacent samples in the RX Modem, above which the phase difference is considered excessive and to be a "spike". The required value for this parameter depends heavily on RX Modem parameters such as data rate, deviation, and over-sampling rate; Silicon Laboratories recommends use of the value suggested by WDS.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_ONE_SHOT_AFC">MODEM_ONE_SHOT_AFC</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x55</li>
<li>Summary: Configures parameters for th e One Shot AFC function and for BCR timing/acquisition.</li>
<li>Purpose:</li>
<ul><li>
Refer to <a href="#prop-MODEM_DSA_CTRL1">MODEM_DSA_CTRL1</a>
 for an overview of the Signal Arrival Detection (DSA) function.               </li><li>
The chip provides a conventional method of Automatic Frequency Control (AFC) where the frequency error is estimated during Preamble. The estimated frequency error is used to iteratively adjust the frequency of the PLL Synthesizer in a feedback control loop, driving the error towards zero over several bit periods.
              </li><li>
This property provides for a faster AFC adjustement method, in that the frequency error is estimated once after detection of signal arrival. This "one-shot" frequency error estimate is used to provide a one-time adjustment to the PLL Synthesizer frequency, thus eliminating the need for iterative frequency adjustment cycles.
              </li><li>
This property also provides miscellaneous bits for control of Bit Clock Recovery (BCR) timing and acquisition functions.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_ONE_SHOT_AFC</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x55</td>
<td colspan="1">ONESHOT_AFC_EN</td>
<td colspan="1">BCR_ALIGN_EN</td>
<td colspan="1">EST_OSR_EN</td>
<td colspan="1">AFCMA_EN</td>
<td colspan="4">ONESHOT_WAIT_CNT</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x55</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="4">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_ONE_SHOT_AFC">MODEM_ONE_SHOT_AFC</a><ul>
<li><a name="field-MODEM_ONE_SHOT_AFC%3AONESHOT_AFC_EN">ONESHOT_AFC_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Conventional AFC methods require iterative adjustments of the PLL Synthesizer frequency over several bit periods until the frequency error is minimized. If this bit is enabled, a one-time estimate of the frequency error is obtained (using the Min-Max frequency detector) upon detection of signal arrival. This "one-shot" frequency error estimate is used to provide a one-time adjustmenet to the PLL Synthesizer frequency, thus eliminating the need for iterative frequency adjustmenet cycles.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable One shot AFC function.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable One shot AFC function.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_ONE_SHOT_AFC%3ABCR_ALIGN_EN">BCR_ALIGN_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
When this bit is cleared, the BCR circuit operates continuously and thus attempts to acquire bit timing on the noise that is present prior to arrival of the packet. When this bit is set, the BCR circuit is not released to start tracking the data and acquiring bit timing until signal arrival is detected.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Allow BCR tracking prior to signal arrival.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable BCR tracking only after signal arrival.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_ONE_SHOT_AFC%3AEST_OSR_EN">EST_OSR_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The RX modem in th e chip contains a Numerically Controlled Oscillator (NCO) for the purpose of synchronizing a local bit clock to the received data stream. (Please refer to the text descrition for <a href="#prop-MODEM_BCR_NCO_OFFSET">MODEM_BCR_NCO_OFFSET</a>
 for more details regarding the BCR NCO.)
            </li><li>
The free-running frequency of the NCO is normally set to a fixed value (appropriate for the selected data rate) and used throughout the entire packet. However, in the event of receiving a packet with a large error in the data rate, the BCR loop may not be able to maintain tracking without first obtaining a more accurate estimate of the actual received data rate. This compensation is typically needed only when the data rate error is greater than 1%.
            </li><li>
The chip can compensate for data rate error by acquiring a new estimate for the NCO frequency from the received data itself. This new NCO frequency estimate is obtained during the Preamble field, and then used for the remainder of the packet.
            </li><li>
The chip already provides a separate control bit <a href="#field-MODEM_BCR_MISC1%3ARXNCOCOMP">MODEM_BCR_MISC1:RXNCOCOMP</a>
 for obtaining the data rate error estimate upon detection of PREAMBLE_VALID. If the EST_OSR_EN bit is additionally set, the chip then obtains the data rate error estimate at the instant of signal arrival detection (i.e., much more quickly). If the RXNCOCOMP bit is cleared, no data rate error estimation is performed in any fashion.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable data rate error measurement and compensation upon signal arrival detection.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable data rate error measurement and compensation upon signal arrival detection.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_ONE_SHOT_AFC%3AAFCMA_EN">AFCMA_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit enables a Moving Average filter in the signal path used to obtain the estimate of frequency error for the AFC function. The tap length of the MA filter is 4 taps.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable MA filter for frequency error estimator.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable MA filter for frequency error estimator.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_ONE_SHOT_AFC%3AONESHOT_WAIT_CNT">ONESHOT_WAIT_CNT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Adjustment of the PLL Synthesizer frequency by AFC algorithm may result in corruption of several data bits until the new signal frequency propagates completely through the RX signal chain. This parameter defines a programmable delay time, in bit periods. Upon expiration of this delay period, the RX Modem obtains one final estimate of the residual frequency error. This frequency error estimate is not used to further adjust the PLL Synthesizer frequency but is instead used to digitally compensate the BCR and Slicer functions in the RX Modem. AFC compensation is then frozen for the remainder of the packet.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_RSSI_HYSTERESIS">MODEM_RSSI_HYSTERESIS</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x56</li>
<li>Summary: Configures the amount of hysteresis on the RSSI threshold detection function.</li>
<li>Purpose:</li>
<ul><li>
This chip is capable of generating an interrupt event and interrupt status indication when the received signal strength exceeds a threshold level, as configured in <a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a>
.
            </li><li>
The RSSI status bit in the <a href="#reply-GET_INT_STATUS%3AMODEM_STATUS">GET_INT_STATUS:MODEM_STATUS</a>
 response stream reflects the real-time condition of the received signal strength, relative to the programmed RSSI threshold. That is, the RSSI status bit will return a '1' if the RSSI is above the threshold at the time of GIT_INT_STATUS command is issued, but will return a '0' if the RSSI subsequenty drops below the threshold and the <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 command is issued again.
            </li><li>
It is desirable for the RSSI comparator function to have some amount of hysteresis so that the RSSI status output bit does not "chatter" when receiving a signal very near the programmed threshold level.
            </li><li>
This property defines the amount of hysteresis for the RSSI level which is reflected in the <a href="#field-GET_INT_STATUS%3AMODEM_STATUS%3ARSSI">GET_INT_STATUS:MODEM_STATUS:RSSI</a>
 bit.</li></ul>
<li>Defaults: 0xff</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_RSSI_HYSTERESIS</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x56</td>
<td colspan="8">RSSI_HYSTERESIS</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x56</td>
<td colspan="8">0xff</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_RSSI_HYSTERESIS">MODEM_RSSI_HYSTERESIS</a><ul>
<li><a name="field-MODEM_RSSI_HYSTERESIS%3ARSSI_HYSTERESIS">RSSI_HYSTERESIS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Defines the amount of hysteresis for the RSSI level which is reflected in the <a href="#field-GET_INT_STATUS%3AMODEM_STATUS%3ARSSI">GET_INT_STATUS:MODEM_STATUS:RSSI</a>
 bit (i.e., the amount by which the signal strength much drop before the RSSI status bit returns to 0). This parameter adjusts the RSSI hysteresis level in increments of 0.5 dB.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x1</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_RSSI_MUTE">MODEM_RSSI_MUTE</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x57</li>
<li>Summary: Configures muting of the RSSI to avoid false RSSI interrupts.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for generating an RSSI interrupt event when the received signal strength exceeds the threshold level set in <a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a>
.
            </li><li>
It is sometimes possible to observe a false RSSI interrupt (i.e., an RSSI interrupt that indicates the presence of an on-channel signal when in fact no on-channel signal exists). This condition may be caused by enabling the receiver while a strong signal is present in an adjacent or nearby channel. While the undesired signal is not present on the tuned channel, its abrupt "burst-like" envelope (as viewed in the time domain) gives rise to spectral spallter (as viewed in the frequency domain). Sidebands of this spectral splatter can briefly appear as energy on the desired channel, possibly leading to a false RSSI interrupt indication.
            </li><li>
The chip provides a countermeasure against such false RSSI interrupts by only enabling the RSSI hardware after a programmable delay period has expired (i.e., after the transient energy has decayed).
            </li><li>
This property enables this RSSI delay feature, and configures the programmable delay period.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_RSSI_MUTE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x57</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">RSSI_DELAY</td>
<td colspan="3">RSSI_DELAY_CNT</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x57</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="3">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_RSSI_MUTE">MODEM_RSSI_MUTE</a><ul>
<li><a name="field-MODEM_RSSI_MUTE%3ARSSI_DELAY">RSSI_DELAY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If this bit is set, the RSSI circuitry will not be enabled until expiration of the delay period configured in <a href="#field-MODEM_RSSI_MUTE%3ARSSI_DELAY_CNT">MODEM_RSSI_MUTE:RSSI_DELAY_CNT</a>
. If cleared, the RSSI circuitry will be enabled immediately upon entering RX mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
RSSI is enabled immediately upon entering RX mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable RSSI only after delay period expires.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_RSSI_MUTE%3ARSSI_DELAY_CNT">RSSI_DELAY_CNT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This parameter defines the delay period (in bit periods) before the RSSI circuitry is enabled, after entering RX mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_FAST_RSSI_DELAY">MODEM_FAST_RSSI_DELAY</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x58</li>
<li>Summary: Configures the delay for fast RSSI Latching mode.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for latching the RSSI value at programmable points in time in the packet structure. The latching point is configured by the <a href="#field-MODEM_RSSI_CONTROL%3ALATCH">MODEM_RSSI_CONTROL:LATCH</a>
 field, and allows latching upon certain events (e.g., Preamble Detection or Sync Word Detection) or upon expiration of certain timer periods (i.e., 'X' bit periods after entering RX mode).
            </li><li>
Applications that scan channels rapidly desire to assess the RSSI level as quickly as possible. The fastest option that may be selected by the <a href="#field-MODEM_RSSI_CONTROL%3ALATCH">MODEM_RSSI_CONTROL:LATCH</a>
 field is latching at 4*Tb after entering RX mode.
            </li><li>
While it is not feasible to sample and latch the RSSI value immediately upon entering RX mode (due to the time required for the signal to propogate through the entire RX chain), it is possible to configure the chip to latch the RSSI somewhat faster than 4*Tb.
            </li><li>
To access this faster latching option, it is necessary to switch the latching delay timer from counting bit periods (i.e., 1*Tb increments) to counting RX data over-sampling clock periods (i.e., 1*Ts increments). This switch in clock source is accomplished by setting <a href="#field-MODEM_RSSI_CONTROL%3AAVERAGE">MODEM_RSSI_CONTROL:AVERAGE</a>
 = 3 = enum SAMPLE1.
            </li><li>
 When the oversampling clock source is selected by <a href="#field-MODEM_RSSI_CONTROL%3AAVERAGE">MODEM_RSSI_CONTROL:AVERAGE</a>
, this property defines the number of sample clocks (after entering RX mode before the RSSI is latched.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_FAST_RSSI_DELAY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x58</td>
<td colspan="8">FAST_RSSI_DELAY</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x58</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_FAST_RSSI_DELAY">MODEM_FAST_RSSI_DELAY</a><ul>
<li><a name="field-MODEM_FAST_RSSI_DELAY%3AFAST_RSSI_DELAY">FAST_RSSI_DELAY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Defines the number of RX data oversampling clock periods (1*Ts) before RSSI is latched, after entering RX mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_PSM">MODEM_PSM</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x59 ... 0x5a</li>
<li>Summary: Configures the Preamble Sense Mode feature</li>
<li>Purpose:</li>
<ul><li>
Preamble Sense Mode duty cycles the receiver while the radio is searching for a preamble in order to save current consumption. For this feature to work, this property must be nonzero and <a href="#field-START_RX%3ANEXT_STATE1%3ARX_TIMEOUT_STATE">START_RX:NEXT_STATE1:RX_TIMEOUT_STATE</a>
 must be set to RX_IDLE.</li></ul>
<li>Comments (internal):</li>
<ul><li>
TODO: Insert Picture?  Describe the Preamble Sense Mode feature in more detail!</li></ul>
<li>Defaults: 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_PSM</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x59</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="4">IDLE_TIME[11:8]</td>
</tr>
<tr><td>0x5a</td>
<td colspan="8">IDLE_TIME[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x59</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="4">0x0</td>
</tr>
<tr><td>0x5a</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_PSM">MODEM_PSM</a><ul>
<li><a name="field-MODEM_PSM%3AIDLE_TIME">IDLE_TIME</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Putting a 0 in this field will disable the low power preamble search feature.  Otherwise this field                  defines the amount of time to stay in RX_IDLE state when a signal is not detected in RX_STATE as                  determined by the formula: <br />[LATEX equation: _{RX\_IDLE\_TIME\mathit{seconds}} = (\frac{256 \times IDLE\_TIME} {F_{XTAL}})]
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_DSA_CTRL1">MODEM_DSA_CTRL1</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x5b</li>
<li>Summary: Configures parameters for the Signal Arrival Detection circuit block and algorithm.</li>
<li>Purpose:</li>
<ul><li>
The chip contains a circuit block called the Signal Arrival Detector (DSA) which provides alternate methods of qualifying the arrival of a valid signal, apart from the conventional methods of Preamble Detection and RSSI/Clear Channel Assessment.
            </li><li>
These new methods include: detection of the presence of absence of noise-like "spikes" in the demodulated FM signal, verification of the peak-to-peak demodulated FM deviation is within certain boundary limits, and the verification that the signal strength is above a certain programmable threshold.
            </li><li>
The advantage of the DSA is that it can provide validation of the presence of a signal more quickly than with conventional Preamble Detection, allowing operation with shorter Preamble fields.
            </li><li>
This property provides the master Enable/Disable control for the DSA algorithm, and is also used to select the source metric by which the signal is qualified.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_DSA_CTRL1</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x5b</td>
<td colspan="2">QUAL_SOURCE</td>
<td colspan="1">DSA_EN</td>
<td colspan="5">ADJ_SAMP_ERR_TOLERANCE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x5b</td>
<td colspan="2">0x0</td>
<td colspan="1">0x0</td>
<td colspan="5">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_DSA_CTRL1">MODEM_DSA_CTRL1</a><ul>
<li><a name="field-MODEM_DSA_CTRL1%3AQUAL_SOURCE">QUAL_SOURCE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This field selects the source metric by which the DSA algorithm will decide if the signal has arrived.
            </li><li>
0 = Spike Detection qualifier. THe DSA algorithm calculates the difference in phase between adjacent samples in the RX Modem; an excessive difference in phase of adjacent samples is equivalent to a "spike" in the frequency domain and indicates a noisy or weak signal. The DSA algorithm counts the number of spikes over a programmable search period of time; the signal is considered to have arrived if the spike count value is less than a programmable threshold. This option is only applicable when receiving a (G)FSK signal and should not be used when receiving an OOK signal.
            </li><li>
1 = Spike detection and Eye Opening Qualifier. This qualification method logically-ANDs the results from two different qualification methods; the signal is considered to have arrived if both are true. The Spike Detection qualification method is discussed above. The Eye Opening qualification measures the peak-to-peak deviation of the signal over a programmable search period of time, and the signal is considered valid if the deviation remains within a programmable limit window. This option is only applicable when receiving a (G)FSK signal and should not be used when receiving an OOK signal.
            </li><li>
2 = RSSI qualifier. The signal is considered valid if the measured RSSI is above the threshold set in the <a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a>
 property.
            </li><li>
3 = Eye Opening and RSSI qualifier. This qualification method logicall-ANDs the results from the Eye Opening qualifier and the RSSI qualifier; the signal is considered to have arrived if both are true.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">EYE_QUAL</td><td>0</td><td align="left">
<ul><li>
Spike Detection Qualifier</li></ul>
</td></tr>
<tr valign="top"><td align="left">ADJ_SAMP_QUAL</td><td>1</td><td align="left">
<ul><li>
Spike Detection and Eye Opening Qualifier</li></ul>
</td></tr>
<tr valign="top"><td align="left">RSSI_QUAL</td><td>2</td><td align="left">
<ul><li>
RSSI Qualifier</li></ul>
</td></tr>
<tr valign="top"><td align="left">EYE_RSSI_QUAL</td><td>3</td><td align="left">
<ul><li>
Eye-Opening and RSSI to qualify signal</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSA_CTRL1%3ADSA_EN">DSA_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enable/Disable the Signal Arrival Detector. This bit provides the master Enable/Disable function for t he DSA algorithm and OOK Squelch function. No DSA functions may be accessed unless this bit is enabled.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable Signal Arrival Detection algorithm</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable Signal Arrival Detection algorithm</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSA_CTRL1%3AADJ_SAMP_ERR_TOLERANCE">ADJ_SAMP_ERR_TOLERANCE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This parameter sets the number of error pulses (i.e., "spikes") from the adjacent sample differentiator block that can be tolerated within one search period window. The signal is considered to have arrived when the detected number of spikes remains below this tolerance limit for the number of consecutive search periods set by the <a href="#field-MODEM_DSA_CTRL2%3AARRIVAL_THD">MODEM_DSA_CTRL2:ARRIVAL_THD</a>
 parameter.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_DSA_CTRL2">MODEM_DSA_CTRL2</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x5c</li>
<li>Summary: Signal Arrival Detection Control 2</li>
<li>Purpose:</li>
<ul><li>
Configures Signal Arrival Detection Algorithm</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_DSA_CTRL2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x5c</td>
<td colspan="1">PREAM_QUAL</td>
<td colspan="1">SYNC_QUAL</td>
<td colspan="1">BCR_GEAR_SHIFT</td>
<td colspan="1">SKIP_PMDET</td>
<td colspan="4">ARRIVAL_THD</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x5c</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="4">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_DSA_CTRL2">MODEM_DSA_CTRL2</a><ul>
<li><a name="field-MODEM_DSA_CTRL2%3APREAM_QUAL">PREAM_QUAL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enable signal arrival detection block to qualify premable detection.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable Signal Arrival Detection algorithm to qualify preamble.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable Signal Arrival Detection algorithm to qualify preamble.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSA_CTRL2%3ASYNC_QUAL">SYNC_QUAL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enable signal arrival detection block to qualify sync word detection</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable Signal Arrival Detection algorithm to qualify sync word.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable Signal Arrival Detection algorithm to qualify sync word.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSA_CTRL2%3ABCR_GEAR_SHIFT">BCR_GEAR_SHIFT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enable BCR to switch from fast gear to middle gear after sync word is detected</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable BCR to switch from fast to middle gear after sync word detect.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable BCR to switch from fast to middle gear after sync word detect.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSA_CTRL2%3ASKIP_PMDET">SKIP_PMDET</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Signal Arrival Detect algorithm determines preamble detection.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">QUAL_ONLY</td><td>0</td><td align="left">
<ul><li>
Signal Arrival Detection algorithm helps qualify preamble detection.</li></ul>
</td></tr>
<tr valign="top"><td align="left">REPLACE_PREAMBLE</td><td>1</td><td align="left">
<ul><li>
Signal Arrival Detection algorithm replaces modem preamble detection</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSA_CTRL2%3AARRIVAL_THD">ARRIVAL_THD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Along with SCHPRD_HI in ref <a href="#prop-MODEM_RAW_SEARCH">MODEM_RAW_SEARCH</a>
, observation period is defined as Tb*arrival_thd*sch_period</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_DSA_QUAL">MODEM_DSA_QUAL</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x5d</li>
<li>Summary: Configures parameters for the Eye Opening qualification m ethod of the Signal Arrival Detection algorithm.</li>
<li>Purpose:</li>
<ul><li>
Refer to MODEM_DSA_CTRL1 for an overview of the Signal Arrival Detection (DSA) function.
            </li><li>
The DSA circuit contains a block that measures peak-to-peak deviation of the signal over a programmable search period of time. The signal is considered valid if the peak-to-peak deviation remains within a programmable "window"(i.e., the deviation is above a minimum limit and below a maximum limit value).
            </li><li>
The <a href="#field-MODEM_DSA_QUAL%3AARRQUAL">MODEM_DSA_QUAL:ARRQUAL</a>
 parameter defines the center value of this limit window; the minimum and maximum limits of the window are obtained by internally multiplying the ARRQUAL parameter by fixed scale factors.
            </li><li>
The period of time over which the DSA algorithm measures the peak-to-peak deviation is configured by the <a href="#field-MODEM_RAW_SEARCH2%3ASCHPRD_HI">MODEM_RAW_SEARCH2:SCHPRD_HI</a>
 parmeter.
            </li><li>
It is additionally possible to enable a Moving Average filter on the measured value of peak-to-peak deviation.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_DSA_QUAL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x5d</td>
<td colspan="1">EYE_QUAL_SEL</td>
<td colspan="7">ARRQUAL</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x5d</td>
<td colspan="1">0x0</td>
<td colspan="7">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_DSA_QUAL">MODEM_DSA_QUAL</a><ul>
<li><a name="field-MODEM_DSA_QUAL%3AEYE_QUAL_SEL">EYE_QUAL_SEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit enables/disables a moving average filter in the frequency demodulator path used in the Eye Opening qualifier for the DSA. This MA filter function helps "smooth out" noise-like spikes in the frequency domain when operating at weak or noisy signal levels. However suppression of these spikes may not be desirable when using Spike Detection as the qualification source for the DSA.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable MA filter on Eye Qualifier signal path.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable MA filter on Eye Qualifier signal path.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSA_QUAL%3AARRQUAL">ARRQUAL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This parmeter configures the center value of the deviation limit window, against which the measured peak-to-peak deviation is compared. The measured deviation must remain within the limit window over the search period of time for the signal to be considered valid. The required value for this parameter depends heavily on RX Modem parameters such as data rate, deviation, and over-sampling rate. Silicon Laboratories recommends use of the value suggested by WDS.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_DSA_RSSI">MODEM_DSA_RSSI</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x5e</li>
<li>Summary: Signal Arrival Detect RSSI Qualifier Config</li>
<li>Purpose:</li>
<ul><li>
Configures RSSI Qualifier options for the Signal Arrival Detection algorithm</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_DSA_RSSI</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x5e</td>
<td colspan="1">SQUELCH_EN</td>
<td colspan="7">DSA_RSSI_THRESHOLD</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x5e</td>
<td colspan="1">0x0</td>
<td colspan="7">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_DSA_RSSI">MODEM_DSA_RSSI</a><ul>
<li><a name="field-MODEM_DSA_RSSI%3ASQUELCH_EN">SQUELCH_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enable squelch function and replace RSSI above threshold interrupt</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable squelch function which replaces RSSI above threshold interrupt.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable squelch function which replaces RSSI above threshold interrupt.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSA_RSSI%3ADSA_RSSI_THRESHOLD">DSA_RSSI_THRESHOLD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Signal Arrival RSSI Threshold</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_DSA_MISC">MODEM_DSA_MISC</a></h4>
<ul>
<li>Group: 0x20</li>
<li>Index: 0x5f</li>
<li>Summary: Miscellaneous detection of signal arrival bits.</li>
<li>Purpose:</li>
<ul><li>
Miscellaneous detection of signal arrival bits.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_DSA_MISC</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x5f</td>
<td colspan="1">CC_ASSESS_SEL</td>
<td colspan="1">EYEXEST_EN</td>
<td colspan="1">EYEXEST_FAST</td>
<td>0</td>
<td>0</td>
<td colspan="3">LOW_DUTY</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x5f</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="3">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM%3AMODEM_DSA_MISC">MODEM_DSA_MISC</a><ul>
<li><a name="field-MODEM_DSA_MISC%3ACC_ASSESS_SEL">CC_ASSESS_SEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
DSA replaces above RSSI threshold detection interrupt</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable DSA replacing RSSI above threshold detection interrupt for clear channel assessment..</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable DSA replacing RSSI above threshold detection interrupt for clear channel assessment..</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSA_MISC%3AEYEXEST_EN">EYEXEST_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If enabled, include eye opening measurement in time domain in signal arrival detection</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable eye opening measurement in time domain as a factor of signal arrival detection..</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable eye opening measurement in time domain as a factor of signal arrival detection..</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSA_MISC%3AEYEXEST_FAST">EYEXEST_FAST</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Define the window for eye opening measurement in time domain.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">WINDOW4</td><td>0</td><td align="left">
<ul><li>
Use a 4-bit observation window for eye-opening measurement in time domain.</li></ul>
</td></tr>
<tr valign="top"><td align="left">WINDOW8</td><td>1</td><td align="left">
<ul><li>
Use a 8-bit observation window for eye-opening measurement in time domain.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MODEM_DSA_MISC%3ALOW_DUTY">LOW_DUTY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Used to accommodate filter propagation delay. During this time the signal arrival detector is ignored.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-MODEM_CHFLT">MODEM_CHFLT</a></h3>
<h4><a name="prop-MODEM_CHFLT_RX1_CHFLT_COE">MODEM_CHFLT_RX1_CHFLT_COE</a></h4>
<ul>
<li>Group: 0x21</li>
<li>Index: 0x00 ... 0x11</li>
<li>Summary: Filter coefficients for the first set of RX filter coefficients.</li>
<li>Purpose:</li>
<ul><li>
The chip implements the RX channel selection bandpass filtering in the digital domain as an FIR filter.     The <a href="#prop-MODEM_CHFLT_RX1_CHFLT_COE">MODEM_CHFLT_RX1_CHFLT_COE</a>
 property defines the values for the filter tap coefficients.    </li><li>
The chip provides for two different sets of RX filter coefficients (MODEM_CHFLT_RX1 and MODEM_CHFLT_RX2).    This property define the values for the first set of filter coefficients;     see also the text description for the <a href="#prop-MODEM_CHFLT_RX2_CHFLT_COE">MODEM_CHFLT_RX2_CHFLT_COE</a>
 property for a discussion of the second set of filter coefficients and use of adaptive RX filter bandwidth across the packet.    </li><li>
By default, the digital filter is 27 taps in length.     However, it is possible to configure the RX Modem for a channel selection filter with only 15 taps;    the advantage of the 15-tap filter is a reduction in filter processing delay at the expense of reduced filtering performance (e.g., adjacent channel selectivity).    </li><li>
The values of the tap coefficients are symmetrical;    that is, the value of COEFF26=COEFF0, COEFF25=COEFF1, and so on.    Thus it is only necessary to store 14 filter coefficients;     the internal circuitry obtains the remaining coefficients through symmetry.    The programmed values of coefficients are the same when operating in the reduced performance mode (i.e., 15-tap filter),    but the lower six coefficients are not used.
    </li><li>
Each filter tap coefficient is a 10-bit signed value.     The lower 8-bits of each coefficient are held in the properties at indexes 0x00 through 0x0D,    while the top two bits are packed into the properties at indexes 0x0E through 0x11. 
    </li><li>
Silicon Labs has pre-calculated 15 different sets of filter tap coefficients.     The WDS Calculator will recommend one of these filter sets,    based upon the RX filter bandwidth required to receive the desired signal.     The filter bandwidth is a function of both the selected filter set,    as well as the filter clock decimation ratio (see the <a href="#prop-MODEM_DECIMATION_CFG1">MODEM_DECIMATION_CFG1</a>
/0 properties).</li></ul>
<li>Defaults: 0xff, 0xba, 0x0f, 0x51, 0xcf, 0xa9, 0xc9, 0xfc, 0x1b, 0x1e, 0x0f, 0x01, 0xfc, 0xfd, 0x15, 0xff, 0x00, 0x0f</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_CHFLT_RX1_CHFLT_COE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="8">RX1_CHFLT_COE13[7:0]</td>
</tr>
<tr><td>0x01</td>
<td colspan="8">RX1_CHFLT_COE12[7:0]</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">RX1_CHFLT_COE11[7:0]</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">RX1_CHFLT_COE10[7:0]</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">RX1_CHFLT_COE9[7:0]</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">RX1_CHFLT_COE8[7:0]</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">RX1_CHFLT_COE7[7:0]</td>
</tr>
<tr><td>0x07</td>
<td colspan="8">RX1_CHFLT_COE6[7:0]</td>
</tr>
<tr><td>0x08</td>
<td colspan="8">RX1_CHFLT_COE5[7:0]</td>
</tr>
<tr><td>0x09</td>
<td colspan="8">RX1_CHFLT_COE4[7:0]</td>
</tr>
<tr><td>0x0a</td>
<td colspan="8">RX1_CHFLT_COE3[7:0]</td>
</tr>
<tr><td>0x0b</td>
<td colspan="8">RX1_CHFLT_COE2[7:0]</td>
</tr>
<tr><td>0x0c</td>
<td colspan="8">RX1_CHFLT_COE1[7:0]</td>
</tr>
<tr><td>0x0d</td>
<td colspan="8">RX1_CHFLT_COE0[7:0]</td>
</tr>
<tr><td>0x0e</td>
<td colspan="2">RX1_CHFLT_COE10[9:8]</td>
<td colspan="2">RX1_CHFLT_COE11[9:8]</td>
<td colspan="2">RX1_CHFLT_COE12[9:8]</td>
<td colspan="2">RX1_CHFLT_COE13[9:8]</td>
</tr>
<tr><td>0x0f</td>
<td colspan="2">RX1_CHFLT_COE6[9:8]</td>
<td colspan="2">RX1_CHFLT_COE7[9:8]</td>
<td colspan="2">RX1_CHFLT_COE8[9:8]</td>
<td colspan="2">RX1_CHFLT_COE9[9:8]</td>
</tr>
<tr><td>0x10</td>
<td colspan="2">RX1_CHFLT_COE2[9:8]</td>
<td colspan="2">RX1_CHFLT_COE3[9:8]</td>
<td colspan="2">RX1_CHFLT_COE4[9:8]</td>
<td colspan="2">RX1_CHFLT_COE5[9:8]</td>
</tr>
<tr><td>0x11</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="2">RX1_CHFLT_COE0[9:8]</td>
<td colspan="2">RX1_CHFLT_COE1[9:8]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="8">0xff</td>
</tr>
<tr><td>0x01</td>
<td colspan="8">0xba</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">0xf</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">0x51</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">0xcf</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">0xa9</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">0xc9</td>
</tr>
<tr><td>0x07</td>
<td colspan="8">0xfc</td>
</tr>
<tr><td>0x08</td>
<td colspan="8">0x1b</td>
</tr>
<tr><td>0x09</td>
<td colspan="8">0x1e</td>
</tr>
<tr><td>0x0a</td>
<td colspan="8">0xf</td>
</tr>
<tr><td>0x0b</td>
<td colspan="8">0x1</td>
</tr>
<tr><td>0x0c</td>
<td colspan="8">0xfc</td>
</tr>
<tr><td>0x0d</td>
<td colspan="8">0xfd</td>
</tr>
<tr><td>0x0e</td>
<td colspan="2">0x0</td>
<td colspan="2">0x1</td>
<td colspan="2">0x1</td>
<td colspan="2">0x1</td>
</tr>
<tr><td>0x0f</td>
<td colspan="2">0x3</td>
<td colspan="2">0x3</td>
<td colspan="2">0x3</td>
<td colspan="2">0x3</td>
</tr>
<tr><td>0x10</td>
<td colspan="2">0x0</td>
<td colspan="2">0x0</td>
<td colspan="2">0x0</td>
<td colspan="2">0x0</td>
</tr>
<tr><td>0x11</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="2">0x3</td>
<td colspan="2">0x3</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM_CHFLT%3AMODEM_CHFLT_RX1_CHFLT_COE">MODEM_CHFLT_RX1_CHFLT_COE</a><ul>
<li><a name="field-MODEM_CHFLT_RX1_CHFLT_COE%3ARX1_CHFLT_COE13">RX1_CHFLT_COE13</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx1_chflt_coe13</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX1_CHFLT_COE%3ARX1_CHFLT_COE12">RX1_CHFLT_COE12</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx1_chflt_coe12</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX1_CHFLT_COE%3ARX1_CHFLT_COE11">RX1_CHFLT_COE11</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx1_chflt_coe11</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX1_CHFLT_COE%3ARX1_CHFLT_COE10">RX1_CHFLT_COE10</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx1_chflt_coe10</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX1_CHFLT_COE%3ARX1_CHFLT_COE9">RX1_CHFLT_COE9</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx1_chflt_coe9</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX1_CHFLT_COE%3ARX1_CHFLT_COE8">RX1_CHFLT_COE8</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx1_chflt_coe8</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX1_CHFLT_COE%3ARX1_CHFLT_COE7">RX1_CHFLT_COE7</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx1_chflt_coe7</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX1_CHFLT_COE%3ARX1_CHFLT_COE6">RX1_CHFLT_COE6</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx1_chflt_coe6</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX1_CHFLT_COE%3ARX1_CHFLT_COE5">RX1_CHFLT_COE5</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx1_chflt_coe5</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX1_CHFLT_COE%3ARX1_CHFLT_COE4">RX1_CHFLT_COE4</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx1_chflt_coe4</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX1_CHFLT_COE%3ARX1_CHFLT_COE3">RX1_CHFLT_COE3</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx1_chflt_coe3</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX1_CHFLT_COE%3ARX1_CHFLT_COE2">RX1_CHFLT_COE2</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx1_chflt_coe2</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX1_CHFLT_COE%3ARX1_CHFLT_COE1">RX1_CHFLT_COE1</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx1_chflt_coe1</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX1_CHFLT_COE%3ARX1_CHFLT_COE0">RX1_CHFLT_COE0</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx1_chflt_coe0</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MODEM_CHFLT_RX2_CHFLT_COE">MODEM_CHFLT_RX2_CHFLT_COE</a></h4>
<ul>
<li>Group: 0x21</li>
<li>Index: 0x12 ... 0x23</li>
<li>Summary: Filter coefficients for the second set of RX filter coefficients.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for two different sets of RX filter coefficients (MODEM_CHFLT_RX1 and MODEM_CHFLT_RX2).    This property defines the values for the second set of filter coefficients;    see also the text description for the <a href="#prop-MODEM_CHFLT_RX1_CHFLT_COE">MODEM_CHFLT_RX1_CHFLT_COE</a>
 property for a general discussion of the configuration of filter tap coefficients.    </li><li>
Two different sets of filter tap coefficients (i.e., filter bandwidths)    are provided to allow narrowing the RX bandwidth after the PLL-based AFC algorithm has acquired the signal and centered it in the filter passband.     With no residual frequency error,    the filter bandwidth may be reduced to pass only the modulation bandwidth of the signal,    thus improving sensitivity over the remainder of the packet.    </li><li>
This adaptive RX bandwidth feature is only applicable when PLL AFC is enabled (by setting    <a href="#field-MODEM_AFC_MISC%3AENFBPLL">MODEM_AFC_MISC:ENFBPLL</a>
),    and the adaptive RX bandwidth function is enabled     (by setting <a href="#field-MODEM_AFC_GAIN%3AAFCBD">MODEM_AFC_GAIN:AFCBD</a>
).    </li><li>
When the adaptive RX bandwidth feature is enabled,    the first set of filter coefficients (defined in the <a href="#prop-MODEM_CHFLT_RX1_CHFLT_COE">MODEM_CHFLT_RX1_CHFLT_COE</a>
 property)    is effective prior to gear-switching (e.g., detection of PREAMBLE_VALID)     while the second set of filter coefficients (defined in the <a href="#prop-MODEM_CHFLT_RX2_CHFLT_COE">MODEM_CHFLT_RX2_CHFLT_COE</a>
 property) is effective after  gear-switching.     When the adaptive RX bandwidth feature is disabled,    the first set of filter coefficients is  used for the entire packet.</li></ul>
<li>Defaults: 0xff, 0xc4, 0x30, 0x7f, 0xf5, 0xb5, 0xb8, 0xde, 0x05, 0x17, 0x16, 0x0c, 0x03, 0x00, 0x15, 0xff, 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MODEM_CHFLT_RX2_CHFLT_COE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x12</td>
<td colspan="8">RX2_CHFLT_COE13[7:0]</td>
</tr>
<tr><td>0x13</td>
<td colspan="8">RX2_CHFLT_COE12[7:0]</td>
</tr>
<tr><td>0x14</td>
<td colspan="8">RX2_CHFLT_COE11[7:0]</td>
</tr>
<tr><td>0x15</td>
<td colspan="8">RX2_CHFLT_COE10[7:0]</td>
</tr>
<tr><td>0x16</td>
<td colspan="8">RX2_CHFLT_COE9[7:0]</td>
</tr>
<tr><td>0x17</td>
<td colspan="8">RX2_CHFLT_COE8[7:0]</td>
</tr>
<tr><td>0x18</td>
<td colspan="8">RX2_CHFLT_COE7[7:0]</td>
</tr>
<tr><td>0x19</td>
<td colspan="8">RX2_CHFLT_COE6[7:0]</td>
</tr>
<tr><td>0x1a</td>
<td colspan="8">RX2_CHFLT_COE5[7:0]</td>
</tr>
<tr><td>0x1b</td>
<td colspan="8">RX2_CHFLT_COE4[7:0]</td>
</tr>
<tr><td>0x1c</td>
<td colspan="8">RX2_CHFLT_COE3[7:0]</td>
</tr>
<tr><td>0x1d</td>
<td colspan="8">RX2_CHFLT_COE2[7:0]</td>
</tr>
<tr><td>0x1e</td>
<td colspan="8">RX2_CHFLT_COE1[7:0]</td>
</tr>
<tr><td>0x1f</td>
<td colspan="8">RX2_CHFLT_COE0[7:0]</td>
</tr>
<tr><td>0x20</td>
<td colspan="2">RX2_CHFLT_COE10[9:8]</td>
<td colspan="2">RX2_CHFLT_COE11[9:8]</td>
<td colspan="2">RX2_CHFLT_COE12[9:8]</td>
<td colspan="2">RX2_CHFLT_COE13[9:8]</td>
</tr>
<tr><td>0x21</td>
<td colspan="2">RX2_CHFLT_COE6[9:8]</td>
<td colspan="2">RX2_CHFLT_COE7[9:8]</td>
<td colspan="2">RX2_CHFLT_COE8[9:8]</td>
<td colspan="2">RX2_CHFLT_COE9[9:8]</td>
</tr>
<tr><td>0x22</td>
<td colspan="2">RX2_CHFLT_COE2[9:8]</td>
<td colspan="2">RX2_CHFLT_COE3[9:8]</td>
<td colspan="2">RX2_CHFLT_COE4[9:8]</td>
<td colspan="2">RX2_CHFLT_COE5[9:8]</td>
</tr>
<tr><td>0x23</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="2">RX2_CHFLT_COE0[9:8]</td>
<td colspan="2">RX2_CHFLT_COE1[9:8]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x12</td>
<td colspan="8">0xff</td>
</tr>
<tr><td>0x13</td>
<td colspan="8">0xc4</td>
</tr>
<tr><td>0x14</td>
<td colspan="8">0x30</td>
</tr>
<tr><td>0x15</td>
<td colspan="8">0x7f</td>
</tr>
<tr><td>0x16</td>
<td colspan="8">0xf5</td>
</tr>
<tr><td>0x17</td>
<td colspan="8">0xb5</td>
</tr>
<tr><td>0x18</td>
<td colspan="8">0xb8</td>
</tr>
<tr><td>0x19</td>
<td colspan="8">0xde</td>
</tr>
<tr><td>0x1a</td>
<td colspan="8">0x5</td>
</tr>
<tr><td>0x1b</td>
<td colspan="8">0x17</td>
</tr>
<tr><td>0x1c</td>
<td colspan="8">0x16</td>
</tr>
<tr><td>0x1d</td>
<td colspan="8">0xc</td>
</tr>
<tr><td>0x1e</td>
<td colspan="8">0x3</td>
</tr>
<tr><td>0x1f</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x20</td>
<td colspan="2">0x0</td>
<td colspan="2">0x1</td>
<td colspan="2">0x1</td>
<td colspan="2">0x1</td>
</tr>
<tr><td>0x21</td>
<td colspan="2">0x3</td>
<td colspan="2">0x3</td>
<td colspan="2">0x3</td>
<td colspan="2">0x3</td>
</tr>
<tr><td>0x22</td>
<td colspan="2">0x0</td>
<td colspan="2">0x0</td>
<td colspan="2">0x0</td>
<td colspan="2">0x0</td>
</tr>
<tr><td>0x23</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="2">0x0</td>
<td colspan="2">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MODEM_CHFLT%3AMODEM_CHFLT_RX2_CHFLT_COE">MODEM_CHFLT_RX2_CHFLT_COE</a><ul>
<li><a name="field-MODEM_CHFLT_RX2_CHFLT_COE%3ARX2_CHFLT_COE13">RX2_CHFLT_COE13</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx2_chflt_coe13</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX2_CHFLT_COE%3ARX2_CHFLT_COE12">RX2_CHFLT_COE12</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx2_chflt_coe12</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX2_CHFLT_COE%3ARX2_CHFLT_COE11">RX2_CHFLT_COE11</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx2_chflt_coe11</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX2_CHFLT_COE%3ARX2_CHFLT_COE10">RX2_CHFLT_COE10</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx2_chflt_coe10</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX2_CHFLT_COE%3ARX2_CHFLT_COE9">RX2_CHFLT_COE9</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx2_chflt_coe9</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX2_CHFLT_COE%3ARX2_CHFLT_COE8">RX2_CHFLT_COE8</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx2_chflt_coe8</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX2_CHFLT_COE%3ARX2_CHFLT_COE7">RX2_CHFLT_COE7</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx2_chflt_coe7</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX2_CHFLT_COE%3ARX2_CHFLT_COE6">RX2_CHFLT_COE6</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx2_chflt_coe6</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX2_CHFLT_COE%3ARX2_CHFLT_COE5">RX2_CHFLT_COE5</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx2_chflt_coe5</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX2_CHFLT_COE%3ARX2_CHFLT_COE4">RX2_CHFLT_COE4</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx2_chflt_coe4</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX2_CHFLT_COE%3ARX2_CHFLT_COE3">RX2_CHFLT_COE3</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx2_chflt_coe3</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX2_CHFLT_COE%3ARX2_CHFLT_COE2">RX2_CHFLT_COE2</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx2_chflt_coe2</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX2_CHFLT_COE%3ARX2_CHFLT_COE1">RX2_CHFLT_COE1</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx2_chflt_coe1</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-MODEM_CHFLT_RX2_CHFLT_COE%3ARX2_CHFLT_COE0">RX2_CHFLT_COE0</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx2_chflt_coe0</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-PA">PA</a></h3>
<h4><a name="prop-PA_MODE">PA_MODE</a></h4>
<ul>
<li>Group: 0x22</li>
<li>Index: 0x00</li>
<li>Summary: Selects the PA operating mode, and selects resolution of PA power adjustment (i.e., step size).</li>
<li>Purpose:</li>
<ul><li>
The PA output circuit is designed to operate as either a switching-type amplifier, or as a switched programmable current source.
    </li><li>
This property selects the operating mode of the PA.     A switching-type amplifier (matched for Class-E or Square Wave operation)    will typically provide higher output power and better current efficiency,     while a switched current amplifier will typically provide more linear control of output power and better power flatness over variations in VDD supply voltage.
    </li><li>
The output power level is configured through the <a href="#prop-PA_PWR_LVL">PA_PWR_LVL</a>
 property and (when operating in Switched Current mode) the <a href="#prop-PA_BIAS_CLKDUTY">PA_BIAS_CLKDUTY</a>
 property.
    </li><li>
The chip provides a signal on the TXRAMP pin for ramping control of an external PA.     This signal may be enabled/disabled through the EXT_PA_RAMP bit in this property;     configuration of the external ramping signal itself is provided in the <a href="#prop-PA_RAMP_EX">PA_RAMP_EX</a>
 property.
    </li><li>
The different chips within the Si446x family (e.g., Si4460/61/63/64)    contain a variety of sizes and groups of PA output devices.      These are selected to obtain the desired output power level and power adjustment step size.      This configuration is automatically handled inside the chip according to chip type;     the PA_SEL field does not need to be configured to obtain proper operation of the PA.      However, there is no harm in continuing to set this parameter to the value(s) suggested by WDS. </li></ul>
<li>Defaults: 0x08</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PA_MODE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="1">EXT_PA_RAMP</td>
<td colspan="1">DIG_PWR_SEQ</td>
<td colspan="4">PA_SEL</td>
<td colspan="1">PA_OV_CLAMP</td>
<td colspan="1">PA_MODE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="4">0x2</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PA%3APA_MODE">PA_MODE</a><ul>
<li><a name="field-PA_MODE%3AEXT_PA_RAMP">EXT_PA_RAMP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
When set, enables a signal on the TXRAMP pin for ramping control of an external PA.
    </li><li>
The characteristics of the external ramping signal are configured through the <a href="#prop-PA_RAMP_EX">PA_RAMP_EX</a>
 property.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable external TX ramp signal.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable external TX ramp signal.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PA_MODE%3ADIG_PWR_SEQ">DIG_PWR_SEQ</a>
<dl><dt>Description:</dt><dd>
<ul><li>
When set, provides for much slower ramp times of the internal PA by digitally sequencing the number of enabled PA output device fingers.     The number of enabled output device fingers is stepped from 0 up to the value programmed in PA_PWR_LVL.    </li><li>
The number of device fingers enabled per step and the time delay between steps is configured in the <a href="#prop-PA_DIG_PWR_SEQ_CONFIG">PA_DIG_PWR_SEQ_CONFIG</a>
 property.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Disable digital power sequencing.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Enable digital power sequencing.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PA_MODE%3APA_SEL">PA_SEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
 Selects the appropriate groups and sizes of PA output devices to obtain the desired output power level and power adjustment step size, according to chip type.    </li><li>
Use of enumerations other than those listed below are not recommended.</li></ul>
</dd></dl>
<dl><dt>Comments:</dt><dd>
<ul><li>
In REVB this field is ignored.  In REVC This field works as such:                                                                                                                                        </li><li>
 If none of the feature_xx_DB_PA feature bits are enabled this field defaults to 0 and any writes will have no effect on the PA operation.                   </li><li>
 If any of the feature_xx_DB_PA feature bits are enabled this field must select one of the allowed PA options, or the PA will be disabled.                   </li><li>
 If any of the feature_xx_DB_PA feature bits are enabled the default of this property is controled by firmware based on the aconfig shadow value of pa.pdo.pdo.  This is controlled by OTP.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">HP_FINE</td><td>1</td><td align="left">
<ul><li>
Si4463/64: lower maximum power but with finer step size (~2x). </li></ul>
Comments: 
<ul><li>
Selects HPA0 1 group on (pa.pdo.pdo = 1_HPA_ON = 0x3e)</li></ul>
</td></tr>
<tr valign="top"><td align="left">HP_COARSE</td><td>2</td><td align="left">
<ul><li>
Si4463/64: higher maximum power but with larger step size. </li></ul>
Comments: 
<ul><li>
Selects HPA0 2 groups on (pa.pdo.pdo = 2_HPA_ON = 0x3C)</li></ul>
</td></tr>
<tr valign="top"><td align="left">LP</td><td>6</td><td align="left">
<ul><li>
Si4460: lower-power applications.</li></ul>
Comments: 
<ul><li>
Selects MPAN 1 group on (pa.pdo.pdo = MPA_N_ON = 0x2f)</li></ul>
</td></tr>
<tr valign="top"><td align="left">MP</td><td>8</td><td align="left">
<ul><li>
Si4461: medium-power applications.</li></ul>
Comments: 
<ul><li>
Selects HPA1 1 group on (pa.pdo.pdo = 1_HPA1_ON = 0x3b)</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PA_MODE%3APA_OV_CLAMP">PA_OV_CLAMP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enables detection and clamping of a transient over-voltage condition on the PA output.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Over-voltage detection and clamping disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Over-voltage detection and clamping enabled.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PA_MODE%3APA_MODE">PA_MODE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the operating mode of the PA.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">CLE</td><td>0</td><td align="left">
<ul><li>
Switching-Amplifier Mode (for Class-E or Square Wave match).</li></ul>
</td></tr>
<tr valign="top"><td align="left">SWC</td><td>1</td><td align="left">
<ul><li>
Switched Current Mode.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PA_PWR_LVL">PA_PWR_LVL</a></h4>
<ul>
<li>Group: 0x22</li>
<li>Index: 0x01</li>
<li>Summary: Configuration of PA output power level.</li>
<li>Purpose:</li>
<ul><li>
The PA circuitry in the chip contains an output device whose size may be adjusted by enabling/disabling different numbers of device fingers.     Selection of a higher value results in an increase in TX output power.
    </li><li>
	The relationship between output power and the number of enabled device fingers is not necessarily linear,     and is dependent upon the PA mode of operation (e.g., Class-E or Switched Current), the duty cycle of the drive signal to the output circuit,     the VDD supply voltage, and the output match.     As a result, there is no simple formula to relate the setting of the PA_PWR_LVL property to an absolute value of output power in dBm.    </li><li>
The adjustment resolution of the TX output power is very fine (step size < 0.1 dB) when operating near the maximum power setting,    but becomes coarser as the output power level is reduced. </li></ul>
<li>Defaults: 0x7f</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PA_PWR_LVL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td>0</td>
<td colspan="7">DDAC</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td>0x0</td>
<td colspan="7">0x7f</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PA%3APA_PWR_LVL">PA_PWR_LVL</a><ul>
<li><a name="field-PA_PWR_LVL%3ADDAC">DDAC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the number of enabled output device fingers, with a larger value resulting in increased output power.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PA_BIAS_CLKDUTY">PA_BIAS_CLKDUTY</a></h4>
<ul>
<li>Group: 0x22</li>
<li>Index: 0x02</li>
<li>Summary: Configuration of the PA Bias and duty cycle of the TX clock source.</li>
<li>Purpose:</li>
<ul><li>
The PA output circuit is designed to operate as either a switching-type amplifier, or as a switched programmable current source.     The PA mode of operation is selected through the PA_MODE property;    the bias current (when operated as a switched programmable current source)    and the duty cycle of the driving TX clock source are selected through this property.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PA_BIAS_CLKDUTY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="2">CLK_DUTY</td>
<td colspan="6">OB</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="2">0x0</td>
<td colspan="6">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PA%3APA_BIAS_CLKDUTY">PA_BIAS_CLKDUTY</a><ul>
<li><a name="field-PA_BIAS_CLKDUTY%3ACLK_DUTY">CLK_DUTY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This parameter adjusts the drive mode (single-ended or complementary) and duty cycle of the TX clock source to the PA output devices.
    </li><li>
Silicon Labs recommends use of the modes listed below,     as they have been optimized for the listed chips and associated output power levels.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DIFF_50</td><td>0</td><td align="left">
<ul><li>
Complementary drive signals, 50% duty cycle.    Recommended for use with Si4463/Si4464 high-power (e.g., +20dBm)applications,    and as an option for Si4461 medium-power (e.g., +13 to +16 dBm) applications.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIFF_25</td><td>1</td><td align="left">
<ul><li>
Complementary drive signals, 25% duty cycle. </li></ul>
</td></tr>
<tr valign="top"><td align="left">SINGLE_50</td><td>2</td><td align="left">
<ul><li>
Single-ended drive signal, 50% duty cycle. </li></ul>
</td></tr>
<tr valign="top"><td align="left">SINGLE_25</td><td>3</td><td align="left">
<ul><li>
Single-ended drive signal, 25% duty cycle.     Recommended for use with Si4460 low-power (e.g., +10 to +13 dBm, or lower) applications,    and as an option for Si4461 medium-power (e.g., +13 to +16 dBm) applications.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PA_BIAS_CLKDUTY%3AOB">OB</a>
<dl><dt>Description:</dt><dd>
<ul><li>
When the PA is configured for the Switched Current mode of operation, the output devices act as programmable current sources.    The current sources are switched ON and OFF at the RF frequency by the driving signal selected by the CLK_DUTY parameter,    thus delivering pulses of programmable current to the load.    </li><li>
This parameter selects the amount of bias current per enabled output device finger.     The total number of enabled output device fingers is selected by the PA_PWR_LVL property,    and thus the total PA bias current is equal to Bias_Current_per_Finger * Number_Enabled_Fingers.     </li><li>
The step size of this parameter is in increments of 10 A.     There is a fixed 10 A bias current added to the value selected by this field (e.g., OB = 0 = 10A, OB = 1 = 20A, etc.)    </li><li>
This parameter has no effect when PA_MODE = Switching Amplifier.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x3f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PA_TC">PA_TC</a></h4>
<ul>
<li>Group: 0x22</li>
<li>Index: 0x03</li>
<li>Summary: Configuration of PA ramping parameters.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for PA power ramping in order to minimize spectral splatter and switching transients.
	</li><li>
The TC value specifies the time constant for the ramping of both the rising and falling edges of the PA power.     This time constant is applicable to both the rising and falling edges of the TX packet in (G)FSK mode, as well as to individual data bits in OOK mode.     It is difficult to precisely define the ramp time as different measurement methods may be used     (e.g., 10% to 90% rise time, to within 1dB of final value, etc.)     However, the approximate ramp time is given by the following table:
    <br />[embedded image: PA_TC Ramp Configuration]

	</li><li>
The FSK_MOD_DLY value specifies an additional delay period from the rising edge of the PA ramp to the first bit of the (G)FSK modulation.     It is configurable over the range of 2 to 30 usec in increments of 4 usec, and is added to an intrinsic modulation delay of approximately 3 bits/symbols.
	</li><li>
The purpose of the FSK_MOD_DLY parameter is to ensure that the (G)FSK modulation does not begin before the PA power ramping has been completed.     In (G)FSK mode, the value of FSK_MOD_DLY should be programmed to work well with the selected value of TC.     The FSK_MOD_DLY parameter has no effect in OOK mode.</li></ul>
<li>Defaults: 0x5d</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PA_TC</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="3">FSK_MOD_DLY</td>
<td colspan="5">TC</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="3">0x2</td>
<td colspan="5">0x1d</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PA%3APA_TC">PA_TC</a><ul>
<li><a name="field-PA_TC%3AFSK_MOD_DLY">FSK_MOD_DLY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
In (G)FSK mode this specifies an additional delay from the rising edge of the PA ramp to the start of the (G)FSK modulation.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">2_US</td><td>0</td><td align="left">
<ul><li>
Start of (G)FSK modulation is delayed by an additional 2sec</li></ul>
</td></tr>
<tr valign="top"><td align="left">6_US</td><td>1</td><td align="left">
<ul><li>
Start of (G)FSK modulation is delayed by an additional 6sec</li></ul>
</td></tr>
<tr valign="top"><td align="left">10_US</td><td>2</td><td align="left">
<ul><li>
Start of (G)FSK modulation is delayed by an additional 10sec</li></ul>
</td></tr>
<tr valign="top"><td align="left">14_US</td><td>3</td><td align="left">
<ul><li>
Start of (G)FSK modulation is delayed by an additional 14sec</li></ul>
</td></tr>
<tr valign="top"><td align="left">18_US</td><td>4</td><td align="left">
<ul><li>
Start of (G)FSK modulation is delayed by an additional 18sec</li></ul>
</td></tr>
<tr valign="top"><td align="left">22_US</td><td>5</td><td align="left">
<ul><li>
Start of (G)FSK modulation is delayed by an additional 22sec</li></ul>
</td></tr>
<tr valign="top"><td align="left">26_US</td><td>6</td><td align="left">
<ul><li>
Start of (G)FSK modulation is delayed by an additional 26sec</li></ul>
</td></tr>
<tr valign="top"><td align="left">30_US</td><td>7</td><td align="left">
<ul><li>
Start of (G)FSK modulation is delayed by an additional 30sec</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PA_TC%3ATC">TC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Specifies the time constant for the ramping of both the rising and falling edges of the PA power.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PA_RAMP_EX">PA_RAMP_EX</a></h4>
<ul>
<li>Group: 0x22</li>
<li>Index: 0x04</li>
<li>Summary: Select the time constant of the external PA ramp signal.</li>
<li>Purpose:</li>
<ul><li>
The chip provides a signal on the TXRAMP pin for ramping control of an external PA.      This property selects the ramp time constant of the TXRAMP signal.    The signal may be enabled/disabled through the EXT_PA_RAMP bit in the <a href="#prop-PA_MODE">PA_MODE</a>
 property.
    </li><li>
The time constant of the ramp signal is determined by the following formula:
    <br />[LATEX equation: Ramp Time = (\frac{20 \mu sec}{16 - TC})]

    </li><li>
The amplitude range of the TXRAMP signal is fixed at ramping from 0V to 3.0V.      In the event the VDD supply voltage to the chip is reduced,     the upper voltage limit of the TXRAMP signal will be approximately VDD - 0.1V.
    </li><li>
This property does not affect the ramp time constant of the internal PA. </li></ul>
<li>Defaults: 0x80</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PA_RAMP_EX</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="4">VSET</td>
<td colspan="4">TC</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="4">0x8</td>
<td colspan="4">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PA%3APA_RAMP_EX">PA_RAMP_EX</a><ul>
<li><a name="field-PA_RAMP_EX%3AVSET">VSET</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This field adjusts the regulated voltage supply to the TXRAMP circuitry.      VSET = 0 = 1.0 V, VSET = 15 = 1.5 V.
    </li><li>
This field does not adjust the upper voltage limit of the TXRAMP signal. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
<li><a name="field-PA_RAMP_EX%3ATC">TC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the ramp time (both up and down) of the external PA ramp signal on the TXRAMP pin.
    </li><li>
The ramp time is determined by the formula:
    <br />[LATEX equation: Ramp Time = (\frac{20 \mu sec}{16 - TC})]
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PA_RAMP_DOWN_DELAY">PA_RAMP_DOWN_DELAY</a></h4>
<ul>
<li>Group: 0x22</li>
<li>Index: 0x05</li>
<li>Summary: Delay from the start of the PA ramp down to disabling of the PA output. </li>
<li>Purpose:</li>
<ul><li>
The ramp time constant selected by the <a href="#field-PA_TC%3ATC">PA_TC:TC</a>
 field controls the ramping of an analog bias voltage applied to the PA output device(s).    The RF drive signal to the PA output devices must remain active until the completion of the ramp-down process,    else the ramp-down waveform would terminate abruptly.     This property delays the complete shut-down of the PA block until the analog ramp-down is complete.    </li><li>
The units of this parameter are in sec.    This delay time must be greater than or equal to the ramp time specified by <a href="#field-PA_TC%3ATC">PA_TC:TC</a>
,    but must not be greater than RAMP_DOWN_DELAY = 0x28 = 40.      For most applications, it is acceptable to leave this property at its default value.     </li><li>
This property has no effect upon the ramp-up process.</li></ul>
<li>Defaults: 0x23</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PA_RAMP_DOWN_DELAY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="8">RAMP_DOWN_DELAY</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="8">0x23</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PA%3APA_RAMP_DOWN_DELAY">PA_RAMP_DOWN_DELAY</a><ul>
<li><a name="field-PA_RAMP_DOWN_DELAY%3ARAMP_DOWN_DELAY">RAMP_DOWN_DELAY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the delay time (in sec) between the start of the ramp-down process and the disabling of the PA output.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x1</dd></dl>
<dl><dt>Max:</dt><dd>0x28</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PA_DIG_PWR_SEQ_CONFIG">PA_DIG_PWR_SEQ_CONFIG</a></h4>
<ul>
<li>Group: 0x22</li>
<li>Index: 0x06</li>
<li>Summary: Configuration for digital power sequencing.</li>
<li>Purpose:</li>
<ul><li>
Configures the digital power sequencing delay and step size when DIG_PWR_SEQ in <a href="#prop-PA_MODE">PA_MODE</a>
 is enabled or during the <a href="#cmd-TX_HOP"><code>TX_HOP</code></a>
 command.</li><li>
The digital power sequencing step size is defaulted to a step of 1.</li></ul>
<li>Defaults: 0x03</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PA_DIG_PWR_SEQ_CONFIG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="1">INC_STEP_SIZE</td>
<td colspan="7">DIG_PWR_SEQ_DELAY</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="1">0x0</td>
<td colspan="7">0x3</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PA%3APA_DIG_PWR_SEQ_CONFIG">PA_DIG_PWR_SEQ_CONFIG</a><ul>
<li><a name="field-PA_DIG_PWR_SEQ_CONFIG%3AINC_STEP_SIZE">INC_STEP_SIZE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Increase the digital power sequencing step size from 1 to 2. This allows for quicker digital power sequence times by incrementing the DDAC by 2 for every delay.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">STEP_SIZE_1</td><td>0</td><td align="left">
<ul><li>
Digital power sequenecing step size of 1 DDAC level.</li></ul>
</td></tr>
<tr valign="top"><td align="left">STEP_SIZE_2</td><td>1</td><td align="left">
<ul><li>
Digital power sequencing step size of 2 DDAC levels.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PA_DIG_PWR_SEQ_CONFIG%3ADIG_PWR_SEQ_DELAY">DIG_PWR_SEQ_DELAY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Digital power sequencing delay between PA steps defined in .1us.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x3</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-SYNTH">SYNTH</a></h3>
<h4><a name="prop-SYNTH_PFDCP_CPFF">SYNTH_PFDCP_CPFF</a></h4>
<ul>
<li>Group: 0x23</li>
<li>Index: 0x00</li>
<li>Summary: Feed forward charge pump current selection.</li>
<li>Purpose:</li>
<ul><li>
The charge pump and loop filter in the PLL Synthesizer have two paths:  an integral path and a feed-forward path.  This property adjusts the charge pump gain (i.e., current) for the feed-forward path.</li><li>
The coding of the MSB (bit 5) of the CP_FF_CUR field is inverted.  As a result, the minimum charge pump gain setting is obtained for a value of CP_FF_CUR=0x20, while CP_FF_CUR=0x00 corresponds to a mid-range charge pump gain setting and 0x1F corresponds to the maximum charge pump gain setting.</li><li>
The step size or resolution of the charge pump feed-forward current is in increments of 5 uA.  Thus the range of values provided by the CP_FF_CUR field is from 0 uA to 315 uA.</li><li>
CP_FF_CUR_TEST is a test bit and is not recommended for general customer applications. The CP_FF_CUR_TEST bit is not binary-weighted with the CP_FF_CUR field but instead provides an additional 160 uA, when set.</li><li>
NOTE:  the primary purpose of the SYNTH group of properties is to adjust the PLL loop bandwidth to a value appropriate for the selected data rate.  Silicon Labs does not recommend modifying these properties away from the values suggested by the WDS Calculator.</li></ul>
<li>Defaults: 0x2c</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">SYNTH_PFDCP_CPFF</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0</td>
<td colspan="1">CP_FF_CUR_TEST</td>
<td colspan="6">CP_FF_CUR</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="6">0x2c</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-SYNTH%3ASYNTH_PFDCP_CPFF">SYNTH_PFDCP_CPFF</a><ul>
<li><a name="field-SYNTH_PFDCP_CPFF%3ACP_FF_CUR_TEST">CP_FF_CUR_TEST</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Do not increase charge pump current.  Use value defined in CP_FF_CUR.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Increase charge pump current defined in CP_FF_CUR by 160 uA.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-SYNTH_PFDCP_CPFF%3ACP_FF_CUR">CP_FF_CUR</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_32</td><td>32</td><td align="left">
<ul><li>
0 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_33</td><td>33</td><td align="left">
<ul><li>
5 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_64</td><td>63</td><td align="left">
<ul><li>
155 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
160 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
165 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_31</td><td>31</td><td align="left">
<ul><li>
315 uA.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-SYNTH_PFDCP_CPINT">SYNTH_PFDCP_CPINT</a></h4>
<ul>
<li>Group: 0x23</li>
<li>Index: 0x01</li>
<li>Summary: Integration charge pump current selection.</li>
<li>Purpose:</li>
<ul><li>
The charge pump and loop filter in the PLL Synthesizer have two paths:  an integral path and a feed-forward path.  This property adjusts the charge pump gain (i.e., current) for the integral path.</li><li>
The coding of the MSB (bit 3) of the CP_INT_CUR field is inverted.  As a result, the minimum charge pump gain setting is obtained for a value of CP_INT_CUR=0x08, while CP_INT_CUR=0x00 corresponds to a mid-range charge pump gain setting and 0x07 corresponds to the maximum charge pump gain setting.</li><li>
The step size or resolution of the charge pump feed-forward current is in increments of 5 uA.  Thus the range of values provided by the CP_INT_CUR field is from 0 uA to 75 uA.</li><li>
NOTE:  the primary purpose of the SYNTH group of properties is to adjust the PLL loop bandwidth to a value appropriate for the selected data rate.  Silicon Labs does not recommend modifying these properties away from the values suggested by the WDS Calculator.</li></ul>
<li>Defaults: 0x0e</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">SYNTH_PFDCP_CPINT</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="4">CP_INT_CUR</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="4">0xe</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-SYNTH%3ASYNTH_PFDCP_CPINT">SYNTH_PFDCP_CPINT</a><ul>
<li><a name="field-SYNTH_PFDCP_CPINT%3ACP_INT_CUR">CP_INT_CUR</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_8</td><td>8</td><td align="left">
<ul><li>
0 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_9</td><td>9</td><td align="left">
<ul><li>
5 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_10</td><td>10</td><td align="left">
<ul><li>
10 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_11</td><td>11</td><td align="left">
<ul><li>
15 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_12</td><td>12</td><td align="left">
<ul><li>
20 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_13</td><td>13</td><td align="left">
<ul><li>
25 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_14</td><td>14</td><td align="left">
<ul><li>
30 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_15</td><td>15</td><td align="left">
<ul><li>
35 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
40 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
45 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
50 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
55 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_4</td><td>4</td><td align="left">
<ul><li>
60 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_5</td><td>5</td><td align="left">
<ul><li>
65 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_6</td><td>6</td><td align="left">
<ul><li>
70 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_7</td><td>7</td><td align="left">
<ul><li>
Maximum 75 uA.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-SYNTH_VCO_KV">SYNTH_VCO_KV</a></h4>
<ul>
<li>Group: 0x23</li>
<li>Index: 0x02</li>
<li>Summary: Gain scaling factors (Kv) for the VCO tuning varactors on both the integrated-path and feed forward path.</li>
<li>Purpose:</li>
<ul><li>
The charge pump, loop filter, and VCO tuning varactors in the PLL Synthesizer have two paths:  an integral path and a feed-forward path.  This property adjusts the gain scaling factors (Kv) for the tuning varactors in both the integral path and the feed-forward path.  The adjustment of the gain factors is accomplished internally by switching in different number of varactor devices.</li><li>
NOTE:  the primary purpose of the SYNTH group of properties is to adjust the PLL loop bandwidth to a value appropriate for the selected data rate.  Silicon Labs does not recommend modifying these properties away from the values suggested by the WDS Calculator.</li></ul>
<li>Defaults: 0x0b</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">SYNTH_VCO_KV</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">RESERVED</td>
<td colspan="2">KV_DIR</td>
<td colspan="2">KV_INT</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x02</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="2">0x2</td>
<td colspan="2">0x3</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-SYNTH%3ASYNTH_VCO_KV">SYNTH_VCO_KV</a><ul>
<li><a name="field-SYNTH_VCO_KV%3ARESERVED">RESERVED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Reserved.  Always write 0.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-SYNTH_VCO_KV%3AKV_DIR">KV_DIR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Sets the scaling factor on the tuning varactor gain (Kv_dir) in the feed-forward path (i.e., direct path).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">GND</td><td>0</td><td align="left">
<ul><li>
Sets the feed-forward (i.e., direct) path tuning varactor input port of the
                                        VCO to GND (used only for testing purposes).</li></ul>
</td></tr>
<tr valign="top"><td align="left">HALF</td><td>1</td><td align="left">
<ul><li>
Sets kv_dir to 1/2 of its maximum value.</li></ul>
</td></tr>
<tr valign="top"><td align="left">MAX</td><td>2</td><td align="left">
<ul><li>
Sets kv_dir to its maximum value.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
Sets kv_dir to its maximum value (same as kv_dir = 2).</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-SYNTH_VCO_KV%3AKV_INT">KV_INT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Sets the scaling factor on the tuning varactor gain (Kv_int) in the integral path.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">GND</td><td>0</td><td align="left">
<ul><li>
Sets the integral path tuning varactor input port of the VCO to GND (used only for testing purposes).</li></ul>
</td></tr>
<tr valign="top"><td align="left">33PERCENT</td><td>1</td><td align="left">
<ul><li>
Sets kv_int to 1/3 of its maximum value.</li></ul>
</td></tr>
<tr valign="top"><td align="left">66PENCENT</td><td>2</td><td align="left">
<ul><li>
Sets kv_int to 2/3 of its maximum value.</li></ul>
</td></tr>
<tr valign="top"><td align="left">MAX</td><td>3</td><td align="left">
<ul><li>
Sets kv_int to its maximum value.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-SYNTH_LPFILT3">SYNTH_LPFILT3</a></h4>
<ul>
<li>Group: 0x23</li>
<li>Index: 0x03</li>
<li>Summary: Value of resistor R2 in feed-forward path of loop filter.</li>
<li>Purpose:</li>
<ul><li>
The loop filter in the feed-forward path contains three lowpass filter poles:  R1-C1,  R2-C2, and R3-C3.    </li><li>
The LPF_FF_R2 field adjusts the value of resistor R2, and thus adjusts the cutoff frequency of the R2-C2 lowpass filter pole.    </li><li>
Additionally, the resistor R2 affects the DC gain of the transistor Gm stage in the feed-forward path.     Increasing the value of R2 has the effect of increasing the feed-forward path gain.    </li><li>
The value of R2 is in increments of 18 k, ranging from a minimum value of 18 k to a maximum of 144 k.    </li><li>
NOTE:  the primary purpose of the SYNTH group of properties is to adjust the PLL loop bandwidth to a value appropriate for the selected data rate.     Silicon Labs does not recommend modifying these properties away from the values suggested by the WDS Calculator.</li></ul>
<li>Defaults: 0x04</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">SYNTH_LPFILT3</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x03</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="3">LPF_FF_R2</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x03</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="3">0x4</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-SYNTH%3ASYNTH_LPFILT3">SYNTH_LPFILT3</a><ul>
<li><a name="field-SYNTH_LPFILT3%3ALPF_FF_R2">LPF_FF_R2</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
R2 = 18 k</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
R2 = 36 k</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
R2 = 54 k</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
R2 = 72 k</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_4</td><td>4</td><td align="left">
<ul><li>
R2 = 90 k</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_5</td><td>5</td><td align="left">
<ul><li>
R2 = 108 k</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_6</td><td>6</td><td align="left">
<ul><li>
R2 = 126 k</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_7</td><td>7</td><td align="left">
<ul><li>
R2 = 144 k</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-SYNTH_LPFILT2">SYNTH_LPFILT2</a></h4>
<ul>
<li>Group: 0x23</li>
<li>Index: 0x04</li>
<li>Summary: Value of capacitor C2 in feed-forward path of loop filter.</li>
<li>Purpose:</li>
<ul><li>
The loop filter in the feed-forward path contains three lowpass filter poles:  R1-C1, R2-C2, and R3-C3.</li><li>
The LPF_FF_C2 field adjusts the value of capacitor C2, and thus adjusts the cutoff frequency of the R2-C2 lowpass filter pole.</li><li>
The value of C2 is in increments of 335 fF, ranging from a minimum value of 877 fF to a maximum of 11.25 pF.</li><li>
NOTE:  the primary purpose of the SYNTH group of properties is to adjust the PLL loop bandwidth to a value appropriate for the selected data rate.  Silicon Labs does not recommend modifying these properties away from the values suggested by the WDS Calculator.</li></ul>
<li>Defaults: 0x0c</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">SYNTH_LPFILT2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x04</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="5">LPF_FF_C2</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x04</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="5">0xc</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-SYNTH%3ASYNTH_LPFILT2">SYNTH_LPFILT2</a><ul>
<li><a name="field-SYNTH_LPFILT2%3ALPF_FF_C2">LPF_FF_C2</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
C2 = 877 fF.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>31</td><td align="left">
<ul><li>
C2 = 11.25 pF.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-SYNTH_LPFILT1">SYNTH_LPFILT1</a></h4>
<ul>
<li>Group: 0x23</li>
<li>Index: 0x05</li>
<li>Summary: Value of capacitors C1 and C3 in feed-forward path of loop filter.</li>
<li>Purpose:</li>
<ul><li>
The loop filter in the feed-forward path contains three lowpass filter poles:    R1-C1, R2-C2, and R3-C3.</li><li>
The LPF_FF_C3 field adjusts the value of capacitor C3,    and thus adjusts the cutoff frequency of the R3-C3 lowpass filter pole.    The value of resistor R3 is not adjustable and is fixed at R3=2 k.    </li><li>
The value of C3 is in increments of 1 pF,    ranging from a minimum value of 9 pF  to a maximum of 12 pF.    </li><li>
The total value of capacitor C1 is determined by a 3-bit binary-weighted field LPF_FF_C1 in increments of 380 fF,    and a 2-bit offset field LPF_FF_C1_CODE in increments of 1 pF,    plus an additional fixed capacitance of 4.55 pF.     Thus the total value of capacitor C1 may be described by the following equation:    </li><li>
C1 = 4.55pF + 380fF*LPF_FF_C1 + 1pF*LPF_FF_C1_CODE    </li><li>
The value of resistor R1 is not adjustable and is fixed at R1=9.86 k.    </li><li>
NOTE:  the primary purpose of the SYNTH group of properties is to adjust the PLL loop bandwidth to a value appropriate for the selected data rate.     Silicon Labs does not recommend modifying these properties away from the values suggested by the WDS Calculator.</li></ul>
<li>Defaults: 0x73</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">SYNTH_LPFILT1</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x05</td>
<td>0</td>
<td colspan="3">LPF_FF_C1</td>
<td colspan="2">LPF_FF_C1_CODE</td>
<td colspan="2">LPF_FF_C3</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x05</td>
<td>0x0</td>
<td colspan="3">0x7</td>
<td colspan="2">0x0</td>
<td colspan="2">0x3</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-SYNTH%3ASYNTH_LPFILT1">SYNTH_LPFILT1</a><ul>
<li><a name="field-SYNTH_LPFILT1%3ALPF_FF_C1">LPF_FF_C1</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Sets the fine-tune value of C1 in increments of 380 fF, with a range from 4.55 pF to 7.21 pF.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
C1 = 4.55 pF.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
C1 = 4.93 pF.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
C1 = 5.31 pF.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
C1 = 5.69 pF.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_4</td><td>4</td><td align="left">
<ul><li>
C1 = 6.07 pF.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_5</td><td>5</td><td align="left">
<ul><li>
C1 = 6.45 pF.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_6</td><td>6</td><td align="left">
<ul><li>
C1 = 6.83 pF.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_7</td><td>7</td><td align="left">
<ul><li>
C1 = 7.21 pF.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-SYNTH_LPFILT1%3ALPF_FF_C1_CODE">LPF_FF_C1_CODE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Offsets the value of C1 in increments of 1pF, with a range of 0pF to 3pF.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
delta C1 = 0 pF.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
delta C1 = 1 pF.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
delta C1 = 2 pF.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
delta C1 = 3 pF.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-SYNTH_LPFILT1%3ALPF_FF_C3">LPF_FF_C3</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Sets the value of C3 in increments of 1pF, with a range of 9pF to 12pF.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
C3 =  9 pF.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
C3 = 10 pF.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
C3 = 11 pF.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
C3 = 12 pF.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-SYNTH_LPFILT0">SYNTH_LPFILT0</a></h4>
<ul>
<li>Group: 0x23</li>
<li>Index: 0x06</li>
<li>Summary: Bias current of the active amplifier in the feed-forward loop filter.</li>
<li>Purpose:</li>
<ul><li>
The loop filter in the PLL Synthesizer consists of an integrator path and a feed-forward path.     The feed-forward path consists of an active amplifier (a single transistor Gm stage) with three lowpass filter poles and one right-half plane zero.     </li><li>
This property selects the bias current of the active amplifier.     Adjusting the bias current has the additional effect of changing the DC gain of the amplifier which in turn affects the PLL loop bandwidth and loop dynamics.     The suggested settings for all other properties within the SYNTH group assume the default value of SYNTH_LPFILT0 = 0x03 = 100A.     In the event a different value of bias current is selected, it would become necessary to modify all other SYNTH properties in order to maintain the desired PLL loop bandwidth.     For this reason, Silicon Labs recommends leaving this property at its default value. </li></ul>
<li>Defaults: 0x03</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">SYNTH_LPFILT0</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x06</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="2">LPF_FF_BIAS</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x06</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="2">0x3</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-SYNTH%3ASYNTH_LPFILT0">SYNTH_LPFILT0</a><ul>
<li><a name="field-SYNTH_LPFILT0%3ALPF_FF_BIAS">LPF_FF_BIAS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the bias current of the amplifier in the feed-forward loop filter path. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
25 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
34 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_2</td><td>2</td><td align="left">
<ul><li>
50 uA.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_3</td><td>3</td><td align="left">
<ul><li>
100 uA.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-SYNTH_VCO_KVCAL">SYNTH_VCO_KVCAL</a></h4>
<ul>
<li>Group: 0x23</li>
<li>Index: 0x07</li>
<li>Summary: Scaling entire KV of VCO.</li>
<li>Purpose:</li>
<ul><li>
Scaling on VCO KV for all parameters.</li></ul>
<li>Defaults: 0x05</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">SYNTH_VCO_KVCAL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x07</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">LADR_SELECT</td>
<td colspan="4">KVCAL</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x07</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="4">0x5</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-SYNTH%3ASYNTH_VCO_KVCAL">SYNTH_VCO_KVCAL</a><ul>
<li><a name="field-SYNTH_VCO_KVCAL%3ALADR_SELECT">LADR_SELECT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enable VCO ladder.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Disable VCO ladder.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Enable VCO ladder.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-SYNTH_VCO_KVCAL%3AKVCAL">KVCAL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Sets the scaling on the VCO ladder where 0 is the max voltage setting and 15 is the min voltage setting.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-EZCONFIG">EZCONFIG</a></h3>
<h4><a name="prop-EZCONFIG_MODULATION">EZCONFIG_MODULATION</a></h4>
<ul>
<li>Group: 0x24</li>
<li>Index: 0x00</li>
<li>Summary: Selects the type of modulation using the EZConfig feature.</li>
<li>Purpose:</li>
<ul><li>
This property configures the Modem in the chip for transmission/reception of the following modulation types: OOK, 2FSK, and 2GFSK modulation.</li><li>
In TX mode, this property is additionally used to select the source of the TX data stream,
    and whether that TX data stream is from a synchronous or asynchronous source (in Direct mode only)."</li><li>
The Modem must be configured for transmission/reception of only one type of modulation throughout the entire packet;    it is not possible (for example) to use OOK modulation over certain fields and (G)FSK modulation over other fields. </li></ul>
<li>Defaults: 0x02</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">EZCONFIG_MODULATION</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="1">TX_DIRECT_MODE_TYPE</td>
<td colspan="2">TX_DIRECT_MODE_GPIO</td>
<td colspan="2">MOD_SOURCE</td>
<td>0</td>
<td colspan="2">MOD_TYPE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="1">0x0</td>
<td colspan="2">0x0</td>
<td colspan="2">0x0</td>
<td>0x0</td>
<td colspan="2">0x2</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-EZCONFIG%3AEZCONFIG_MODULATION">EZCONFIG_MODULATION</a><ul>
<li><a name="field-EZCONFIG_MODULATION%3ATX_DIRECT_MODE_TYPE">TX_DIRECT_MODE_TYPE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit determines whether a real-time TX data stream (applied to the chip on a selected GPIO input pin)    is processed in synchronous or asynchronous fashion.  This bit is applicable only in TX mode,     and only when the MOD_SOURCE field is also set for TX Direct mode.
    </li><li>
In TX Direct Synchronous mode, the chip controls the transmit data rate by outputting a TX bit clock (GPIO_PIN_CFG=0x10).     The host MCU receives the rising edge of the TX clock and responds by outputting one bit for each clock tick;    the chip clocks in this new data bit on the subsequent falling edge of the TX clock.    All 2-level modulation modes (OOK, 2FSK, 2GFSK) are supported.
    </li><li>
In TX Direct Asynchronous mode, the host MCU controls the transmit data rate;    the RFIC has no knowledge of the rate of the incoming TX data stream but simply oversamples the data as fast as possible to determine the bit edge transitions.     OOK and 2FSK are supported, but 2GFSK is not supported in this mode.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">SYNC</td><td>0</td><td align="left">
<ul><li>
TX Direct Synchronous mode</li></ul>
</td></tr>
<tr valign="top"><td align="left">ASYNC</td><td>1</td><td align="left">
<ul><li>
TX Direct Asynchronous mode</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-EZCONFIG_MODULATION%3ATX_DIRECT_MODE_GPIO">TX_DIRECT_MODE_GPIO</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This field determines which GPIO pin is selected by the Modem as the modulation data source during TX Direct mode.     This field is applicable only in TX mode, and only when the MOD_SOURCE field is also set for TX Direct mode.
    </li><li>
This bit does not automatically configure the selected GPIO pin as a digital input pin;    it remains necessary to additionally configure the desired GPIO pin as a CMOS-compatible input pin by setting GPIO_PIN_CFG=0x04. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">GPIO0</td><td>0</td><td align="left">
<ul><li>
Use GPIO0 as the data source in TX Direct mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">GPIO1</td><td>1</td><td align="left">
<ul><li>
Use GPIO1 as the data source in TX Direct mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">GPIO2</td><td>2</td><td align="left">
<ul><li>
Use GPIO2 as the data source in TX Direct mode.</li></ul>
</td></tr>
<tr valign="top"><td align="left">GPIO3</td><td>3</td><td align="left">
<ul><li>
Use GPIO3 as the data source in TX Direct mode.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-EZCONFIG_MODULATION%3AMOD_SOURCE">MOD_SOURCE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This field selects the source of modulation during TX mode.     It is applicable only in TX mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">PACKET</td><td>0</td><td align="left">
<ul><li>
The modulation is sourced from the TX FIFO in the packet handler.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIRECT</td><td>1</td><td align="left">
<ul><li>
The modulation is sourced in real-time (i.e., TX Direct Mode) from a GPIO pin, as selected by the TX_DIRECT_MODE_GPIO field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">PSEUDO</td><td>2</td><td align="left">
<ul><li>
The modulation is sourced from the internal pseudo-random generator.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-EZCONFIG_MODULATION%3AMOD_TYPE">MOD_TYPE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This field configures the Modem for transmission or reception of the desired type of modulation.
    </li><li>
With the exception of CW mode (a TX-only function), this field is applicable in both TX and RX modes.
</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">CW</td><td>0</td><td align="left">
<ul><li>
CW.</li></ul>
</td></tr>
<tr valign="top"><td align="left">OOK</td><td>1</td><td align="left">
<ul><li>
OOK.</li></ul>
</td></tr>
<tr valign="top"><td align="left">2FSK</td><td>2</td><td align="left">
<ul><li>
2FSK.</li></ul>
</td></tr>
<tr valign="top"><td align="left">2GFSK</td><td>3</td><td align="left">
<ul><li>
2GFSK.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-EZCONFIG_CONFIG_SELECT">EZCONFIG_CONFIG_SELECT</a></h4>
<ul>
<li>Group: 0x24</li>
<li>Index: 0x01</li>
<li>Summary: REMOVED as of fw_3_0_9 Used to be: Select the index from EZ config table.</li>
<li>Purpose:</li>
<ul><li>
This property selects the configuration index from a predefined EZConfig table.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">EZCONFIG_CONFIG_SELECT</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">CONFIG_INDEX</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-EZCONFIG%3AEZCONFIG_CONFIG_SELECT">EZCONFIG_CONFIG_SELECT</a><ul>
<li><a name="field-EZCONFIG_CONFIG_SELECT%3ACONFIG_INDEX">CONFIG_INDEX</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NONE</td><td>0</td><td align="left">
<ul><li>
Select none</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_1</td><td>1</td><td align="left">
<ul><li>
001_Fc283-350MHz_2GFSK_loPPM_2.4kbps_BW76kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_2</td><td>2</td><td align="left">
<ul><li>
002_Fc283-350MHz_2GFSK_loPPM_4.8kbps_BW76kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_3</td><td>3</td><td align="left">
<ul><li>
003_Fc283-350MHz_2GFSK_loPPM_5.0kbps_BW76kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_4</td><td>4</td><td align="left">
<ul><li>
004_Fc283-350MHz_2GFSK_loPPM_9.6kbps_BW76kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_5</td><td>5</td><td align="left">
<ul><li>
005_Fc283-350MHz_2GFSK_loPPM_10.0kbps_BW76kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_6</td><td>6</td><td align="left">
<ul><li>
006_Fc283-350MHz_2GFSK_loPPM_15.0kbps_BW76kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_7</td><td>7</td><td align="left">
<ul><li>
007_Fc283-350MHz_2GFSK_loPPM_19.2kbps_BW76kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_8</td><td>8</td><td align="left">
<ul><li>
008_Fc283-350MHz_2GFSK_loPPM_20.0kbps_BW76kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_9</td><td>9</td><td align="left">
<ul><li>
009_Fc283-350MHz_2GFSK_loPPM_38.4kbps_BW92kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_10</td><td>10</td><td align="left">
<ul><li>
010_Fc283-350MHz_2GFSK_loPPM_40.0kbps_BW92kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_11</td><td>11</td><td align="left">
<ul><li>
011_Fc283-350MHz_2GFSK_loPPM_50.0kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_12</td><td>12</td><td align="left">
<ul><li>
012_Fc283-350MHz_2GFSK_loPPM_96.0kbps_BW228kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_13</td><td>13</td><td align="left">
<ul><li>
013_Fc283-350MHz_2GFSK_loPPM_100.0kbps_BW228kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_14</td><td>14</td><td align="left">
<ul><li>
014_Fc283-350MHz_2GFSK_loPPM_128.0kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_15</td><td>15</td><td align="left">
<ul><li>
015_Fc283-350MHz_2GFSK_hiPPM_2.4kbps_BW228kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_16</td><td>16</td><td align="left">
<ul><li>
016_Fc283-350MHz_2GFSK_hiPPM_4.8kbps_BW228kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_17</td><td>17</td><td align="left">
<ul><li>
017_Fc283-350MHz_2GFSK_hiPPM_5.0kbps_BW228kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_18</td><td>18</td><td align="left">
<ul><li>
018_Fc283-350MHz_2GFSK_hiPPM_9.6kbps_BW228kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_19</td><td>19</td><td align="left">
<ul><li>
019_Fc283-350MHz_2GFSK_hiPPM_10.0kbps_BW228kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_20</td><td>20</td><td align="left">
<ul><li>
020_Fc283-350MHz_2GFSK_hiPPM_15.0kbps_BW228kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_21</td><td>21</td><td align="left">
<ul><li>
021_Fc283-350MHz_2GFSK_hiPPM_19.2kbps_BW228kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_22</td><td>22</td><td align="left">
<ul><li>
022_Fc283-350MHz_2GFSK_hiPPM_20.0kbps_BW228kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_23</td><td>23</td><td align="left">
<ul><li>
023_Fc283-350MHz_2GFSK_hiPPM_38.4kbps_BW228kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_24</td><td>24</td><td align="left">
<ul><li>
024_Fc283-350MHz_2GFSK_hiPPM_40.0kbps_BW228kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_25</td><td>25</td><td align="left">
<ul><li>
025_Fc283-350MHz_2GFSK_hiPPM_50.0kbps_BW228kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_26</td><td>26</td><td align="left">
<ul><li>
026_Fc283-350MHz_2GFSK_hiPPM_96.0kbps_BW228kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_27</td><td>27</td><td align="left">
<ul><li>
027_Fc283-350MHz_2GFSK_hiPPM_100.0kbps_BW228kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_28</td><td>28</td><td align="left">
<ul><li>
028_Fc283-350MHz_2GFSK_hiPPM_128.0kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_29</td><td>29</td><td align="left">
<ul><li>
029_Fc283-350MHz_OOK_0.5kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_30</td><td>30</td><td align="left">
<ul><li>
030_Fc283-350MHz_OOK_1.0kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_31</td><td>31</td><td align="left">
<ul><li>
031_Fc283-350MHz_OOK_2.4kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_32</td><td>32</td><td align="left">
<ul><li>
032_Fc283-350MHz_OOK_4.8kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_33</td><td>33</td><td align="left">
<ul><li>
033_Fc283-350MHz_OOK_5.0kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_34</td><td>34</td><td align="left">
<ul><li>
034_Fc283-350MHz_OOK_9.6kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_35</td><td>35</td><td align="left">
<ul><li>
035_Fc283-350MHz_OOK_10.0kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_36</td><td>36</td><td align="left">
<ul><li>
036_Fc283-350MHz_OOK_15.0kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_37</td><td>37</td><td align="left">
<ul><li>
037_Fc283-350MHz_OOK_19.2kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_38</td><td>38</td><td align="left">
<ul><li>
038_Fc283-350MHz_OOK_20.0kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_39</td><td>39</td><td align="left">
<ul><li>
039_Fc283-350MHz_OOK_38.4kbps_BW123kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_40</td><td>40</td><td align="left">
<ul><li>
040_Fc283-350MHz_OOK_40.0kbps_BW123kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_41</td><td>41</td><td align="left">
<ul><li>
041_Fc425-525MHz_2GFSK_loPPM_2.4kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_42</td><td>42</td><td align="left">
<ul><li>
042_Fc425-525MHz_2GFSK_loPPM_4.8kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_43</td><td>43</td><td align="left">
<ul><li>
043_Fc425-525MHz_2GFSK_loPPM_5.0kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_44</td><td>44</td><td align="left">
<ul><li>
044_Fc425-525MHz_2GFSK_loPPM_9.6kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_45</td><td>45</td><td align="left">
<ul><li>
045_Fc425-525MHz_2GFSK_loPPM_10.0kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_46</td><td>46</td><td align="left">
<ul><li>
046_Fc425-525MHz_2GFSK_loPPM_15.0kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_47</td><td>47</td><td align="left">
<ul><li>
047_Fc425-525MHz_2GFSK_loPPM_19.2kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_48</td><td>48</td><td align="left">
<ul><li>
048_Fc425-525MHz_2GFSK_loPPM_20.0kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_49</td><td>49</td><td align="left">
<ul><li>
049_Fc425-525MHz_2GFSK_loPPM_38.4kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_50</td><td>50</td><td align="left">
<ul><li>
050_Fc425-525MHz_2GFSK_loPPM_40.0kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_51</td><td>51</td><td align="left">
<ul><li>
051_Fc425-525MHz_2GFSK_loPPM_50.0kbps_BW114kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_52</td><td>52</td><td align="left">
<ul><li>
052_Fc425-525MHz_2GFSK_loPPM_96.0kbps_BW245kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_53</td><td>53</td><td align="left">
<ul><li>
053_Fc425-525MHz_2GFSK_loPPM_100.0kbps_BW245kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_54</td><td>54</td><td align="left">
<ul><li>
054_Fc425-525MHz_2GFSK_loPPM_128.0kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_55</td><td>55</td><td align="left">
<ul><li>
055_Fc425-525MHz_2GFSK_hiPPM_2.4kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_56</td><td>56</td><td align="left">
<ul><li>
056_Fc425-525MHz_2GFSK_hiPPM_4.8kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_57</td><td>57</td><td align="left">
<ul><li>
057_Fc425-525MHz_2GFSK_hiPPM_5.0kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_58</td><td>58</td><td align="left">
<ul><li>
058_Fc425-525MHz_2GFSK_hiPPM_9.6kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_59</td><td>59</td><td align="left">
<ul><li>
059_Fc425-525MHz_2GFSK_hiPPM_10.0kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_60</td><td>60</td><td align="left">
<ul><li>
060_Fc425-525MHz_2GFSK_hiPPM_15.0kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_61</td><td>61</td><td align="left">
<ul><li>
061_Fc425-525MHz_2GFSK_hiPPM_19.2kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_62</td><td>62</td><td align="left">
<ul><li>
062_Fc425-525MHz_2GFSK_hiPPM_20.0kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_63</td><td>63</td><td align="left">
<ul><li>
063_Fc425-525MHz_2GFSK_hiPPM_38.4kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_64</td><td>64</td><td align="left">
<ul><li>
064_Fc425-525MHz_2GFSK_hiPPM_40.0kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_65</td><td>65</td><td align="left">
<ul><li>
065_Fc425-525MHz_2GFSK_hiPPM_50.0kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_66</td><td>66</td><td align="left">
<ul><li>
066_Fc425-525MHz_2GFSK_hiPPM_96.0kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_67</td><td>67</td><td align="left">
<ul><li>
067_Fc425-525MHz_2GFSK_hiPPM_100.0kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_68</td><td>68</td><td align="left">
<ul><li>
068_Fc425-525MHz_2GFSK_hiPPM_128.0kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_69</td><td>69</td><td align="left">
<ul><li>
069_Fc425-525MHz_OOK_0.5kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_70</td><td>70</td><td align="left">
<ul><li>
070_Fc425-525MHz_OOK_1.0kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_71</td><td>71</td><td align="left">
<ul><li>
071_Fc425-525MHz_OOK_2.4kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_72</td><td>72</td><td align="left">
<ul><li>
072_Fc425-525MHz_OOK_4.8kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_73</td><td>73</td><td align="left">
<ul><li>
073_Fc425-525MHz_OOK_5.0kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_74</td><td>74</td><td align="left">
<ul><li>
074_Fc425-525MHz_OOK_9.6kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_75</td><td>75</td><td align="left">
<ul><li>
075_Fc425-525MHz_OOK_10.0kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_76</td><td>76</td><td align="left">
<ul><li>
076_Fc425-525MHz_OOK_15.0kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_77</td><td>77</td><td align="left">
<ul><li>
077_Fc425-525MHz_OOK_19.2kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_78</td><td>78</td><td align="left">
<ul><li>
078_Fc425-525MHz_OOK_20.0kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_79</td><td>79</td><td align="left">
<ul><li>
079_Fc425-525MHz_OOK_38.4kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_80</td><td>80</td><td align="left">
<ul><li>
080_Fc425-525MHz_OOK_40.0kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_81</td><td>81</td><td align="left">
<ul><li>
081_Fc850-950MHz_2GFSK_loPPM_2.4kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_82</td><td>82</td><td align="left">
<ul><li>
082_Fc850-950MHz_2GFSK_loPPM_4.8kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_83</td><td>83</td><td align="left">
<ul><li>
083_Fc850-950MHz_2GFSK_loPPM_5.0kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_84</td><td>84</td><td align="left">
<ul><li>
084_Fc850-950MHz_2GFSK_loPPM_9.6kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_85</td><td>85</td><td align="left">
<ul><li>
085_Fc850-950MHz_2GFSK_loPPM_10.0kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_86</td><td>86</td><td align="left">
<ul><li>
086_Fc850-950MHz_2GFSK_loPPM_15.0kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_87</td><td>87</td><td align="left">
<ul><li>
087_Fc850-950MHz_2GFSK_loPPM_19.2kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_88</td><td>88</td><td align="left">
<ul><li>
088_Fc850-950MHz_2GFSK_loPPM_20.0kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_89</td><td>89</td><td align="left">
<ul><li>
089_Fc850-950MHz_2GFSK_loPPM_38.4kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_90</td><td>90</td><td align="left">
<ul><li>
090_Fc850-950MHz_2GFSK_loPPM_40.0kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_91</td><td>91</td><td align="left">
<ul><li>
091_Fc850-950MHz_2GFSK_loPPM_50.0kbps_BW185kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_92</td><td>92</td><td align="left">
<ul><li>
092_Fc850-950MHz_2GFSK_loPPM_96.0kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_93</td><td>93</td><td align="left">
<ul><li>
093_Fc850-950MHz_2GFSK_loPPM_100.0kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_94</td><td>94</td><td align="left">
<ul><li>
094_Fc850-950MHz_2GFSK_loPPM_128.0kbps_BW305kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_95</td><td>95</td><td align="left">
<ul><li>
095_Fc850-950MHz_2GFSK_hiPPM_2.4kbps_BW593kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_96</td><td>96</td><td align="left">
<ul><li>
096_Fc850-950MHz_2GFSK_hiPPM_4.8kbps_BW593kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_97</td><td>97</td><td align="left">
<ul><li>
097_Fc850-950MHz_2GFSK_hiPPM_5.0kbps_BW593kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_98</td><td>98</td><td align="left">
<ul><li>
098_Fc850-950MHz_2GFSK_hiPPM_9.6kbps_BW593kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_99</td><td>99</td><td align="left">
<ul><li>
099_Fc850-950MHz_2GFSK_hiPPM_10.0kbps_BW593kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_100</td><td>100</td><td align="left">
<ul><li>
100_Fc850-950MHz_2GFSK_hiPPM_15.0kbps_BW593kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_101</td><td>101</td><td align="left">
<ul><li>
101_Fc850-950MHz_2GFSK_hiPPM_19.2kbps_BW593kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_102</td><td>102</td><td align="left">
<ul><li>
102_Fc850-950MHz_2GFSK_hiPPM_20.0kbps_BW593kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_103</td><td>103</td><td align="left">
<ul><li>
103_Fc850-950MHz_2GFSK_hiPPM_38.4kbps_BW593kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_104</td><td>104</td><td align="left">
<ul><li>
104_Fc850-950MHz_2GFSK_hiPPM_40.0kbps_BW593kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_105</td><td>105</td><td align="left">
<ul><li>
105_Fc850-950MHz_2GFSK_hiPPM_50.0kbps_BW593kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_106</td><td>106</td><td align="left">
<ul><li>
106_Fc850-950MHz_2GFSK_hiPPM_96.0kbps_BW593kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_107</td><td>107</td><td align="left">
<ul><li>
107_Fc850-950MHz_2GFSK_hiPPM_100.0kbps_BW593kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_108</td><td>108</td><td align="left">
<ul><li>
108_Fc850-950MHz_2GFSK_hiPPM_128.0kbps_BW593kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_109</td><td>109</td><td align="left">
<ul><li>
109_Fc850-950MHz_OOK_0.5kbps_BW370kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_110</td><td>110</td><td align="left">
<ul><li>
110_Fc850-950MHz_OOK_1.0kbps_BW370kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_111</td><td>111</td><td align="left">
<ul><li>
111_Fc850-950MHz_OOK_2.4kbps_BW370kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_112</td><td>112</td><td align="left">
<ul><li>
112_Fc850-950MHz_OOK_4.8kbps_BW370kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_113</td><td>113</td><td align="left">
<ul><li>
113_Fc850-950MHz_OOK_5.0kbps_BW370kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_114</td><td>114</td><td align="left">
<ul><li>
114_Fc850-950MHz_OOK_9.6kbps_BW370kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_115</td><td>115</td><td align="left">
<ul><li>
115_Fc850-950MHz_OOK_10.0kbps_BW370kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_116</td><td>116</td><td align="left">
<ul><li>
116_Fc850-950MHz_OOK_15.0kbps_BW370kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_117</td><td>117</td><td align="left">
<ul><li>
117_Fc850-950MHz_OOK_19.2kbps_BW370kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_118</td><td>118</td><td align="left">
<ul><li>
118_Fc850-950MHz_OOK_20.0kbps_BW370kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_119</td><td>119</td><td align="left">
<ul><li>
119_Fc850-950MHz_OOK_38.4kbps_BW370kHz</li></ul>
</td></tr>
<tr valign="top"><td align="left">CONFIG_INDEX_120</td><td>120</td><td align="left">
<ul><li>
120_Fc850-950MHz_OOK_40.0kbps_BW370kHz</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-EZCONFIG_PKT">EZCONFIG_PKT</a></h4>
<ul>
<li>Group: 0x24</li>
<li>Index: 0x02</li>
<li>Summary: REMOVED as of fw_3_0_9 Used to be: EZ config packet configure.</li>
<li>Purpose:</li>
<ul><li>
This property selects packet configuration options.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">EZCONFIG_PKT</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CRC_ENABLE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x02</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-EZCONFIG%3AEZCONFIG_PKT">EZCONFIG_PKT</a><ul>
<li><a name="field-EZCONFIG_PKT%3ACRC_ENABLE">CRC_ENABLE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects whether to use CRC for transmit or recieive.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
DISABLE - CRC will not be automatically transmitted, and will not be checked on receive.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
ENABLE - CRC will be appended to the end of the transmitted packet and will be checked on receive.  If a CRC error occurs the CRC .</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-EZCONFIG_XO_TUNE">EZCONFIG_XO_TUNE</a></h4>
<ul>
<li>Group: 0x24</li>
<li>Index: 0x03</li>
<li>Summary: Configure the internal capacitor frequency tuning bank for the crystal oscillator.</li>
<li>Purpose:</li>
<ul><li>
The chip provides internal adjustable capacitor banks for the purpose of tuning the frequency of the crystal oscillator.     These capacitances effectively appear in shunt from the XIN and XOUT pins to GND.     </li><li>
TUNE_VALUE = 0x00 corresponds to the lowest tuning capacitance value and thus the highest frequency of oscillation,    while TUNE_VALUE = 0x7F corresponds to the highest tuning capacitance value and the lowest frequency of oscillation.     Each LSB code corresponds to ~70 fF change in capacitance.     </li><li>
The total frequency adjustment range (for a typical 30 MHz crystal blank) is approximately 100 ppm. </li></ul>
<li>Defaults: 0x40</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">EZCONFIG_XO_TUNE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x03</td>
<td>0</td>
<td colspan="7">TUNE_VALUE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x03</td>
<td>0x0</td>
<td colspan="7">0x40</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-EZCONFIG%3AEZCONFIG_XO_TUNE">EZCONFIG_XO_TUNE</a><ul>
<li><a name="field-EZCONFIG_XO_TUNE%3ATUNE_VALUE">TUNE_VALUE</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">FASTEST_FREQUENCY</td><td>0</td><td align="left">
<ul><li>
Lowest capacitance (i.e., highest oscillation frequency).</li></ul>
</td></tr>
<tr valign="top"><td align="left">SLOWEST_FREQUENCY</td><td>127</td><td align="left">
<ul><li>
Highest capacitance (i.e., lowest oscillation frequency).</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-EZCONFIG_SPARE0">EZCONFIG_SPARE0</a></h4>
<ul>
<li>Group: 0x24</li>
<li>Index: 0x04</li>
<li>Summary: For use in patches.</li>
<li>Purpose:</li>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">EZCONFIG_SPARE0</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="8">SPARE0</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-EZCONFIG%3AEZCONFIG_SPARE0">EZCONFIG_SPARE0</a><ul>
<li><a name="field-EZCONFIG_SPARE0%3ASPARE0">SPARE0</a>
<dl><dt>Description:</dt><dd>
<ul><li>
spare0</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-EZCONFIG_SPARE1">EZCONFIG_SPARE1</a></h4>
<ul>
<li>Group: 0x24</li>
<li>Index: 0x05</li>
<li>Summary: For use in patches.</li>
<li>Purpose:</li>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">EZCONFIG_SPARE1</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="8">SPARE1</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-EZCONFIG%3AEZCONFIG_SPARE1">EZCONFIG_SPARE1</a><ul>
<li><a name="field-EZCONFIG_SPARE1%3ASPARE1">SPARE1</a>
<dl><dt>Description:</dt><dd>
<ul><li>
spare1</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-EZCONFIG_SPARE2">EZCONFIG_SPARE2</a></h4>
<ul>
<li>Group: 0x24</li>
<li>Index: 0x06</li>
<li>Summary: For use in patches.</li>
<li>Purpose:</li>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">EZCONFIG_SPARE2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="8">SPARE2</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-EZCONFIG%3AEZCONFIG_SPARE2">EZCONFIG_SPARE2</a><ul>
<li><a name="field-EZCONFIG_SPARE2%3ASPARE2">SPARE2</a>
<dl><dt>Description:</dt><dd>
<ul><li>
spare2</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-EZCONFIG_SPARE3">EZCONFIG_SPARE3</a></h4>
<ul>
<li>Group: 0x24</li>
<li>Index: 0x07</li>
<li>Summary: For use in patches.</li>
<li>Purpose:</li>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">EZCONFIG_SPARE3</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x07</td>
<td colspan="8">SPARE3</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x07</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-EZCONFIG%3AEZCONFIG_SPARE3">EZCONFIG_SPARE3</a><ul>
<li><a name="field-EZCONFIG_SPARE3%3ASPARE3">SPARE3</a>
<dl><dt>Description:</dt><dd>
<ul><li>
spare3</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-EZCONFIG_SPARE4">EZCONFIG_SPARE4</a></h4>
<ul>
<li>Group: 0x24</li>
<li>Index: 0x08</li>
<li>Summary: For use in patches.</li>
<li>Purpose:</li>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">EZCONFIG_SPARE4</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x08</td>
<td colspan="8">SPARE4</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x08</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-EZCONFIG%3AEZCONFIG_SPARE4">EZCONFIG_SPARE4</a><ul>
<li><a name="field-EZCONFIG_SPARE4%3ASPARE4">SPARE4</a>
<dl><dt>Description:</dt><dd>
<ul><li>
spare4</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-MATCH">MATCH</a></h3>
<h4><a name="prop-MATCH_VALUE_1">MATCH_VALUE_1</a></h4>
<ul>
<li>Group: 0x30</li>
<li>Index: 0x00</li>
<li>Summary: Match value to be compared with the result of logically AND-ing (bit-wise) the Mask 1 value with the received Match 1 byte. </li>
<li>Purpose:</li>
<ul><li>
The chip provides for Matching functionality on up to 4 bytes in the Data field(s).            This is typically used to implement a Header Check or Broadcast Check capability.
          </li><li>
The Match functionality consists of taking the received value of a specified data byte,           logically AND-ing it with a programmed Mask value, and then comparing the result with a programmed target Match value.            The logical result of this comparison (TRUE or FALSE) can be logically combined with the results of comparisons for the remaining Match bytes;           the final logical result determines whether or not the overall packet is considered to match.
          </li><li>
This property defines the target Match 1 value to be compared with the result of logically AND-ing (bit-wise) the Mask 1 value with the received Match 1 byte.
          </li><li>
Please refer to the text description for <a href="#prop-MATCH_MASK_1">MATCH_MASK_1</a>
 and <a href="#prop-MATCH_CTRL_1">MATCH_CTRL_1</a>
 for more details regarding the Match byte functionality.
</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MATCH_VALUE_1</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="8">VALUE_1</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MATCH%3AMATCH_VALUE_1">MATCH_VALUE_1</a><ul>
<li><a name="field-MATCH_VALUE_1%3AVALUE_1">VALUE_1</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Match 1 value to be compared with the result of logically AND-ing (bit-wise) the Mask 1 value with the received Match 1 byte.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MATCH_MASK_1">MATCH_MASK_1</a></h4>
<ul>
<li>Group: 0x30</li>
<li>Index: 0x01</li>
<li>Summary: Mask value to be logically AND-ed (bit-wise) with the Match 1 byte.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for Matching functionality on up to 4 bytes in the Data field(s).            This is typically used to implement a Header Check or Broadcast Check capability.
          </li><li>
The Match functionality consists of taking the received value of a specified data byte,           logically AND-ing it with a programmed Mask value, and then comparing the result with a programmed target Match value.            The logical result of this comparison (TRUE or FALSE) can be logically combined with the results of comparisons for the remaining Match bytes;           the final logical result determines whether or not the overall packet is considered to match.           </li><li>
This property defines the Mask 1 value to be logically AND-ed (bit-wise) with the Match 1 byte, prior to comparison with the target Match 1 value.            Example:  if it is desired to match only the top 4 bits of the Match 1 byte, it would be necessary to set MATCH_MASK_1[7:0] = 0xF0.
          </li><li>
Please refer to the text description for <a href="#prop-MATCH_VALUE_1">MATCH_VALUE_1</a>
 and <a href="#prop-MATCH_CTRL_1">MATCH_CTRL_1</a>
 for more details regarding the Match byte functionality. </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MATCH_MASK_1</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">MASK_1</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MATCH%3AMATCH_MASK_1">MATCH_MASK_1</a><ul>
<li><a name="field-MATCH_MASK_1%3AMASK_1">MASK_1</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Mask value to be logicalled AND-ed with the Match 1 byte.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MATCH_CTRL_1">MATCH_CTRL_1</a></h4>
<ul>
<li>Group: 0x30</li>
<li>Index: 0x02</li>
<li>Summary: Enable for Packet Match functionality, and configuration of Match Byte 1.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for Matching functionality on up to 4 bytes in the Data field(s).           This is typically used to implement a Header Check or Broadcast Check capability.          </li><li>
The Match functionality consists of taking the received value of a specified data byte, logically AND-ing it with a programmed Mask value,          and then comparing the result with a programmed target Match value.            The logical result of this comparison (TRUE or FALSE) can be logically combined with the results of comparisons for the remaining Match bytes;           the final logical result determines whether or not the overall packet is considered to match.          </li><li>
The location of the corresponding Match byte is specified by the OFFSET[4:0] field within each MATCH_CTRL_X property.           This value represents the offset (in number of bytes) of the location of the received data byte to match,           relative to the end of the Sync Word.            Setting OFFSET = 0 would result in matching the first byte immediately following the Sync Word, OFFSET = 1 would match the second byte, etc.          </li><li>
The offset(s) of the Match bytes must be in non-descending order;           that is, the offset location of Match 1 byte must be less than or equal to the location of Match 2 byte,           the location of Match 2 byte must be less than or equal to the location of Match 3 byte, and so on.            Two (or more) Match bytes may have the same offset location.            All Match bytes must be located within the first 32 bytes following the Sync Word,           but need not be adjacent to each other.  The default value for all Match bytes is OFFSET=0;           if the OFFSET value of any Match byte is set to a non-zero value,           the OFFSET values of the higher Match bytes must also be set to equal (or higher) offset locations,           else the non-descending requirement will be violated.
          </li><li>
The MATCH_EN bit (found only within the <a href="#prop-MATCH_CTRL_1">MATCH_CTRL_1</a>
 property) is used to enable/disable the Match functionality across all Match bytes.           If this bit is cleared, the Match functionality is disabled regardless of the contents of all other properties within the MATCH property group.
          </li><li>
The POLARITY bit is used to configure the polarity of the logical result of the comparison on the Match byte.            If POLARITY = 0, the logical result is TRUE if the comparison matches.            If POLARITY = 1, the logical result is TRUE if the comparison does not match.          </li><li>
The LOGIC bit (found only within the <a href="#prop-MATCH_CTRL_2">MATCH_CTRL_2</a>
/3/4 properties) determines how the logical result of           comparison on the specified Match byte will be combined with the logical result from the previous match(es).            If LOGIC=0, the result from the specified Match byte is AND'ed with the logical result from previous MATCH field(s).            If LOGIC=1, the result is OR'ed with the logical result from the previous MATCH field(s).
          </li><li>
This flexibility in logic allows construction of a match function such as:  Match_1 OR !Match_2 AND Match_3 AND !Match_4. </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MATCH_CTRL_1</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="1">POLARITY</td>
<td colspan="1">MATCH_EN</td>
<td>0</td>
<td colspan="5">OFFSET</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td colspan="5">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MATCH%3AMATCH_CTRL_1">MATCH_CTRL_1</a><ul>
<li><a name="field-MATCH_CTRL_1%3APOLARITY">POLARITY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Configures the polarity of the logical result of the comparison on the Match byte. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Logical result is TRUE if the comparison matches.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Logical result is TRUE if the comparison does not match.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MATCH_CTRL_1%3AMATCH_EN">MATCH_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This bit provides the overall enable/disable functionality for the Packet Match capability.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">MATCH_DISABLE</td><td>1</td><td align="left">
<ul><li>
Disable packet match functionality.</li></ul>
</td></tr>
<tr valign="top"><td align="left">MATCH_ENABLE</td><td>1</td><td align="left">
<ul><li>
Enable packet match functionality.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MATCH_CTRL_1%3AOFFSET">OFFSET</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Offset location of the Match byte, relative to the end of the Sync Word.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MATCH_VALUE_2">MATCH_VALUE_2</a></h4>
<ul>
<li>Group: 0x30</li>
<li>Index: 0x03</li>
<li>Summary: Match value to be compared with the result of logically AND-ing (bit-wise) the Mask 2 value with the received Match 2 byte. </li>
<li>Purpose:</li>
<ul><li>
This property defines the target Match 2 value to be compared with the result of logically AND-ing (bit-wise) the Mask 2 value with the received Match 2 byte. Please refer to the text description for <a href="#prop-MATCH_VALUE_1">MATCH_VALUE_1</a>
, <a href="#prop-MATCH_MASK_1">MATCH_MASK_1</a>
, and <a href="#prop-MATCH_CTRL_1">MATCH_CTRL_1</a>
 for more details regarding the Match byte functionality. </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MATCH_VALUE_2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="8">VALUE_2</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MATCH%3AMATCH_VALUE_2">MATCH_VALUE_2</a><ul>
<li><a name="field-MATCH_VALUE_2%3AVALUE_2">VALUE_2</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Match 2 value to be compared with the result of logically AND-ing (bit-wise) the Mask 2 value with the received Match 2 byte.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MATCH_MASK_2">MATCH_MASK_2</a></h4>
<ul>
<li>Group: 0x30</li>
<li>Index: 0x04</li>
<li>Summary: Mask value to be logically AND-ed (bit-wise) with the Match 2 byte.</li>
<li>Purpose:</li>
<ul><li>
This property defines the Mask 2 value to be logically AND-ed (bit-wise) with the Match 2 byte, prior to comparison with the target Match 2 value.</li><li>
Please refer to the text description for <a href="#prop-MATCH_VALUE_1">MATCH_VALUE_1</a>
, <a href="#prop-MATCH_MASK_1">MATCH_MASK_1</a>
, and <a href="#prop-MATCH_CTRL_1">MATCH_CTRL_1</a>
 for more details regarding the Match byte functionality. </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MATCH_MASK_2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="8">MASK_2</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MATCH%3AMATCH_MASK_2">MATCH_MASK_2</a><ul>
<li><a name="field-MATCH_MASK_2%3AMASK_2">MASK_2</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Mask value to be logicalled AND-ed with the Match 2 byte.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MATCH_CTRL_2">MATCH_CTRL_2</a></h4>
<ul>
<li>Group: 0x30</li>
<li>Index: 0x05</li>
<li>Summary: Configuration of Match Byte 2.</li>
<li>Purpose:</li>
<ul><li>
This property contains the configuration bits for the Match 2 byte.</li><li>
Please refer to the text description for <a href="#prop-MATCH_VALUE_1">MATCH_VALUE_1</a>
, <a href="#prop-MATCH_MASK_1">MATCH_MASK_1</a>
, and <a href="#prop-MATCH_CTRL_1">MATCH_CTRL_1</a>
 for more details regarding the Match byte functionality.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MATCH_CTRL_2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="1">POLARITY</td>
<td colspan="1">LOGIC</td>
<td>0</td>
<td colspan="5">OFFSET</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td colspan="5">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MATCH%3AMATCH_CTRL_2">MATCH_CTRL_2</a><ul>
<li><a name="field-MATCH_CTRL_2%3APOLARITY">POLARITY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Configures the polarity of the logical result of the comparison on the Match byte. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Logical result is TRUE if the comparison matches.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Logical result is TRUE if the comparison does not match.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MATCH_CTRL_2%3ALOGIC">LOGIC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
configures how the logical result from the comparison of this Match byte is combined with the logical results from the previous MATCH field(s).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Logical result from this Match byte is AND'ed with the logical result from previous MATCH field(s).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Logical result from this Match byte is OR'ed with the logical result from previous MATCH field(s).</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MATCH_CTRL_2%3AOFFSET">OFFSET</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Offset location of the Match byte, relative to the end of the Sync Word.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MATCH_VALUE_3">MATCH_VALUE_3</a></h4>
<ul>
<li>Group: 0x30</li>
<li>Index: 0x06</li>
<li>Summary: Match value to be compared with the result of logically AND-ing (bit-wise) the Mask 3 value with the received Match 3 byte. </li>
<li>Purpose:</li>
<ul><li>
This property defines the target Match 3 value to be compared with the result of logically AND-ing (bit-wise) the Mask 3 value with the received Match 3 byte. Please refer to the text description for <a href="#prop-MATCH_VALUE_1">MATCH_VALUE_1</a>
, <a href="#prop-MATCH_MASK_1">MATCH_MASK_1</a>
, and <a href="#prop-MATCH_CTRL_1">MATCH_CTRL_1</a>
 for more details regarding the Match byte functionality. </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MATCH_VALUE_3</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="8">VALUE_3</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MATCH%3AMATCH_VALUE_3">MATCH_VALUE_3</a><ul>
<li><a name="field-MATCH_VALUE_3%3AVALUE_3">VALUE_3</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Match 3 value to be compared with the result of logically AND-ing (bit-wise) the Mask 3 value with the received Match 3 byte.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MATCH_MASK_3">MATCH_MASK_3</a></h4>
<ul>
<li>Group: 0x30</li>
<li>Index: 0x07</li>
<li>Summary: Mask value to be logically AND-ed (bit-wise) with the Match 3 byte.</li>
<li>Purpose:</li>
<ul><li>
This property defines the Mask 3 value to be logically AND-ed (bit-wise) with the Match 3 byte, prior to comparison with the target Match 3 value.</li><li>
Please refer to the text description for <a href="#prop-MATCH_VALUE_1">MATCH_VALUE_1</a>
, <a href="#prop-MATCH_MASK_1">MATCH_MASK_1</a>
, and <a href="#prop-MATCH_CTRL_1">MATCH_CTRL_1</a>
 for more details regarding the Match byte functionality. </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MATCH_MASK_3</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x07</td>
<td colspan="8">MASK_3</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x07</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MATCH%3AMATCH_MASK_3">MATCH_MASK_3</a><ul>
<li><a name="field-MATCH_MASK_3%3AMASK_3">MASK_3</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Mask value to be logicalled AND-ed with the Match 3 byte.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MATCH_CTRL_3">MATCH_CTRL_3</a></h4>
<ul>
<li>Group: 0x30</li>
<li>Index: 0x08</li>
<li>Summary: Configuration of Match Byte 3.</li>
<li>Purpose:</li>
<ul><li>
This property contains the configuration bits for the Match 3 byte.</li><li>
Please refer to the text description for <a href="#prop-MATCH_VALUE_1">MATCH_VALUE_1</a>
, <a href="#prop-MATCH_MASK_1">MATCH_MASK_1</a>
, and <a href="#prop-MATCH_CTRL_1">MATCH_CTRL_1</a>
 for more details regarding the Match byte functionality.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MATCH_CTRL_3</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x08</td>
<td colspan="1">POLARITY</td>
<td colspan="1">LOGIC</td>
<td>0</td>
<td colspan="5">OFFSET</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x08</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td colspan="5">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MATCH%3AMATCH_CTRL_3">MATCH_CTRL_3</a><ul>
<li><a name="field-MATCH_CTRL_3%3APOLARITY">POLARITY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Configures the polarity of the logical result of the comparison on the Match byte. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Logical result is TRUE if the comparison matches.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Logical result is TRUE if the comparison does not match.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MATCH_CTRL_3%3ALOGIC">LOGIC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
configures how the logical result from the comparison of this Match byte is combined with the logical results from the previous MATCH field(s).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Logical result from this Match byte is AND'ed with the logical result from previous MATCH field(s).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Logical result from this Match byte is OR'ed with the logical result from previous MATCH field(s).</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MATCH_CTRL_3%3AOFFSET">OFFSET</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Offset location of the Match byte, relative to the end of the Sync Word.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MATCH_VALUE_4">MATCH_VALUE_4</a></h4>
<ul>
<li>Group: 0x30</li>
<li>Index: 0x09</li>
<li>Summary: Match value to be compared with the result of logically AND-ing (bit-wise) the Mask 4 value with the received Match 4 byte. </li>
<li>Purpose:</li>
<ul><li>
This property defines the target Match 4 value to be compared with the result of logically AND-ing (bit-wise) the Mask 4 value with the received Match 4 byte. Please refer to the text description for <a href="#prop-MATCH_VALUE_1">MATCH_VALUE_1</a>
, <a href="#prop-MATCH_MASK_1">MATCH_MASK_1</a>
, and <a href="#prop-MATCH_CTRL_1">MATCH_CTRL_1</a>
 for more details regarding the Match byte functionality. </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MATCH_VALUE_4</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x09</td>
<td colspan="8">VALUE_4</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x09</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MATCH%3AMATCH_VALUE_4">MATCH_VALUE_4</a><ul>
<li><a name="field-MATCH_VALUE_4%3AVALUE_4">VALUE_4</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Match 4 value to be compared with the result of logically AND-ing (bit-wise) the Mask 4 value with the received Match 4 byte.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MATCH_MASK_4">MATCH_MASK_4</a></h4>
<ul>
<li>Group: 0x30</li>
<li>Index: 0x0a</li>
<li>Summary: Mask value to be logically AND-ed (bit-wise) with the Match 4 byte.</li>
<li>Purpose:</li>
<ul><li>
This property defines the Mask 4 value to be logically AND-ed (bit-wise) with the Match 4 byte, prior to comparison with the target Match 4 value.</li><li>
Please refer to the text description for <a href="#prop-MATCH_VALUE_1">MATCH_VALUE_1</a>
, <a href="#prop-MATCH_MASK_1">MATCH_MASK_1</a>
, and <a href="#prop-MATCH_CTRL_1">MATCH_CTRL_1</a>
 for more details regarding the Match byte functionality. </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MATCH_MASK_4</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0a</td>
<td colspan="8">MASK_4</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0a</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MATCH%3AMATCH_MASK_4">MATCH_MASK_4</a><ul>
<li><a name="field-MATCH_MASK_4%3AMASK_4">MASK_4</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Mask value to be logicalled AND-ed with the Match 4 byte.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-MATCH_CTRL_4">MATCH_CTRL_4</a></h4>
<ul>
<li>Group: 0x30</li>
<li>Index: 0x0b</li>
<li>Summary: Configuration of Match Byte 4.</li>
<li>Purpose:</li>
<ul><li>
This property contains the configuration bits for the Match 4 byte.</li><li>
Please refer to the text description for <a href="#prop-MATCH_VALUE_1">MATCH_VALUE_1</a>
, <a href="#prop-MATCH_MASK_1">MATCH_MASK_1</a>
, and <a href="#prop-MATCH_CTRL_1">MATCH_CTRL_1</a>
 for more details regarding the Match byte functionality.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MATCH_CTRL_4</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0b</td>
<td colspan="1">POLARITY</td>
<td colspan="1">LOGIC</td>
<td>0</td>
<td colspan="5">OFFSET</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0b</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td colspan="5">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MATCH%3AMATCH_CTRL_4">MATCH_CTRL_4</a><ul>
<li><a name="field-MATCH_CTRL_4%3APOLARITY">POLARITY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Configures the polarity of the logical result of the comparison on the Match byte. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Logical result is TRUE if the comparison matches.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Logical result is TRUE if the comparison does not match.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MATCH_CTRL_4%3ALOGIC">LOGIC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
configures how the logical result from the comparison of this Match byte is combined with the logical results from the previous MATCH field(s).</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>0</td><td align="left">
<ul><li>
Logical result from this Match byte is AND'ed with the logical result from previous MATCH field(s).</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENUM_1</td><td>1</td><td align="left">
<ul><li>
Logical result from this Match byte is OR'ed with the logical result from previous MATCH field(s).</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MATCH_CTRL_4%3AOFFSET">OFFSET</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Offset location of the Match byte, relative to the end of the Sync Word.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x1f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-FREQ_CONTROL">FREQ_CONTROL</a></h3>
<h4><a name="prop-FREQ_CONTROL_INTE">FREQ_CONTROL_INTE</a></h4>
<ul>
<li>Group: 0x40</li>
<li>Index: 0x00</li>
<li>Summary: Frac-N PLL Synthesizer integer divide number.</li>
<li>Purpose:</li>
<ul><li>
The total divide ratio for the Fractional-N PLL Synthesizer consists of an integer portion and a fractional portion.     This property defines the integer divide number;     the fractional divide value is specified in property  <a href="#prop-FREQ_CONTROL_FRAC">FREQ_CONTROL_FRAC</a>
.    </li><li>
The formula for calculating RF channel frequency as a function of integer and fractional divide values is as follows:

    <br />[LATEX equation: RF_{Channel_{Hz}}=\left(fc_{inte}+\frac{fc_{frac}}{2^{19}}\right) \times \left(\frac{N_{PRESC} \times freq\_xo}{outdiv}\right)]
</li><li>
The output divider value OUTDIV is configured as a function of the desired frequency band,                             and is specified in property <a href="#field-MODEM_CLKGEN_BAND%3ABAND">MODEM_CLKGEN_BAND:BAND</a>
.                        </li><li>
The prescaler divider value N<sub>PRESC</sub> is configured as a function of the selected synthesizer performance mode and may take on the values NPRESC=2 or NPRESC=4,                            as specified in property <a href="#field-MODEM_CLKGEN_BAND%3ASY_SEL">MODEM_CLKGEN_BAND:SY_SEL</a>
.</li><li>
The entire fc<sub>frac</sub> word is 20-bits in length, but the MSB should always be set to 1,                           and thus the term fc<sub>frac</sub>/2<sup>19</sup> will always be between 1 and 2 in value.                             As a result, the integer term fc<sub>inte</sub> should be reduced by 1.                           Example:  a total desired divide ratio of N = 60.135 should be implemented as fc<sub>inte</sub> = 59, fc<sub>frac</sub>/2<sup>19</sup> = 1.135.                       </li><li>
Modifying this property will have no effect until the chip exits from TX or RX state, and then re-enters the state.</li></ul>
<li>Defaults: 0x3c</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">FREQ_CONTROL_INTE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0</td>
<td colspan="7">INTE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0x0</td>
<td colspan="7">0x3c</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-FREQ_CONTROL%3AFREQ_CONTROL_INTE">FREQ_CONTROL_INTE</a><ul>
<li><a name="field-FREQ_CONTROL_INTE%3AINTE">INTE</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-FREQ_CONTROL_FRAC">FREQ_CONTROL_FRAC</a></h4>
<ul>
<li>Group: 0x40</li>
<li>Index: 0x01 ... 0x03</li>
<li>Summary: Frac-N PLL fraction number.</li>
<li>Purpose:</li>
<ul><li>
Please refer to the text description for <a href="#prop-FREQ_CONTROL_INTE">FREQ_CONTROL_INTE</a>
 for more details regarding frequency calculation.</li></ul>
<li>Defaults: 0x08, 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">FREQ_CONTROL_FRAC</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="4">FRAC[19:16]</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">FRAC[15:8]</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">FRAC[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="4">0x8</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-FREQ_CONTROL%3AFREQ_CONTROL_FRAC">FREQ_CONTROL_FRAC</a><ul>
<li><a name="field-FREQ_CONTROL_FRAC%3AFRAC">FRAC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Frequency control fractional part</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xfffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-FREQ_CONTROL_CHANNEL_STEP_SIZE">FREQ_CONTROL_CHANNEL_STEP_SIZE</a></h4>
<ul>
<li>Group: 0x40</li>
<li>Index: 0x04 ... 0x05</li>
<li>Summary: EZ Frequency Programming channel step size.</li>
<li>Purpose:</li>
<ul><li>
The EZ Frequency Programming method allows the user to control the frequency by selecting a desired channel number, given a base frequency and a channel step size.      This property defines the unsigned 16-bit channel step size value.    </li><li>
The units of the <a href="#prop-FREQ_CONTROL_CHANNEL_STEP_SIZE">FREQ_CONTROL_CHANNEL_STEP_SIZE</a>
 property are in increments of the LSB tuning resolution of the PLL Synthesizer,    and are therefore a function of the crystal reference frequency and output frequency band.      The formula for calculating the value of the FREQ_CONTROL_CHANNEL_STEP_SIZE property is given by the following equation:

    <br />[LATEX equation: FREQ\_CTRL\_CHAN\_STEP\_SIZE=\frac{2^{19} \times outdiv \times Desired\_Stepsize\_Hz}{N_{PRESC} \times freq\_xo}]
</li><li>
The output divider value OUTDIV is configured as a function of the desired frequency band,                             and is specified in property <a href="#field-MODEM_CLKGEN_BAND%3ABAND">MODEM_CLKGEN_BAND:BAND</a>
.                        </li><li>
The prescaler divider value N<sub>PRESC</sub> is configured as a function of the selected synthesizer performance mode and may take on the values NPRESC=2 or NPRESC=4,                            as specified in property <a href="#field-MODEM_CLKGEN_BAND%3ASY_SEL">MODEM_CLKGEN_BAND:SY_SEL</a>
.</li><li>
The base frequency is specified by the <a href="#prop-FREQ_CONTROL_INTE">FREQ_CONTROL_INTE</a>
 and <a href="#prop-FREQ_CONTROL_FRAC">FREQ_CONTROL_FRAC</a>
 properties. </li><li>
The channel number is specified by the CHANNEL parameter byte passed to the <a href="#cmd-START_TX"><code>START_TX</code></a>
 command.</li><li>
The commanded channel frequency is given by the formula:

    <br />[LATEX equation: Center\_Freq=Base\_Freq+Channel\_Number \times Desired\_Step\_Size\_Hz]

    </li></ul>
<li>Defaults: 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">FREQ_CONTROL_CHANNEL_STEP_SIZE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="8">CHANNEL_STEP_SIZE[15:8]</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">CHANNEL_STEP_SIZE[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-FREQ_CONTROL%3AFREQ_CONTROL_CHANNEL_STEP_SIZE">FREQ_CONTROL_CHANNEL_STEP_SIZE</a><ul>
<li><a name="field-FREQ_CONTROL_CHANNEL_STEP_SIZE%3ACHANNEL_STEP_SIZE">CHANNEL_STEP_SIZE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Channel step size</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-FREQ_CONTROL_W_SIZE">FREQ_CONTROL_W_SIZE</a></h4>
<ul>
<li>Group: 0x40</li>
<li>Index: 0x06</li>
<li>Summary: Set window gating period (in number of crystal reference clock cycles) for counting VCO frequency during calibration.</li>
<li>Purpose:</li>
<ul><li>
The chip performs a calibration of the VCO at each new commanded frequency.  This is accomplished by counting cycles of the VCO frequency and comparing to an expected target count value.</li><li>
The length of the window during which cycles of the VCO frequency are counted is specified by this property.  The units are in cycles of the crystal reference frequency (e.g., 30 MHz clock periods).</li><li>
This property does not need to change as a function of crystal reference frequency; the chip automatically calculates the target VCO count value as a function of crystal reference frequency and thus this property may remain constant.  Silicon Labs recommends setting this property always to 0x20.</li></ul>
<li>Defaults: 0x20</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">FREQ_CONTROL_W_SIZE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="8">W_SIZE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="8">0x20</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-FREQ_CONTROL%3AFREQ_CONTROL_W_SIZE">FREQ_CONTROL_W_SIZE</a><ul>
<li><a name="field-FREQ_CONTROL_W_SIZE%3AW_SIZE">W_SIZE</a>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-FREQ_CONTROL_VCOCNT_RX_ADJ">FREQ_CONTROL_VCOCNT_RX_ADJ</a></h4>
<ul>
<li>Group: 0x40</li>
<li>Index: 0x07</li>
<li>Summary: Adjust target count for VCO calibration in RX mode.</li>
<li>Purpose:</li>
<ul><li>
The chip performs a calibration of the VCO at each new commanded frequency.  This is accomplished by counting cycles of the VCO frequency and comparing to an expected target count value.  As the chip's default mode of operation uses a low-IF architecture with low-side Mixer injection, the RX LO must shift downwards in frequency during RX mode.  The expected target count value changes as a result of this shift in frequency.</li><li>
This field is a signed value that represents the amount by which the target count value must be adjusted in RX mode.</li></ul>
<li>Defaults: 0xff</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">FREQ_CONTROL_VCOCNT_RX_ADJ</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x07</td>
<td colspan="8">VCOCNT_RX_ADJ</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x07</td>
<td colspan="8">0xff</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-FREQ_CONTROL%3AFREQ_CONTROL_VCOCNT_RX_ADJ">FREQ_CONTROL_VCOCNT_RX_ADJ</a><ul>
<li><a name="field-FREQ_CONTROL_VCOCNT_RX_ADJ%3AVCOCNT_RX_ADJ">VCOCNT_RX_ADJ</a>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-RX_HOP">RX_HOP</a></h3>
<h4><a name="prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x00</li>
<li>Summary: Configuration options for the automatic RX Hop functionality.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.      This reduces the amount of control from the host MCU required to manage such a channel scanning application.
    </li><li>
This property selects the condition under which the chip will automatically hop, and sets the RSSI timeout value for that hopping option.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_TABLE_SIZE">RX_HOP_TABLE_SIZE</a>
 and RX_HOP_TABLE_ENTRY_X for details regarding the configuration of the RX Hop Table.
</li></ul>
<li>Defaults: 0x04</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_CONTROL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0</td>
<td colspan="3">HOP_EN</td>
<td colspan="4">RSSI_TIMEOUT</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0x0</td>
<td colspan="3">0x0</td>
<td colspan="4">0x4</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_CONTROL">RX_HOP_CONTROL</a><ul>
<li><a name="field-RX_HOP_CONTROL%3AHOP_EN">HOP_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Enables automatic RX hopping, and selects the condition(s) under which an RX hop will occur.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">HOP_DISABLE</td><td>0</td><td align="left">
<ul><li>
Hop disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">HOP_PM_TO</td><td>1</td><td align="left">
<ul><li>
Hop on INVALID_PREAMBLE event (i.e., RX Preamble timeout)    The possible actions of the chip are:
    a)Hop if no PREAMBLE_VALID signal is detected before expiration of the RX Preamble Timeout period (set in the <a href="#prop-PREAMBLE_CONFIG_STD_2">PREAMBLE_CONFIG_STD_2</a>
 property).
    b)Remain on the channel if PREAMBLE_VALID signal is detected before expiration of the RX Preamble Timeout period. </li></ul>
</td></tr>
<tr valign="top"><td align="left">HOP_RSSI_PM_TO</td><td>2</td><td align="left">
<ul><li>
Hop on INVALID_PREAMBLE or RSSI Timeout event(s).    The possible actions of the chip are:
    a)Hop if no PREAMBLE_VALID signal is detected before expiration of the RX Preamble Timeout period,    or if the measured Current RSSI level does not exceed the RSSI threshold value     (set in the <a href="#prop-MODEM_RSSI_THRESH">MODEM_RSSI_THRESH</a>
 property) before expiration of the RSSI Timeout period     (whichever occurs first).
    b)Remain on the channel if PREAMBLE_VALID signal is detected before expiration of the RX Preamble Timeout period,    and the Current RSSI level exceeds the RSSI threshold level before expiration of the RSSI Timeout period. </li></ul>
</td></tr>
<tr valign="top"><td align="left">HOP_PM_SYNC_TO</td><td>3</td><td align="left">
<ul><li>
Hop on INVALID_PREAMBLE or invalid Sync Word event(s).    The possible actions of the chip are:
    a)Hop if no PREAMBLE_VALID signal is detected before expiration of the RX Preamble Timeout period, or if a valid Sync Word is not detected.
    b)Remain on the channel if PREAMBLE_VALID signal is detected before expiration of the RX Preamble Timeout period, and a valid Sync Word is detected.
</li></ul>
</td></tr>
<tr valign="top"><td align="left">HOP_RSSI_PM_SYNC_TO</td><td>4</td><td align="left">
<ul><li>
Hop on INVALID_PREAMBLE or RSSI Timeout or invalid Sync Word event(s).    The possible actions of the chip are:
    a)Hop if no PREAMBLE_VALID signal is detected before expiration of the RX Preamble Timeout period,    or if the measured Current RSSI level does not exceed the RSSI threshold value before expiration of the RSSI Timeout period,    or if a valid Sync Word is not detected.
    b)Remain on the channel if PREAMBLE_VALID signal is detected before expiration of the RX Preamble Timeout period,     and the Current RSSI level exceeds the RSSI threshold level before expiration of the RSSI Timeout period, and a valid Sync Word is detected. </li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-RX_HOP_CONTROL%3ARSSI_TIMEOUT">RSSI_TIMEOUT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
The chip may be configured to hop if the measured Current RSSI level does not exceed a threshold level within a certain timeout period.
    </li><li>
This field sets the RSSI Timeout period, expressed in nibbles. </li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_SIZE">RX_HOP_TABLE_SIZE</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x01</li>
<li>Summary: Specifies the number of entries (channels) in the RX Hop table.</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
This property specifies the number of entries (channels) in the RX Hop Table.  The RX Hop Table may be up to 64 channels in length.
    </li><li>
Please refer to the text description for RX_HOP_CONTROL for more details regarding the configuration of the RX Hop functionality.
</li></ul>
<li>Defaults: 0x01</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_SIZE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td>0</td>
<td colspan="7">RX_HOP_TABLE_SIZE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td>0x0</td>
<td colspan="7">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_SIZE">RX_HOP_TABLE_SIZE</a><ul>
<li><a name="field-RX_HOP_TABLE_SIZE%3ARX_HOP_TABLE_SIZE">RX_HOP_TABLE_SIZE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Specifies the number of entries in the RX Hop table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x1</dd></dl>
<dl><dt>Max:</dt><dd>0x40</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x02</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x03</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x01</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="8">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x04</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x02</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="8">0x2</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x05</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x03</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="8">0x3</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x06</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x04</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="8">0x4</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x07</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x05</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x07</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x07</td>
<td colspan="8">0x5</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x08</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x06</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x08</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x08</td>
<td colspan="8">0x6</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x09</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x07</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x09</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x09</td>
<td colspan="8">0x7</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x0a</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x08</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0a</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0a</td>
<td colspan="8">0x8</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x0b</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x09</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0b</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0b</td>
<td colspan="8">0x9</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x0c</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x0a</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0c</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0c</td>
<td colspan="8">0xa</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x0d</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x0b</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0d</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0d</td>
<td colspan="8">0xb</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x0e</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x0c</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0e</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0e</td>
<td colspan="8">0xc</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x0f</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x0d</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0f</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0f</td>
<td colspan="8">0xd</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x10</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x0e</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x10</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x10</td>
<td colspan="8">0xe</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x11</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x0f</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x11</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x11</td>
<td colspan="8">0xf</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x12</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x10</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x12</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x12</td>
<td colspan="8">0x10</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x13</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x11</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x13</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x13</td>
<td colspan="8">0x11</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x14</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x12</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x14</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x14</td>
<td colspan="8">0x12</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x15</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x13</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x15</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x15</td>
<td colspan="8">0x13</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x16</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x14</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x16</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x16</td>
<td colspan="8">0x14</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x17</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x15</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x17</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x17</td>
<td colspan="8">0x15</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x18</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x16</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x18</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x18</td>
<td colspan="8">0x16</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x19</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x17</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x19</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x19</td>
<td colspan="8">0x17</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x1a</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x18</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1a</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1a</td>
<td colspan="8">0x18</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x1b</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x19</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1b</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1b</td>
<td colspan="8">0x19</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x1c</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x1a</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1c</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1c</td>
<td colspan="8">0x1a</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x1d</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x1b</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1d</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1d</td>
<td colspan="8">0x1b</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x1e</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x1c</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1e</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1e</td>
<td colspan="8">0x1c</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x1f</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x1d</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1f</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1f</td>
<td colspan="8">0x1d</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x20</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x1e</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x20</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x20</td>
<td colspan="8">0x1e</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x21</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x1f</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x21</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x21</td>
<td colspan="8">0x1f</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x22</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x20</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x22</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x22</td>
<td colspan="8">0x20</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x23</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x21</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x23</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x23</td>
<td colspan="8">0x21</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x24</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x22</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x24</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x24</td>
<td colspan="8">0x22</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x25</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x23</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x25</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x25</td>
<td colspan="8">0x23</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x26</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x24</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x26</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x26</td>
<td colspan="8">0x24</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x27</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x25</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x27</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x27</td>
<td colspan="8">0x25</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x28</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x26</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x28</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x28</td>
<td colspan="8">0x26</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x29</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x27</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x29</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x29</td>
<td colspan="8">0x27</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x2a</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x28</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2a</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2a</td>
<td colspan="8">0x28</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x2b</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x29</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2b</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2b</td>
<td colspan="8">0x29</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x2c</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x2a</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2c</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2c</td>
<td colspan="8">0x2a</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x2d</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x2b</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2d</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2d</td>
<td colspan="8">0x2b</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x2e</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x2c</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2e</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2e</td>
<td colspan="8">0x2c</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x2f</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x2d</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2f</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2f</td>
<td colspan="8">0x2d</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x30</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x2e</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x30</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x30</td>
<td colspan="8">0x2e</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x31</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x2f</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x31</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x31</td>
<td colspan="8">0x2f</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x32</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x30</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x32</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x32</td>
<td colspan="8">0x30</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x33</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x31</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x33</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x33</td>
<td colspan="8">0x31</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x34</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x32</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x34</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x34</td>
<td colspan="8">0x32</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x35</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x33</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x35</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x35</td>
<td colspan="8">0x33</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x36</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x34</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x36</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x36</td>
<td colspan="8">0x34</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x37</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x35</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x37</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x37</td>
<td colspan="8">0x35</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x38</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x36</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x38</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x38</td>
<td colspan="8">0x36</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x39</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x37</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x39</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x39</td>
<td colspan="8">0x37</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x3a</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x38</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x3a</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x3a</td>
<td colspan="8">0x38</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x3b</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x39</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x3b</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x3b</td>
<td colspan="8">0x39</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x3c</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x3a</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x3c</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x3c</td>
<td colspan="8">0x3a</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x3d</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x3b</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x3d</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x3d</td>
<td colspan="8">0x3b</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x3e</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x3c</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x3e</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x3e</td>
<td colspan="8">0x3c</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x3f</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x3d</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x3f</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x3f</td>
<td colspan="8">0x3d</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x40</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x3e</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x40</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x40</td>
<td colspan="8">0x3e</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-RX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a></h4>
<ul>
<li>Group: 0x50</li>
<li>Index: 0x41</li>
<li>Summary: Defines entries in the RX Hopping Table (N=0 to 63)</li>
<li>Purpose:</li>
<ul><li>
The chip provides for automatic frequency hopping from one RX channel to another when certain conditions are met.
    </li><li>
The desired frequency hopping or channel scanning sequence is specified by a table of channel numbers.
    This property specifies the channel number for the No.N entry in the RX Hop Table.
    </li><li>
An entry in the RX Hop Table is skipped if its value is CHANNEL_NUM = 0xFF.
    </li><li>
The channel number values in the RX Hop Table may be entered in random fashion,    and need not be in ascending or sorted order.     However, the START_RX command should be invoked with a CHANNEL parameter byte value    equal to the CHANNEL_NUM in the first entry in the RX Hop Table.
    </li><li>
Duplicate channel number values are allowed in the table.
    </li><li>
Please refer to the text description for <a href="#prop-RX_HOP_CONTROL">RX_HOP_CONTROL</a>
 for more details regarding the configuration of the RX Hop functionality. </li></ul>
<li>Defaults: 0x3f</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">RX_HOP_TABLE_ENTRY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x41</td>
<td colspan="8">CHANNEL_NUM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x41</td>
<td colspan="8">0x3f</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-RX_HOP%3ARX_HOP_TABLE_ENTRY">RX_HOP_TABLE_ENTRY</a><ul>
<li><a name="field-RX_HOP_TABLE_ENTRY%3ACHANNEL_NUM">CHANNEL_NUM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This property specifies the channel number for the N<sup>th</sup> entry in the RX Hop Table.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-IE154_TX">IE154_TX</a></h3>
<h4><a name="prop-IE154_TX_FLAGS">IE154_TX_FLAGS</a></h4>
<ul>
<li>Group: 0x60</li>
<li>Index: 0x00</li>
<li>Summary: Configure ie154_tx_flags</li>
<li>Purpose:</li>
<ul><li>
TODO</li></ul>
<li>Comments (internal):</li>
<ul><li>
TODO</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_TX_FLAGS</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">ACK_IN_FIFO</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_TX%3AIE154_TX_FLAGS">IE154_TX_FLAGS</a><ul>
<li><a name="field-IE154_TX_FLAGS%3AACK_IN_FIFO">ACK_IN_FIFO</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Controls putting received ACK messages in TX mode into the RX FIFO.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Do not put received ACK messages in the RX FIFO.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Put received ACK messages in the RX FIFO.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_TX_BACKOFF_TURNAROUND_TIME_SYMBOLS">IE154_TX_BACKOFF_TURNAROUND_TIME_SYMBOLS</a></h4>
<ul>
<li>Group: 0x60</li>
<li>Index: 0x01</li>
<li>Summary: Configure TX Mode transition time after sending a packet and starting to receive the ack</li>
<li>Purpose:</li>
<ul><li>
Define the number of symbols before transitioning into RX to receive the ack</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented and used to compute ack timeout. Not fully tested  
</li></ul>
<li>Defaults: 0x0c</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_TX_BACKOFF_TURNAROUND_TIME_SYMBOLS</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">BACKOFF_TURNAROUND_TIME_SYMBOLS</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">0xc</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_TX%3AIE154_TX_BACKOFF_TURNAROUND_TIME_SYMBOLS">IE154_TX_BACKOFF_TURNAROUND_TIME_SYMBOLS</a><ul>
<li><a name="field-IE154_TX_BACKOFF_TURNAROUND_TIME_SYMBOLS%3ABACKOFF_TURNAROUND_TIME_SYMBOLS">BACKOFF_TURNAROUND_TIME_SYMBOLS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Defines TX mode turnaround time in symbols.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_TX_ACK_TIMEOUT">IE154_TX_ACK_TIMEOUT</a></h4>
<ul>
<li>Group: 0x60</li>
<li>Index: 0x02 ... 0x03</li>
<li>Summary: Configure the number of symbols for ack timeout.</li>
<li>Purpose:</li>
<ul><li>
Define the number of symbols to wait for an ack before timing out.</li></ul>
<li>Comments (internal):</li>
<ul><li>
Implemented and tested.</li></ul>
<li>Defaults: 0x00, 0xff</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_TX_ACK_TIMEOUT</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="8">ACK_TIMEOUT_SYMBOLS[15:8]</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">ACK_TIMEOUT_SYMBOLS[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">0xff</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_TX%3AIE154_TX_ACK_TIMEOUT">IE154_TX_ACK_TIMEOUT</a><ul>
<li><a name="field-IE154_TX_ACK_TIMEOUT%3AACK_TIMEOUT_SYMBOLS">ACK_TIMEOUT_SYMBOLS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Defines the ack timeout value in symbols.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_TX_CCA_MODE">IE154_TX_CCA_MODE</a></h4>
<ul>
<li>Group: 0x60</li>
<li>Index: 0x04</li>
<li>Summary: TX Mode CCA configuration.</li>
<li>Purpose:</li>
<ul><li>
Configure CCA operation.</li></ul>
<li>Comments (internal):</li>
<ul><li>
Not implemented and not tested.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_TX_CCA_MODE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x04</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CCA_METHOD</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x04</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_TX%3AIE154_TX_CCA_MODE">IE154_TX_CCA_MODE</a><ul>
<li><a name="field-IE154_TX_CCA_MODE%3ACCA_METHOD">CCA_METHOD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Configure CCA algorithm to Listen Before Talk</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">CSMA_CA</td><td>0</td><td align="left">
<ul><li>
Configure CCA algorithm to CSMA_CA</li></ul>
</td></tr>
<tr valign="top"><td align="left">LBT</td><td>1</td><td align="left">
<ul><li>
Configure CCA algorithm to Listen Before Talk</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_TX_CCA_THRESHOLD">IE154_TX_CCA_THRESHOLD</a></h4>
<ul>
<li>Group: 0x60</li>
<li>Index: 0x05</li>
<li>Summary: Configure CCA Threshold</li>
<li>Purpose:</li>
<ul><li>
CCA Threshold in dBm units</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented and tested  
</li></ul>
<li>Defaults: 0x50</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_TX_CCA_THRESHOLD</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="8">CCA_THRESHOLD</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="8">0x50</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_TX%3AIE154_TX_CCA_THRESHOLD">IE154_TX_CCA_THRESHOLD</a><ul>
<li><a name="field-IE154_TX_CCA_THRESHOLD%3ACCA_THRESHOLD">CCA_THRESHOLD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Sets theCCA Threshold in dBm units.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_TX_CSMA_BACKOFF_BASE_SYMBOLS">IE154_TX_CSMA_BACKOFF_BASE_SYMBOLS</a></h4>
<ul>
<li>Group: 0x60</li>
<li>Index: 0x06 ... 0x07</li>
<li>Summary: Define the base number of symbols for the CSMA backoff.</li>
<li>Purpose:</li>
<ul><li>
This property defines the base number of symbols for the CSMA backoff array.</li></ul>
<li>Comments (internal):</li>
<ul><li>
Implemented and tested. Possibility to overflow the timer. Firmware calculation is the following: (<a href="#prop-IE154_TX_CSMA_BACKOFF_BASE_SYMBOLS">IE154_TX_CSMA_BACKOFF_BASE_SYMBOLS</a>
 * <a href="#prop-IE154_TX_CSMA_BACKOFF">IE154_TX_CSMA_BACKOFF</a>
 * <a href="#prop-MODEM_XTAL_TICK_PER_SYMBOL">MODEM_XTAL_TICK_PER_SYMBOL</a>
 / 256) < 2^12. 12 bits of timer, 256 xtal ticks/ timer tick. Only the lower 8 bits are currently supported.</li></ul>
<li>Defaults: 0x00, 0x14</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_TX_CSMA_BACKOFF_BASE_SYMBOLS</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="8">CSMA_BACKOFF_BASE_SYMBOLS[15:8]</td>
</tr>
<tr><td>0x07</td>
<td colspan="8">CSMA_BACKOFF_BASE_SYMBOLS[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x07</td>
<td colspan="8">0x14</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_TX%3AIE154_TX_CSMA_BACKOFF_BASE_SYMBOLS">IE154_TX_CSMA_BACKOFF_BASE_SYMBOLS</a><ul>
<li><a name="field-IE154_TX_CSMA_BACKOFF_BASE_SYMBOLS%3ACSMA_BACKOFF_BASE_SYMBOLS">CSMA_BACKOFF_BASE_SYMBOLS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Base number of symbols for CSMA backoff.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_TX_CSMA_BACKOFF">IE154_TX_CSMA_BACKOFF</a></h4>
<ul>
<li>Group: 0x60</li>
<li>Index: 0x08 ... 0x11</li>
<li>Summary: Configure the range of CSMA backoff for five attempts.</li>
<li>Purpose:</li>
<ul><li>
Defines the CSMA backoff min and max times for five attempts. The CSMA backoff then randomized between the min and max value. The resultant value is multipled by the value of <a href="#prop-ie154_tx_csma_backoff_base_symbols">ie154_tx_csma_backoff_base_symbols</a>
 to define the number of backoff symbols. </li></ul>
<li>Comments (internal):</li>
<ul><li>
Implemented and tested.</li></ul>
<li>Defaults: 0x00, 0x07, 0x00, 0x0f, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x1f</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_TX_CSMA_BACKOFF</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x08</td>
<td colspan="8">MIN_0</td>
</tr>
<tr><td>0x09</td>
<td colspan="8">MAX_0</td>
</tr>
<tr><td>0x0a</td>
<td colspan="8">MIN_1</td>
</tr>
<tr><td>0x0b</td>
<td colspan="8">MAX_1</td>
</tr>
<tr><td>0x0c</td>
<td colspan="8">MIN_2</td>
</tr>
<tr><td>0x0d</td>
<td colspan="8">MAX_2</td>
</tr>
<tr><td>0x0e</td>
<td colspan="8">MIN_3</td>
</tr>
<tr><td>0x0f</td>
<td colspan="8">MAX_3</td>
</tr>
<tr><td>0x10</td>
<td colspan="8">MIN_4</td>
</tr>
<tr><td>0x11</td>
<td colspan="8">MAX_4</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x08</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x09</td>
<td colspan="8">0x7</td>
</tr>
<tr><td>0x0a</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x0b</td>
<td colspan="8">0xf</td>
</tr>
<tr><td>0x0c</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x0d</td>
<td colspan="8">0x1f</td>
</tr>
<tr><td>0x0e</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x0f</td>
<td colspan="8">0x1f</td>
</tr>
<tr><td>0x10</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x11</td>
<td colspan="8">0x1f</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_TX%3AIE154_TX_CSMA_BACKOFF">IE154_TX_CSMA_BACKOFF</a><ul>
<li><a name="field-IE154_TX_CSMA_BACKOFF%3AMIN_0">MIN_0</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Minimum backoff time in cca units</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_TX_CSMA_BACKOFF%3AMAX_0">MAX_0</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Maximum backoff time in cca units</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_TX_CSMA_BACKOFF%3AMIN_1">MIN_1</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Minimum backoff time in cca units</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_TX_CSMA_BACKOFF%3AMAX_1">MAX_1</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Maximum backoff time in cca units</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_TX_CSMA_BACKOFF%3AMIN_2">MIN_2</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Minimum backoff time in cca units</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_TX_CSMA_BACKOFF%3AMAX_2">MAX_2</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Maximum backoff time in cca units</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_TX_CSMA_BACKOFF%3AMIN_3">MIN_3</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Minimum backoff time in cca units</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_TX_CSMA_BACKOFF%3AMAX_3">MAX_3</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Maximum backoff time in cca units</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_TX_CSMA_BACKOFF%3AMIN_4">MIN_4</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Minimum backoff time in cca units</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_TX_CSMA_BACKOFF%3AMAX_4">MAX_4</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Maximum backoff time in cca units</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_TX_CSMA_ON_SYMBOLS">IE154_TX_CSMA_ON_SYMBOLS</a></h4>
<ul>
<li>Group: 0x60</li>
<li>Index: 0x12 ... 0x13</li>
<li>Summary: Define the number of symbols to measure RSSI during CCA.</li>
<li>Purpose:</li>
<ul><li>
This property defines the number of symbols used to capture RSSI during CSMA clear channel assessment.</li></ul>
<li>Comments (internal):</li>
<ul><li>
Implemented, and tested.</li></ul>
<li>Defaults: 0x00, 0x08</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_TX_CSMA_ON_SYMBOLS</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x12</td>
<td colspan="8">CSMA_ON_SYMBOLS[15:8]</td>
</tr>
<tr><td>0x13</td>
<td colspan="8">CSMA_ON_SYMBOLS[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x12</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x13</td>
<td colspan="8">0x8</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_TX%3AIE154_TX_CSMA_ON_SYMBOLS">IE154_TX_CSMA_ON_SYMBOLS</a><ul>
<li><a name="field-IE154_TX_CSMA_ON_SYMBOLS%3ACSMA_ON_SYMBOLS">CSMA_ON_SYMBOLS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Define the number of symbols to stay in RX to measure RSSI.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_TX_LBT_CLEAR_TIME_MIN">IE154_TX_LBT_CLEAR_TIME_MIN</a></h4>
<ul>
<li>Group: 0x60</li>
<li>Index: 0x14</li>
<li>Summary: Define the LBT minimum clear time.</li>
<li>Purpose:</li>
<ul><li>
This property defines the minimum value that the channel must be clear for the CCA algorithm Listen Before Talk. This property is defined in milliseconds. The LBT clear time is a random value between the minimum and maximum clear time properties.</li></ul>
<li>Comments (internal):</li>
<ul><li>
Not implemented, not tested.</li></ul>
<li>Defaults: 0x05</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_TX_LBT_CLEAR_TIME_MIN</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x14</td>
<td colspan="8">CLEAR_TIME_MIN</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x14</td>
<td colspan="8">0x5</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_TX%3AIE154_TX_LBT_CLEAR_TIME_MIN">IE154_TX_LBT_CLEAR_TIME_MIN</a><ul>
<li><a name="field-IE154_TX_LBT_CLEAR_TIME_MIN%3ACLEAR_TIME_MIN">CLEAR_TIME_MIN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Minimum amount of time the channel must be clear for LBT.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_TX_LBT_CLEAR_TIME_MAX">IE154_TX_LBT_CLEAR_TIME_MAX</a></h4>
<ul>
<li>Group: 0x60</li>
<li>Index: 0x15</li>
<li>Summary: Define the LBT maximum clear time.</li>
<li>Purpose:</li>
<ul><li>
This property defines the minimum value that the channel must be clear for the CCA algorithm Listen Before Talk. This property is defined in milliseconds. The LBT clear time is a random value between the minimum and maximum clear time properties.</li></ul>
<li>Comments (internal):</li>
<ul><li>
Not implemented, not tested.</li></ul>
<li>Defaults: 0x0a</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_TX_LBT_CLEAR_TIME_MAX</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x15</td>
<td colspan="8">CLEAR_TIME_MAX</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x15</td>
<td colspan="8">0xa</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_TX%3AIE154_TX_LBT_CLEAR_TIME_MAX">IE154_TX_LBT_CLEAR_TIME_MAX</a><ul>
<li><a name="field-IE154_TX_LBT_CLEAR_TIME_MAX%3ACLEAR_TIME_MAX">CLEAR_TIME_MAX</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Maximum amount of time the channel must be clear for LBT.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_TX_LBT_TOTAL_TIME">IE154_TX_LBT_TOTAL_TIME</a></h4>
<ul>
<li>Group: 0x60</li>
<li>Index: 0x16</li>
<li>Summary: Total time to check for a clear channel with the Listen Before Talk algorithm.</li>
<li>Purpose:</li>
<ul><li>
This property defines total time to check for a clear channel with the Listen Before Talk algorithm. A CCA_FAIL interrupt is asserted if the channel is not clear within this time window. This property is defined in milliseconds.</li></ul>
<li>Comments (internal):</li>
<ul><li>
Not implemented, not tested.</li></ul>
<li>Defaults: 0x32</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_TX_LBT_TOTAL_TIME</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x16</td>
<td colspan="8">LBT_TOTAL_TIME</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x16</td>
<td colspan="8">0x32</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_TX%3AIE154_TX_LBT_TOTAL_TIME">IE154_TX_LBT_TOTAL_TIME</a><ul>
<li><a name="field-IE154_TX_LBT_TOTAL_TIME%3ALBT_TOTAL_TIME">LBT_TOTAL_TIME</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Define the total time to check for a clear channel using LBT.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-IE154_RX">IE154_RX</a></h3>
<h4><a name="prop-IE154_RX_FLAGS">IE154_RX_FLAGS</a></h4>
<ul>
<li>Group: 0x61</li>
<li>Index: 0x00</li>
<li>Summary: Control fields for Rx mode.</li>
<li>Purpose:</li>
<ul><li>
Rx flags</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS:
                        frame_pending_default_value: Implemented and tested
                        src_addr_event_with_ack: Implemented and used, not fully tested
                        auto_ack: Implemented, used and tested; Need to correct erroneous time-out notification
                        filtering: Implemented and tested: Short address, extended address, beacon frame, different frame combiations creating ill formed packets for 2006 spec</li></ul>
<li>Defaults: 0x13</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_RX_FLAGS</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0</td>
<td>0</td>
<td colspan="1">FRAME_PENDING_DEFAULT_VALUE</td>
<td colspan="1">SRC_ADDR_EVENT_ONLY_ON_ACK_REQUESTS</td>
<td colspan="1">SRC_ADDR_EVENT_DELAY</td>
<td>0</td>
<td colspan="1">AUTO_ACK_DEFAULT_VALUE</td>
<td colspan="1">FILTERING</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x1</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td colspan="1">0x1</td>
<td colspan="1">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_RX%3AIE154_RX_FLAGS">IE154_RX_FLAGS</a><ul>
<li><a name="field-IE154_RX_FLAGS%3AFRAME_PENDING_DEFAULT_VALUE">FRAME_PENDING_DEFAULT_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Default value of the frame pending bit in the Frame Control Field of the automatic acknowledge.  Can be modified using <a href="#cmd-IE154_OVERRIDE_NEXT_ACK"><code>IE154_OVERRIDE_NEXT_ACK</code></a>
.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-IE154_RX_FLAGS%3ASRC_ADDR_EVENT_ONLY_ON_ACK_REQUESTS">SRC_ADDR_EVENT_ONLY_ON_ACK_REQUESTS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Controls source address event when an Acknowledge is requested.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
SRC_ADDR events will only be posted for incoming frames which have the ACK Requested bit set in their Frame Control Field.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
SRC_ADDR events will be posted for all incoming frame with a source address field available to read from the Rx FIFO.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-IE154_RX_FLAGS%3ASRC_ADDR_EVENT_DELAY">SRC_ADDR_EVENT_DELAY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Controls if the source address event is delayed until the MAC command byte is received.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">NONE</td><td>0</td><td align="left">
<ul><li>
SRC_ADDR events post normally.</li></ul>
</td></tr>
<tr valign="top"><td align="left">MAC_CMD_BYTE</td><td>1</td><td align="left">
<ul><li>
If a SRC_ADDR event occurs, the event will post one byte later after receiving the MAC command byte.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-IE154_RX_FLAGS%3AAUTO_ACK_DEFAULT_VALUE">AUTO_ACK_DEFAULT_VALUE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Controls default auto ACK functionality in RX mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
If the packet, passes filtering, requests an ACK, and has a valid CRC, The ACK message is transmitted at the time specified by <a href="#prop-IE154_RX_BACKOFF_TURNAROUND_TIME">IE154_RX_BACKOFF_TURNAROUND_TIME</a>
.                Before the ACK is transmitted this behavior can be modified using <a href="#cmd-IE154_OVERRIDE_NEXT_ACK"><code>IE154_OVERRIDE_NEXT_ACK</code></a>

              </li><li>
After the ACK is transmitted the chip will transition to <a href="#field-IE154_START_RX%3ANEXT_MODE%3ARX_COMPLETE_MODE">IE154_START_RX:NEXT_MODE:RX_COMPLETE_MODE</a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Automatic acknowledge will not be transmitted.                </li><li>
After packet reception the chip will transition to  <a href="#field-IE154_START_RX%3ANEXT_MODE%3ARX_COMPLETE_MODE">IE154_START_RX:NEXT_MODE:RX_COMPLETE_MODE</a>
.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-IE154_RX_FLAGS%3AFILTERING">FILTERING</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Controls address filtering functionality in in RX mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Enable address filtering.  Packet will be validated based on data length (as defined in <a href="#prop-IE154_RX_MAX_PAYLOAD_SIZE">IE154_RX_MAX_PAYLOAD_SIZE</a>
)               FCF, and destination address.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Disable address filtering.  Packet will be validated based on data length (as defined in <a href="#prop-IE154_RX_MAX_PAYLOAD_SIZE">IE154_RX_MAX_PAYLOAD_SIZE</a>
)               FCF.
             </li><li>
This bit does not control auto ack functionality therefore the radio could mistakenly ACK a packet not addressed to it.                  This feature is controlled by <a href="#field-IE154_RX_FLAGS%3AAUTO_ACK">IE154_RX_FLAGS:AUTO_ACK</a>
 and it is recommended to disable auto ack in this mode.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_RX_FLAGS2">IE154_RX_FLAGS2</a></h4>
<ul>
<li>Group: 0x61</li>
<li>Index: 0x01</li>
<li>Summary: Control fields for Rx mode.</li>
<li>Purpose:</li>
<ul><li>
Rx flags 2</li></ul>
<li>Comments (internal):</li>
<ul><li>
Spare byte for future rx flags.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_RX_FLAGS2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">RESERVED</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_RX%3AIE154_RX_FLAGS2">IE154_RX_FLAGS2</a><ul>
<li><a name="field-IE154_RX_FLAGS2%3ARESERVED">RESERVED</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Rx flags 2</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_RX_BACKOFF_TURNAROUND_TIME">IE154_RX_BACKOFF_TURNAROUND_TIME</a></h4>
<ul>
<li>Group: 0x61</li>
<li>Index: 0x02</li>
<li>Summary: Turnaround time between receiving the packet and transmitting the ack</li>
<li>Purpose:</li>
<ul><li>
Define the turnaround time after receiving a packet and transmitting the ack in symbols.</li></ul>
<li>Defaults: 0x0c</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_RX_BACKOFF_TURNAROUND_TIME</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="8">BACKOFF_TURNAROUND_TIME</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="8">0xc</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_RX%3AIE154_RX_BACKOFF_TURNAROUND_TIME">IE154_RX_BACKOFF_TURNAROUND_TIME</a><ul>
<li><a name="field-IE154_RX_BACKOFF_TURNAROUND_TIME%3ABACKOFF_TURNAROUND_TIME">BACKOFF_TURNAROUND_TIME</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Define the turnaround time after receiving a packet and transmitting the ack in symbols.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_RX_EUI_64">IE154_RX_EUI_64</a></h4>
<ul>
<li>Group: 0x61</li>
<li>Index: 0x03 ... 0x0a</li>
<li>Summary: Configure EUI 64</li>
<li>Purpose:</li>
<ul><li>
Unique identifier for the node</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented and tested   
</li></ul>
<li>Defaults: 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_RX_EUI_64</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="8">EUI_64[63:56]</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">EUI_64[55:48]</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">EUI_64[47:40]</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">EUI_64[39:32]</td>
</tr>
<tr><td>0x07</td>
<td colspan="8">EUI_64[31:24]</td>
</tr>
<tr><td>0x08</td>
<td colspan="8">EUI_64[23:16]</td>
</tr>
<tr><td>0x09</td>
<td colspan="8">EUI_64[15:8]</td>
</tr>
<tr><td>0x0a</td>
<td colspan="8">EUI_64[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x07</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x08</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x09</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x0a</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_RX%3AIE154_RX_EUI_64">IE154_RX_EUI_64</a><ul>
<li><a name="field-IE154_RX_EUI_64%3AEUI_64">EUI_64</a>
<dl><dt>Description:</dt><dd>
<ul><li>
64-bit unique identifier</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-IE154_COMMON">IE154_COMMON</a></h3>
<h4><a name="prop-IE154_COMMON_FLAGS">IE154_COMMON_FLAGS</a></h4>
<ul>
<li>Group: 0x62</li>
<li>Index: 0x00</li>
<li>Summary: TODO</li>
<li>Purpose:</li>
<ul><li>
TODO</li></ul>
<li>Defaults: 0x80</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_COMMON_FLAGS</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="2">FRAME_VERSION_FILTER</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="2">0x2</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_COMMON%3AIE154_COMMON_FLAGS">IE154_COMMON_FLAGS</a><ul>
<li><a name="field-IE154_COMMON_FLAGS%3AFRAME_VERSION_FILTER">FRAME_VERSION_FILTER</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Specifies which 802.15.4 frame version is accepted by the radio when receiving data packets in RX mode and receiving ACK packets in TX mode.               This does not specify the frame version that ACKs should be transmitted with.  They will inherit the data packet frame version.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">2003</td><td>0</td><td align="left">
<ul><li>
Accept only 2003 frame type.</li></ul>
</td></tr>
<tr valign="top"><td align="left">2006</td><td>1</td><td align="left">
<ul><li>
Accept 2006 and 2003 frame types.</li></ul>
</td></tr>
<tr valign="top"><td align="left">2012</td><td>2</td><td align="left">
<ul><li>
Accept 2012, 2006, and 2003 frame types.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_COMMON_PHY_CFG">IE154_COMMON_PHY_CFG</a></h4>
<ul>
<li>Group: 0x62</li>
<li>Index: 0x01</li>
<li>Summary: TODO</li>
<li>Purpose:</li>
<ul><li>
TODO</li></ul>
<li>Defaults: 0x03</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_COMMON_PHY_CFG</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="1">PHY_VER</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CODING</td>
<td colspan="1">APPEND_CRC</td>
<td colspan="1">CHECK_CRC</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x1</td>
<td colspan="1">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_COMMON%3AIE154_COMMON_PHY_CFG">IE154_COMMON_PHY_CFG</a><ul>
<li><a name="field-IE154_COMMON_PHY_CFG%3APHY_VER">PHY_VER</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Determines the coding of recieved and transmitted packets.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">STD</td><td>0</td><td align="left">
<ul><li>
802.15.4 standard phy</li></ul>
</td></tr>
<tr valign="top"><td align="left">G</td><td>1</td><td align="left">
<ul><li>
802.15.4g phy</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-IE154_COMMON_PHY_CFG%3ACODING">CODING</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Determines the coding of recieved and transmitted packets.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">2FSK</td><td>0</td><td align="left">
<ul><li>
Packet is 2FSK encoded</li></ul>
</td></tr>
<tr valign="top"><td align="left">4FSK</td><td>1</td><td align="left">
<ul><li>
Packet is 4FSK encoded</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-IE154_COMMON_PHY_CFG%3AAPPEND_CRC">APPEND_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Determines whether or not the CRC is appended to the packet</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DONT_APPEND_CRC</td><td>0</td><td align="left">
<ul><li>
Don't append CRC</li></ul>
</td></tr>
<tr valign="top"><td align="left">APPEND_CRC</td><td>1</td><td align="left">
<ul><li>
Append CRC</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-IE154_COMMON_PHY_CFG%3ACHECK_CRC">CHECK_CRC</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Controls auto CRC functionality in RX data packets in RX mode and RX ACK packets in TX mode. </li></ul>
</dd></dl>
<dl><dt>Comments:</dt><dd>
<ul><li>
Not implemented in ROM4</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Enables CRC validation in the transceiver.  The CRC will not be placed into the RX FIFO.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Disable CRC validation in the transceiver.  The CRC will be placed into the RX FIFO for host validation.
             </li><li>
This bit does not control auto ack functionality therefore the radio could mistakenly ACK a crc invalid packet.                  This feature is controlled by <a href="#field-IE154_RX_FLAGS%3AAUTO_ACK">IE154_RX_FLAGS:AUTO_ACK</a>
 and it is recommended to disable auto ack in this mode.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_COMMON_MAX_PAYLOAD_SIZE">IE154_COMMON_MAX_PAYLOAD_SIZE</a></h4>
<ul>
<li>Group: 0x62</li>
<li>Index: 0x02 ... 0x03</li>
<li>Summary: Configure maximum allowed payload size.  Packets that have a length larger than this value will be filtered out and will not be placed into the RX FIFO.</li>
<li>Purpose:</li>
<ul><li>
Maximum payload size of the packet</li></ul>
<li>Comments (internal):</li>
<ul><li>
Added, not used nor tested </li></ul>
<li>Defaults: 0x00, 0x7d</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_COMMON_MAX_PAYLOAD_SIZE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="8">MAX_PAYLOAD_SIZE[15:8]</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">MAX_PAYLOAD_SIZE[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">0x7d</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_COMMON%3AIE154_COMMON_MAX_PAYLOAD_SIZE">IE154_COMMON_MAX_PAYLOAD_SIZE</a><ul>
<li><a name="field-IE154_COMMON_MAX_PAYLOAD_SIZE%3AMAX_PAYLOAD_SIZE">MAX_PAYLOAD_SIZE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
16-bit max payload size</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_COMMON_MIN_PAYLOAD_SIZE">IE154_COMMON_MIN_PAYLOAD_SIZE</a></h4>
<ul>
<li>Group: 0x62</li>
<li>Index: 0x04</li>
<li>Summary:  Configure minimum allowed payload size when </li>
<li>Purpose:</li>
<ul><li>
Minimum payload size of the packet when filtering is disabled.</li></ul>
<li>Defaults: 0x02</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_COMMON_MIN_PAYLOAD_SIZE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="8">MIN_PAYLOAD_SIZE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="8">0x2</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_COMMON%3AIE154_COMMON_MIN_PAYLOAD_SIZE">IE154_COMMON_MIN_PAYLOAD_SIZE</a><ul>
<li><a name="field-IE154_COMMON_MIN_PAYLOAD_SIZE%3AMIN_PAYLOAD_SIZE">MIN_PAYLOAD_SIZE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Minimum payload size.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_COMMON_XTAL_TICK_PER_SYMBOL">IE154_COMMON_XTAL_TICK_PER_SYMBOL</a></h4>
<ul>
<li>Group: 0x62</li>
<li>Index: 0x05 ... 0x06</li>
<li>Summary: Defines the number of crystal ticks that makes up a symbol time.</li>
<li>Purpose:</li>
<ul><li>
Number of crystal ticks per symbol time</li></ul>
<li>Comments (internal):</li>
<ul><li>
Implemented and tested.</li></ul>
<li>Defaults: 0x01, 0x2c</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_COMMON_XTAL_TICK_PER_SYMBOL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="1">XTAL_TICK_UNITS</td>
<td colspan="7">NUM_XTAL_UNITS_PER_SYM[14:8]</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">NUM_XTAL_UNITS_PER_SYM[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x05</td>
<td colspan="1">0x0</td>
<td colspan="7">0x1</td>
</tr>
<tr><td>0x06</td>
<td colspan="8">0x2c</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_COMMON%3AIE154_COMMON_XTAL_TICK_PER_SYMBOL">IE154_COMMON_XTAL_TICK_PER_SYMBOL</a><ul>
<li><a name="field-IE154_COMMON_XTAL_TICK_PER_SYMBOL%3AXTAL_TICK_UNITS">XTAL_TICK_UNITS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Xtal tick units.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DIV_1</td><td>0</td><td align="left">
<ul><li>
XTAL tick unit time is crystal tick divided by 1.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DIV_256</td><td>1</td><td align="left">
<ul><li>
XTAL tick unit time is crystal tick divided by 256.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-IE154_COMMON_XTAL_TICK_PER_SYMBOL%3ANUM_XTAL_UNITS_PER_SYM">NUM_XTAL_UNITS_PER_SYM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Defines the number of xtal tick units per symbol time.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-IE154_INT_CTL">IE154_INT_CTL</a></h3>
<h4><a name="prop-IE154_INT_CTL_ENABLE">IE154_INT_CTL_ENABLE</a></h4>
<ul>
<li>Group: 0x63</li>
<li>Index: 0x00</li>
<li>Summary: INTERNAL STATUS: Implemented, not fully tested
                        tx_int_status_en: Implemented, not used nor tested
                        rx_int_status_en: Implemented, not used nor tested
                        chip_int_status_en: Implemented, not used nor tested
                        This property provides for global enabling of the three interrupt groups in order to generate HW interrupts at the NIRQ pin.</li>
<li>Purpose:</li>
<ul><li>
INTERNAL STATUS: Implemented, not fully tested
                        tx_int_status_en: Implemented, not used nor tested
                        rx_int_status_en: Implemented, not used nor tested
                        chip_int_status_en: Implemented, not used nor tested
                        Enables top-level interrupt sources to generate HW interrupts at the NIRQ pin.</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented, not fully tested
                        tx_int_status_en: Implemented, not used nor tested
                        rx_int_status_en: Implemented, not used nor tested
                        chip_int_status_en: Implemented, not used nor tested
                        </li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_INT_CTL_ENABLE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CHIP_INT_STATUS_EN</td>
<td colspan="1">RX_INT_STATUS_EN</td>
<td colspan="1">TX_INT_STATUS_EN</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_INT_CTL%3AIE154_INT_CTL_ENABLE">IE154_INT_CTL_ENABLE</a><ul>
<li><a name="field-IE154_INT_CTL_ENABLE%3ACHIP_INT_STATUS_EN">CHIP_INT_STATUS_EN</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable pending interrupts in the Chip Status group from asserting nNIRQ.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable pending interrupts in the Chip Status group to assert nNIRQ.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_ENABLE%3ARX_INT_STATUS_EN">RX_INT_STATUS_EN</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable pending interrupts in rx mode group from asserting nNIRQ.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable pending interrupts in rx mode group to assert nNIRQ.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_ENABLE%3ATX_INT_STATUS_EN">TX_INT_STATUS_EN</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DISABLED</td><td>0</td><td align="left">
<ul><li>
Disable pending interrupts in tx mode group from asserting nNIRQ.</li></ul>
</td></tr>
<tr valign="top"><td align="left">ENABLED</td><td>1</td><td align="left">
<ul><li>
Enable pending interrupts in tx mode group to assert nNIRQ.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_INT_CTL_TX_ENABLE">IE154_INT_CTL_TX_ENABLE</a></h4>
<ul>
<li>Group: 0x63</li>
<li>Index: 0x01</li>
<li>Summary: INTERNAL STATUS: Implemented, Does not seem to be used for any flag ??
Configure 802.15.4 Tx Interrupts</li>
<li>Purpose:</li>
<ul><li>
Enable/Disable 802.15.4 Tx Interrupts</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented, Does not seem to be used for any flag ??
</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_INT_CTL_TX_ENABLE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="1">TX_ERROR</td>
<td colspan="1">TX_FIFO_ALMOST_EMPTY</td>
<td>0</td>
<td>0</td>
<td colspan="1">TX_ACK_RECEIVED_W_FP</td>
<td colspan="1">TX_ACK_RECEIVED_NO_FP</td>
<td colspan="1">TX_COMPLETE</td>
<td colspan="1">TX_SFD_SENT</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_INT_CTL%3AIE154_INT_CTL_TX_ENABLE">IE154_INT_CTL_TX_ENABLE</a><ul>
<li><a name="field-IE154_INT_CTL_TX_ENABLE%3ATX_ERROR">TX_ERROR</a>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_TX_ENABLE%3ATX_FIFO_ALMOST_EMPTY">TX_FIFO_ALMOST_EMPTY</a>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_TX_ENABLE%3ATX_ACK_RECEIVED_W_FP">TX_ACK_RECEIVED_W_FP</a>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_TX_ENABLE%3ATX_ACK_RECEIVED_NO_FP">TX_ACK_RECEIVED_NO_FP</a>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_TX_ENABLE%3ATX_COMPLETE">TX_COMPLETE</a>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_TX_ENABLE%3ATX_SFD_SENT">TX_SFD_SENT</a>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_INT_CTL_RX_ENABLE">IE154_INT_CTL_RX_ENABLE</a></h4>
<ul>
<li>Group: 0x63</li>
<li>Index: 0x02</li>
<li>Summary: INTERNAL STATUS: Implemented, Does not seem to be used for any flag ??
Configure 802.15.4 Rx Interrupts</li>
<li>Purpose:</li>
<ul><li>
INTERNAL STATUS: Implemented, Does not seem to be used for any flag ??
Enable/Disable 802.15.4 Rx Interrupts</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented, Does not seem to be used for any flag ??
</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_INT_CTL_RX_ENABLE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="1">RX_ERROR</td>
<td colspan="1">RX_FIFO_ALMOST_FULL</td>
<td>0</td>
<td>0</td>
<td colspan="1">RX_ACK_TX_COMPLETE</td>
<td colspan="1">RX_COMPLETE</td>
<td colspan="1">RX_SRC_ADDR</td>
<td colspan="1">RX_SFD</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_INT_CTL%3AIE154_INT_CTL_RX_ENABLE">IE154_INT_CTL_RX_ENABLE</a><ul>
<li><a name="field-IE154_INT_CTL_RX_ENABLE%3ARX_ERROR">RX_ERROR</a>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_RX_ENABLE%3ARX_FIFO_ALMOST_FULL">RX_FIFO_ALMOST_FULL</a>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_RX_ENABLE%3ARX_ACK_TX_COMPLETE">RX_ACK_TX_COMPLETE</a>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_RX_ENABLE%3ARX_COMPLETE">RX_COMPLETE</a>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_RX_ENABLE%3ARX_SRC_ADDR">RX_SRC_ADDR</a>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_RX_ENABLE%3ARX_SFD">RX_SFD</a>
<dl><dt>Type:</dt>
<dd>BOOL</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_INT_CTL_IE154_CHIP_ENABLE">IE154_INT_CTL_IE154_CHIP_ENABLE</a></h4>
<ul>
<li>Group: 0x63</li>
<li>Index: 0x03</li>
<li>Summary: INTERNAL STATUS: Implemented, Does not seem to be used for any flag ??
Enable individual interrupt sources within the Chip Interrupt Group to generate a HW interrupt on the NIRQ output pin.</li>
<li>Purpose:</li>
<ul><li>
INTERNAL STATUS: Implemented, Does not seem to be used for any flag ??
Enable individual interrupt sources within the Chip Interrupt Group in order to generate a HW interrupt at the NIRQ output pin.</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented, Does not seem to be used for any flag ??
</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_INT_CTL_IE154_CHIP_ENABLE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x03</td>
<td>0</td>
<td colspan="1">CAL_EN</td>
<td colspan="1">FIFO_UNDERFLOW_OVERFLOW_ERROR_EN</td>
<td colspan="1">STATE_CHANGE_EN</td>
<td colspan="1">CMD_ERROR_EN</td>
<td colspan="1">CHIP_READY_EN</td>
<td colspan="1">LOW_BATT_EN</td>
<td colspan="1">WUT_EN</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x03</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_INT_CTL%3AIE154_INT_CTL_IE154_CHIP_ENABLE">IE154_INT_CTL_IE154_CHIP_ENABLE</a><ul>
<li><a name="field-IE154_INT_CTL_IE154_CHIP_ENABLE%3ACAL_EN">CAL_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables CAL interrupt on rising edge of CAL status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_IE154_CHIP_ENABLE%3AFIFO_UNDERFLOW_OVERFLOW_ERROR_EN">FIFO_UNDERFLOW_OVERFLOW_ERROR_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables FIFO_UNDERFLOW_OVERFLOW_ERROR interrupt on rising edge of FIFO_UNDERFLOW_OVERFLOW_ERROR status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_IE154_CHIP_ENABLE%3ASTATE_CHANGE_EN">STATE_CHANGE_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables STATE_CHANGE interrupt on rising edge of STATE_CHANGE status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_IE154_CHIP_ENABLE%3ACMD_ERROR_EN">CMD_ERROR_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables CMD_ERROR interrupt on rising edge of CMD_ERROR status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_IE154_CHIP_ENABLE%3ACHIP_READY_EN">CHIP_READY_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables CHIP_READY interrupt on rising edge of CHIP_READY status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_IE154_CHIP_ENABLE%3ALOW_BATT_EN">LOW_BATT_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables LOW_BATT interrupt on rising edge of LOW_BATT status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-IE154_INT_CTL_IE154_CHIP_ENABLE%3AWUT_EN">WUT_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
If set, Enables WUT interrupt on rising edge of WUT status bit.  See the status bits in <a href="#cmd-GET_INT_STATUS"><code>GET_INT_STATUS</code></a>
 for more details on the interrupt sources.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-IE154_NETWORK">IE154_NETWORK</a></h3>
<h4><a name="prop-IE154_NETWORK_COORDINATOR_MASK">IE154_NETWORK_COORDINATOR_MASK</a></h4>
<ul>
<li>Group: 0x64</li>
<li>Index: 0x00</li>
<li>Summary: Configure network coordinator mask</li>
<li>Purpose:</li>
<ul><li>
Defines the coordinator mask used for filtering</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented and tested  
</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_NETWORK_COORDINATOR_MASK</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">NETWORK3</td>
<td colspan="1">NETWORK2</td>
<td colspan="1">NETWORK1</td>
<td colspan="1">NETWORK0</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_NETWORK%3AIE154_NETWORK_COORDINATOR_MASK">IE154_NETWORK_COORDINATOR_MASK</a><ul>
<li><a name="field-IE154_NETWORK_COORDINATOR_MASK%3ANETWORK3">NETWORK3</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Network 3 is a coordinator</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-IE154_NETWORK_COORDINATOR_MASK%3ANETWORK2">NETWORK2</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Network 2 is a coordinator</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-IE154_NETWORK_COORDINATOR_MASK%3ANETWORK1">NETWORK1</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Network 1 is a coordinator</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-IE154_NETWORK_COORDINATOR_MASK%3ANETWORK0">NETWORK0</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Network 0 is a coordinator</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_NETWORK_LIST">IE154_NETWORK_LIST</a></h4>
<ul>
<li>Group: 0x64</li>
<li>Index: 0x01 ... 0x06</li>
<li>Summary: Configure PAN ID, node ID and channel ID</li>
<li>Purpose:</li>
<ul><li>
ID of the PAN the node associates to, the corresponding ID of this node and the corresponding channel</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented and tested group 0.
                           Currently testing channel_power member </li></ul>
<li>Defaults: 0xff, 0xff, 0xff, 0xfe, 0x00, 0x0f</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_NETWORK_LIST</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">PAN_ID[15:8]</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">PAN_ID[7:0]</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">NODE_ID[15:8]</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">NODE_ID[7:0]</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">CHANNEL</td>
</tr>
<tr><td>0x06</td>
<td>0</td>
<td colspan="7">TX_POWER</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">0xff</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">0xff</td>
</tr>
<tr><td>0x03</td>
<td colspan="8">0xff</td>
</tr>
<tr><td>0x04</td>
<td colspan="8">0xfe</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x06</td>
<td>0x0</td>
<td colspan="7">0xf</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_NETWORK%3AIE154_NETWORK_LIST">IE154_NETWORK_LIST</a><ul>
<li><a name="field-IE154_NETWORK_LIST%3APAN_ID">PAN_ID</a>
<dl><dt>Description:</dt><dd>
<ul><li>
16-bit PAN ID</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_NETWORK_LIST%3ANODE_ID">NODE_ID</a>
<dl><dt>Description:</dt><dd>
<ul><li>
16-bit node ID</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_NETWORK_LIST%3ACHANNEL">CHANNEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
8 bit channel ID</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_NETWORK_LIST%3ATX_POWER">TX_POWER</a>
<dl><dt>Description:</dt><dd>
<ul><li>
7 bit output power level for the corresponding channel</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_NETWORK_LIST">IE154_NETWORK_LIST</a></h4>
<ul>
<li>Group: 0x64</li>
<li>Index: 0x07 ... 0x0c</li>
<li>Summary: Configure PAN ID, node ID and channel ID</li>
<li>Purpose:</li>
<ul><li>
ID of the PAN the node associates to, the corresponding ID of this node and the corresponding channel</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented and tested group 0.
                           Currently testing channel_power member </li></ul>
<li>Defaults: 0xff, 0xff, 0xff, 0xfe, 0x00, 0x0f</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_NETWORK_LIST</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x07</td>
<td colspan="8">PAN_ID[15:8]</td>
</tr>
<tr><td>0x08</td>
<td colspan="8">PAN_ID[7:0]</td>
</tr>
<tr><td>0x09</td>
<td colspan="8">NODE_ID[15:8]</td>
</tr>
<tr><td>0x0a</td>
<td colspan="8">NODE_ID[7:0]</td>
</tr>
<tr><td>0x0b</td>
<td colspan="8">CHANNEL</td>
</tr>
<tr><td>0x0c</td>
<td>0</td>
<td colspan="7">TX_POWER</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x07</td>
<td colspan="8">0xff</td>
</tr>
<tr><td>0x08</td>
<td colspan="8">0xff</td>
</tr>
<tr><td>0x09</td>
<td colspan="8">0xff</td>
</tr>
<tr><td>0x0a</td>
<td colspan="8">0xfe</td>
</tr>
<tr><td>0x0b</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x0c</td>
<td>0x0</td>
<td colspan="7">0xf</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_NETWORK%3AIE154_NETWORK_LIST">IE154_NETWORK_LIST</a><ul>
<li><a name="field-IE154_NETWORK_LIST%3APAN_ID">PAN_ID</a>
<dl><dt>Description:</dt><dd>
<ul><li>
16-bit PAN ID</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_NETWORK_LIST%3ANODE_ID">NODE_ID</a>
<dl><dt>Description:</dt><dd>
<ul><li>
16-bit node ID</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_NETWORK_LIST%3ACHANNEL">CHANNEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
8 bit channel ID</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_NETWORK_LIST%3ATX_POWER">TX_POWER</a>
<dl><dt>Description:</dt><dd>
<ul><li>
7 bit output power level for the corresponding channel</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_NETWORK_LIST">IE154_NETWORK_LIST</a></h4>
<ul>
<li>Group: 0x64</li>
<li>Index: 0x0d ... 0x12</li>
<li>Summary: Configure PAN ID, node ID and channel ID</li>
<li>Purpose:</li>
<ul><li>
ID of the PAN the node associates to, the corresponding ID of this node and the corresponding channel</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented and tested group 0.
                           Currently testing channel_power member </li></ul>
<li>Defaults: 0xff, 0xff, 0xff, 0xfe, 0x00, 0x0f</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_NETWORK_LIST</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0d</td>
<td colspan="8">PAN_ID[15:8]</td>
</tr>
<tr><td>0x0e</td>
<td colspan="8">PAN_ID[7:0]</td>
</tr>
<tr><td>0x0f</td>
<td colspan="8">NODE_ID[15:8]</td>
</tr>
<tr><td>0x10</td>
<td colspan="8">NODE_ID[7:0]</td>
</tr>
<tr><td>0x11</td>
<td colspan="8">CHANNEL</td>
</tr>
<tr><td>0x12</td>
<td>0</td>
<td colspan="7">TX_POWER</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0d</td>
<td colspan="8">0xff</td>
</tr>
<tr><td>0x0e</td>
<td colspan="8">0xff</td>
</tr>
<tr><td>0x0f</td>
<td colspan="8">0xff</td>
</tr>
<tr><td>0x10</td>
<td colspan="8">0xfe</td>
</tr>
<tr><td>0x11</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x12</td>
<td>0x0</td>
<td colspan="7">0xf</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_NETWORK%3AIE154_NETWORK_LIST">IE154_NETWORK_LIST</a><ul>
<li><a name="field-IE154_NETWORK_LIST%3APAN_ID">PAN_ID</a>
<dl><dt>Description:</dt><dd>
<ul><li>
16-bit PAN ID</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_NETWORK_LIST%3ANODE_ID">NODE_ID</a>
<dl><dt>Description:</dt><dd>
<ul><li>
16-bit node ID</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_NETWORK_LIST%3ACHANNEL">CHANNEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
8 bit channel ID</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_NETWORK_LIST%3ATX_POWER">TX_POWER</a>
<dl><dt>Description:</dt><dd>
<ul><li>
7 bit output power level for the corresponding channel</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-IE154_NETWORK_LIST">IE154_NETWORK_LIST</a></h4>
<ul>
<li>Group: 0x64</li>
<li>Index: 0x13 ... 0x18</li>
<li>Summary: Configure PAN ID, node ID and channel ID</li>
<li>Purpose:</li>
<ul><li>
ID of the PAN the node associates to, the corresponding ID of this node and the corresponding channel</li></ul>
<li>Comments (internal):</li>
<ul><li>
INTERNAL STATUS: Implemented and tested group 0.
                           Currently testing channel_power member </li></ul>
<li>Defaults: 0xff, 0xff, 0xff, 0xfe, 0x00, 0x0f</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">IE154_NETWORK_LIST</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x13</td>
<td colspan="8">PAN_ID[15:8]</td>
</tr>
<tr><td>0x14</td>
<td colspan="8">PAN_ID[7:0]</td>
</tr>
<tr><td>0x15</td>
<td colspan="8">NODE_ID[15:8]</td>
</tr>
<tr><td>0x16</td>
<td colspan="8">NODE_ID[7:0]</td>
</tr>
<tr><td>0x17</td>
<td colspan="8">CHANNEL</td>
</tr>
<tr><td>0x18</td>
<td>0</td>
<td colspan="7">TX_POWER</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x13</td>
<td colspan="8">0xff</td>
</tr>
<tr><td>0x14</td>
<td colspan="8">0xff</td>
</tr>
<tr><td>0x15</td>
<td colspan="8">0xff</td>
</tr>
<tr><td>0x16</td>
<td colspan="8">0xfe</td>
</tr>
<tr><td>0x17</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x18</td>
<td>0x0</td>
<td colspan="7">0xf</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-IE154_NETWORK%3AIE154_NETWORK_LIST">IE154_NETWORK_LIST</a><ul>
<li><a name="field-IE154_NETWORK_LIST%3APAN_ID">PAN_ID</a>
<dl><dt>Description:</dt><dd>
<ul><li>
16-bit PAN ID</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_NETWORK_LIST%3ANODE_ID">NODE_ID</a>
<dl><dt>Description:</dt><dd>
<ul><li>
16-bit node ID</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_NETWORK_LIST%3ACHANNEL">CHANNEL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
8 bit channel ID</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
<li><a name="field-IE154_NETWORK_LIST%3ATX_POWER">TX_POWER</a>
<dl><dt>Description:</dt><dd>
<ul><li>
7 bit output power level for the corresponding channel</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-MBUS">MBUS</a></h3>
<h4><a name="prop-MBUS_FRAME">MBUS_FRAME</a></h4>
<ul>
<li>Group: 0x70</li>
<li>Index: 0x00</li>
<li>Summary: Controls data frame format and encoding.</li>
<li>Purpose:</li>
<ul><li>
used to configure mbus</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">MBUS_FRAME</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="4">DUMMY</td>
<td colspan="2">CODEC</td>
<td colspan="2">FORMAT</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="4">0x0</td>
<td colspan="2">0x0</td>
<td colspan="2">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-MBUS%3AMBUS_FRAME">MBUS_FRAME</a><ul>
<li><a name="field-MBUS_FRAME%3ADUMMY">DUMMY</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">DUMMY_0</td><td>0</td><td align="left">
<ul><li>
Used for dummy</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MBUS_FRAME%3ACODEC">CODEC</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">RAW</td><td>0</td><td align="left">
<ul><li>
No added encoding or decoding. Data is treated as NRZ.</li></ul>
</td></tr>
<tr valign="top"><td align="left">MANCHESTER</td><td>1</td><td align="left">
<ul><li>
Transmit data will be manchester encoded before transmit, and decoded after receive.</li></ul>
</td></tr>
<tr valign="top"><td align="left">3_OF_6</td><td>2</td><td align="left">
<ul><li>
Transmit data will be 3/6 encoded before transmit, and decoded after receive.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-MBUS_FRAME%3AFORMAT">FORMAT</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">FORMAT_RAW</td><td>0</td><td align="left">
<ul><li>
No frame formatting.</li></ul>
</td></tr>
<tr valign="top"><td align="left">FORMAT_A</td><td>1</td><td align="left">
<ul><li>
Frame format A.</li></ul>
</td></tr>
<tr valign="top"><td align="left">FORMAT_B</td><td>2</td><td align="left">
<ul><li>
Frame format B.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-PTI">PTI</a></h3>
<h4><a name="prop-PTI_CTL">PTI_CTL</a></h4>
<ul>
<li>Group: 0xf0</li>
<li>Index: 0x00</li>
<li>Summary: Packet Trace Interface control fields.</li>
<li>Purpose:</li>
<ul><li>
The chip contains packet trace interface for debugging network protocols.  This property controls the behavior of this interface.</li></ul>
<li>Defaults: 0x80</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PTI_CTL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="1">PTI_EN</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="1">0x1</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PTI%3APTI_CTL">PTI_CTL</a><ul>
<li><a name="field-PTI_CTL%3APTI_EN">PTI_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Controls global enable of the PTI functionality.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Enable PTI signal to GPIO.  GPIO must be configured using <a href="#cmd-GPIO_PIN_CFG"><code>GPIO_PIN_CFG</code></a>
.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Disable PTI signal to GPIO.  GPIO must be configured using <a href="#cmd-GPIO_PIN_CFG"><code>GPIO_PIN_CFG</code></a>
.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PTI_BAUD">PTI_BAUD</a></h4>
<ul>
<li>Group: 0xf0</li>
<li>Index: 0x01 ... 0x02</li>
<li>Summary: Desired baud rate for the PTI interface.</li>
<li>Purpose:</li>
<ul><li>
The chip contains a packet trace interface for network debugging.  This data is transmitted to               host debugger using a UART connection on a GPIO pin (selected using <a href="#cmd-GPIO_PIN_CFG"><code>GPIO_PIN_CFG</code></a>
).  This property sets the
              baud rate of the packet trace data in 100 baud steps.</li></ul>
<li>Defaults: 0x13, 0x88</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PTI_BAUD</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">BAUD[15:8]</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">BAUD[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x01</td>
<td colspan="8">0x13</td>
</tr>
<tr><td>0x02</td>
<td colspan="8">0x88</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PTI%3APTI_BAUD">PTI_BAUD</a><ul>
<li><a name="field-PTI_BAUD%3ABAUD">BAUD</a>
<dl><dt>Description:</dt><dd>
<ul><li>
baud</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U16</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PTI_LOG_EN">PTI_LOG_EN</a></h4>
<ul>
<li>Group: 0xf0</li>
<li>Index: 0x03</li>
<li>Summary: Enables what the PTI logs.</li>
<li>Purpose:</li>
<ul><li>
The chip contains packet trace interface for debugging network protocols.  This property controls messages that
              get logged by this interface.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PTI_LOG_EN</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="1">PWR_STATE_EN</td>
<td colspan="1">RX_EN</td>
<td colspan="1">TX_EN</td>
<td colspan="1">CMD_EN</td>
<td colspan="1">CAL_MAN_EN</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PTI%3APTI_LOG_EN">PTI_LOG_EN</a><ul>
<li><a name="field-PTI_LOG_EN%3APWR_STATE_EN">PWR_STATE_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Controls logging of radio power state transitions to the packet trace interface.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Enable Logging to the packet trace interface.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Disable Logging to the packet trace interface.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PTI_LOG_EN%3ARX_EN">RX_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Controls logging of data packets received over the air.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Enable Logging to the packet trace interface.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Disable Logging to the packet trace interface.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PTI_LOG_EN%3ATX_EN">TX_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Controls logging of data packets sent over the air.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Enable Logging to the packet trace interface.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Disable Logging to the packet trace interface.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PTI_LOG_EN%3ACMD_EN">CMD_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Controls logging of SPI commands processed to the packet trace interface.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Enable Logging to the packet trace interface.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Disable Logging to the packet trace interface.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PTI_LOG_EN%3ACAL_MAN_EN">CAL_MAN_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Controls logging of runtime calibration to the packet trace interface.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Enable Logging to the packet trace interface.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Disable Logging to the packet trace interface.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-PTI_LOG_EN_2">PTI_LOG_EN_2</a></h4>
<ul>
<li>Group: 0xf0</li>
<li>Index: 0x04</li>
<li>Summary: Enables what the PTI logs.</li>
<li>Purpose:</li>
<ul><li>
The chip contains packet trace interface for debugging network protocols.  This property controls messages that
              get logged by this interface.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">PTI_LOG_EN_2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x04</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="1">CCA_EN</td>
<td colspan="1">MODE_PHASE_EN</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x04</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-PTI%3APTI_LOG_EN_2">PTI_LOG_EN_2</a><ul>
<li><a name="field-PTI_LOG_EN_2%3ACCA_EN">CCA_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Controls logging of csma/lbt operations to the packet trace interface.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Enable Logging to the packet trace interface.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Disable Logging to the packet trace interface.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-PTI_LOG_EN_2%3AMODE_PHASE_EN">MODE_PHASE_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Controls logging of mode phase transitions to the packet trace interface.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENABLE</td><td>1</td><td align="left">
<ul><li>
Enable Logging to the packet trace interface.</li></ul>
</td></tr>
<tr valign="top"><td align="left">DISABLE</td><td>0</td><td align="left">
<ul><li>
Disable Logging to the packet trace interface.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h3><a name="pgrp-OTP_VARS">OTP_VARS</a></h3>
<h4><a name="prop-OTP_VARS_SPI_ACTIVE_SEQ_DELAY">OTP_VARS_SPI_ACTIVE_SEQ_DELAY</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x00 ... 0x01</li>
<li>Summary: Sequencer delay from SPI active to ready.</li>
<li>Purpose:</li>
<li>Defaults: 0x01, 0xf4</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_SPI_ACTIVE_SEQ_DELAY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="8">SPI_ACTIVE_SEQ_DELAY[15:8]</td>
</tr>
<tr><td>0x01</td>
<td colspan="8">SPI_ACTIVE_SEQ_DELAY[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x00</td>
<td colspan="8">0x1</td>
</tr>
<tr><td>0x01</td>
<td colspan="8">0xf4</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_SPI_ACTIVE_SEQ_DELAY">OTP_VARS_SPI_ACTIVE_SEQ_DELAY</a><ul>
<li><a name="field-OTP_VARS_SPI_ACTIVE_SEQ_DELAY%3ASPI_ACTIVE_SEQ_DELAY">SPI_ACTIVE_SEQ_DELAY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
spi_active_seq_delay</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_TX_TUNE_SEQ_DELAY">OTP_VARS_TX_TUNE_SEQ_DELAY</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x02</li>
<li>Summary: Sequencer delay from TX tune to TX.</li>
<li>Purpose:</li>
<li>Defaults: 0x4b</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_TX_TUNE_SEQ_DELAY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="8">TX_TUNE_SEQ_DELAY</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x02</td>
<td colspan="8">0x4b</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_TX_TUNE_SEQ_DELAY">OTP_VARS_TX_TUNE_SEQ_DELAY</a><ul>
<li><a name="field-OTP_VARS_TX_TUNE_SEQ_DELAY%3ATX_TUNE_SEQ_DELAY">TX_TUNE_SEQ_DELAY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
tx_tune_seq_delay</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_READY_SEQ_DELAY">OTP_VARS_READY_SEQ_DELAY</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x03</li>
<li>Summary: Sequencer delay from ready to TX.</li>
<li>Purpose:</li>
<li>Defaults: 0x96</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_READY_SEQ_DELAY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="8">READY_SEQ_DELAY</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x03</td>
<td colspan="8">0x96</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_READY_SEQ_DELAY">OTP_VARS_READY_SEQ_DELAY</a><ul>
<li><a name="field-OTP_VARS_READY_SEQ_DELAY%3AREADY_SEQ_DELAY">READY_SEQ_DELAY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
ready_seq_delay</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_RX_SEQ_DELAY">OTP_VARS_RX_SEQ_DELAY</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x04 ... 0x05</li>
<li>Summary: Sequencer delay from rx to tx.</li>
<li>Purpose:</li>
<li>Defaults: 0x00, 0x96</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_RX_SEQ_DELAY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="8">RX_SEQ_DELAY[15:8]</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">RX_SEQ_DELAY[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x04</td>
<td colspan="8">0x0</td>
</tr>
<tr><td>0x05</td>
<td colspan="8">0x96</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_RX_SEQ_DELAY">OTP_VARS_RX_SEQ_DELAY</a><ul>
<li><a name="field-OTP_VARS_RX_SEQ_DELAY%3ARX_SEQ_DELAY">RX_SEQ_DELAY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rx_seq_delay</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_CAL_ENABLE_VTR">OTP_VARS_CAL_ENABLE_VTR</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x06</li>
<li>Summary: VTR calibration enables.</li>
<li>Purpose:</li>
<li>Defaults: 0x61</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_CAL_ENABLE_VTR</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="1">CAL_EN_VTR_VCO_LADR</td>
<td colspan="1">CAL_EN_VTR_VCO_V1P5</td>
<td colspan="1">CAL_EN_VTR_VCO_V3P3</td>
<td colspan="1">CAL_EN_VTR_SY</td>
<td colspan="1">CAL_EN_VTR_ADC</td>
<td colspan="1">CAL_EN_VTR_TX</td>
<td colspan="1">CAL_EN_VTR_RX</td>
<td colspan="1">CAL_EN_VTR_XO</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x06</td>
<td colspan="1">0x0</td>
<td colspan="1">0x1</td>
<td colspan="1">0x1</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_CAL_ENABLE_VTR">OTP_VARS_CAL_ENABLE_VTR</a><ul>
<li><a name="field-OTP_VARS_CAL_ENABLE_VTR%3ACAL_EN_VTR_VCO_LADR">CAL_EN_VTR_VCO_LADR</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Perform VTR VCO ladr calibration on every warm boot.  Always performed at cold boot.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_CAL_ENABLE_VTR%3ACAL_EN_VTR_VCO_V1P5">CAL_EN_VTR_VCO_V1P5</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Perform VTR VCO v1p5 calibration on every warm boot.  Always performed at cold boot.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_CAL_ENABLE_VTR%3ACAL_EN_VTR_VCO_V3P3">CAL_EN_VTR_VCO_V3P3</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Perform VTR VCO v3p3 calibration on every warm boot.  Always performed at cold boot.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_CAL_ENABLE_VTR%3ACAL_EN_VTR_SY">CAL_EN_VTR_SY</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Perform VTR SY calibration on every warm boot.  Always performed at cold boot.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_CAL_ENABLE_VTR%3ACAL_EN_VTR_ADC">CAL_EN_VTR_ADC</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Perform VTR ADC calibration on every warm boot.  Always performed at cold boot.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_CAL_ENABLE_VTR%3ACAL_EN_VTR_TX">CAL_EN_VTR_TX</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Perform VTR TX calibration on every warm boot.  Always performed at cold boot.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_CAL_ENABLE_VTR%3ACAL_EN_VTR_RX">CAL_EN_VTR_RX</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Perform VTR RX calibration on every warm boot.  Always performed at cold boot.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_CAL_ENABLE_VTR%3ACAL_EN_VTR_XO">CAL_EN_VTR_XO</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Perform VTR XO calibration on every warm boot.  Always performed at cold boot.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_CAL_ENABLE">OTP_VARS_CAL_ENABLE</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x07</li>
<li>Summary: Calibration enables.</li>
<li>Purpose:</li>
<li>Defaults: 0x45</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_CAL_ENABLE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x07</td>
<td colspan="1">CAL_EN_VTR_VCO_V1P5</td>
<td colspan="1">CAL_EN_RFPKD_RECAL_ON_WARM</td>
<td colspan="1">CAL_EN_RFPKD_RECAL_ON_RX</td>
<td colspan="1">CAL_EN_RFPKD_FULL</td>
<td colspan="1">CAL_EN_RC_CAL_FOR_ADC</td>
<td colspan="1">CAL_EN_PGA_OFS</td>
<td colspan="1">CAL_EN_RC_CAL_32K</td>
<td colspan="1">CAL_EN_BOOT_OSC</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x07</td>
<td colspan="1">0x0</td>
<td colspan="1">0x1</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td colspan="1">0x1</td>
<td colspan="1">0x0</td>
<td colspan="1">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_CAL_ENABLE">OTP_VARS_CAL_ENABLE</a><ul>
<li><a name="field-OTP_VARS_CAL_ENABLE%3ACAL_EN_VTR_VCO_V1P5">CAL_EN_VTR_VCO_V1P5</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Perform VCO v1p5 calibration on every warm boot.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_CAL_ENABLE%3ACAL_EN_RFPKD_RECAL_ON_WARM">CAL_EN_RFPKD_RECAL_ON_WARM</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Perform RF peak detector calibration on every warm boot.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_CAL_ENABLE%3ACAL_EN_RFPKD_RECAL_ON_RX">CAL_EN_RFPKD_RECAL_ON_RX</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Perform fast RF peak detector calibration on every entry into RX.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_CAL_ENABLE%3ACAL_EN_RFPKD_FULL">CAL_EN_RFPKD_FULL</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Perform full RF peak detector calibration on every warm boot.  Full Always performed at cold boot.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_CAL_ENABLE%3ACAL_EN_RC_CAL_FOR_ADC">CAL_EN_RC_CAL_FOR_ADC</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Perform rc32k calibration for adc on every warm boot.  Always performed at cold boot.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_CAL_ENABLE%3ACAL_EN_PGA_OFS">CAL_EN_PGA_OFS</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Perform pga ofs calibration on every entry into RX.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_CAL_ENABLE%3ACAL_EN_RC_CAL_32K">CAL_EN_RC_CAL_32K</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Perform rc32k calibration on every warm boot.  Always performed at cold boot and on CAL timer expiration.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_CAL_ENABLE%3ACAL_EN_BOOT_OSC">CAL_EN_BOOT_OSC</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ENUM_0</td><td>1</td><td align="left">
<ul><li>
Perform boot osc calibration on every warm boot.  Always performed at cold boot.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_VTR_VCO_V3P3_TARGET_VOLTAGE">OTP_VARS_VTR_VCO_V3P3_TARGET_VOLTAGE</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x08</li>
<li>Summary: VCO v3.3 target voltage.</li>
<li>Purpose:</li>
<li>Defaults: 0xfb</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_VTR_VCO_V3P3_TARGET_VOLTAGE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x08</td>
<td colspan="8">VTR_VCO_V3P3_TARGET_VOLTAGE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x08</td>
<td colspan="8">0xfb</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_VTR_VCO_V3P3_TARGET_VOLTAGE">OTP_VARS_VTR_VCO_V3P3_TARGET_VOLTAGE</a><ul>
<li><a name="field-OTP_VARS_VTR_VCO_V3P3_TARGET_VOLTAGE%3AVTR_VCO_V3P3_TARGET_VOLTAGE">VTR_VCO_V3P3_TARGET_VOLTAGE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
vtr_vco_v3p3_target_voltage</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_VTR_VCO_V1P5_TARGET_VOLTAGE">OTP_VARS_VTR_VCO_V1P5_TARGET_VOLTAGE</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x09</li>
<li>Summary: VCO v1.5 target voltage.</li>
<li>Purpose:</li>
<li>Defaults: 0x08</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_VTR_VCO_V1P5_TARGET_VOLTAGE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x09</td>
<td colspan="8">VTR_VCO_V1P5_TARGET_VOLTAGE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x09</td>
<td colspan="8">0x8</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_VTR_VCO_V1P5_TARGET_VOLTAGE">OTP_VARS_VTR_VCO_V1P5_TARGET_VOLTAGE</a><ul>
<li><a name="field-OTP_VARS_VTR_VCO_V1P5_TARGET_VOLTAGE%3AVTR_VCO_V1P5_TARGET_VOLTAGE">VTR_VCO_V1P5_TARGET_VOLTAGE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
vtr_vco_v1p5_target_voltage</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_VTR_VCO_LADR_TARGET_VOLTAGE">OTP_VARS_VTR_VCO_LADR_TARGET_VOLTAGE</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x0a</li>
<li>Summary: VCO Ladder target voltage.</li>
<li>Purpose:</li>
<li>Defaults: 0x01</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_VTR_VCO_LADR_TARGET_VOLTAGE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0a</td>
<td colspan="8">VTR_VCO_LADR_TARGET_VOLTAGE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0a</td>
<td colspan="8">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_VTR_VCO_LADR_TARGET_VOLTAGE">OTP_VARS_VTR_VCO_LADR_TARGET_VOLTAGE</a><ul>
<li><a name="field-OTP_VARS_VTR_VCO_LADR_TARGET_VOLTAGE%3AVTR_VCO_LADR_TARGET_VOLTAGE">VTR_VCO_LADR_TARGET_VOLTAGE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
vtr_vco_ladr_target_voltage</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_RC_CAL_ADC_TARGET">OTP_VARS_RC_CAL_ADC_TARGET</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x0b ... 0x0c</li>
<li>Summary: RC32K ADC calibration target.</li>
<li>Purpose:</li>
<ul><li>
RC calibration ADC Target in Hz.</li></ul>
<li>Defaults: 0x7d, 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_RC_CAL_ADC_TARGET</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0b</td>
<td colspan="8">RC_CAL_ADC_TARGET[15:8]</td>
</tr>
<tr><td>0x0c</td>
<td colspan="8">RC_CAL_ADC_TARGET[7:0]</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0b</td>
<td colspan="8">0x7d</td>
</tr>
<tr><td>0x0c</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_RC_CAL_ADC_TARGET">OTP_VARS_RC_CAL_ADC_TARGET</a><ul>
<li><a name="field-OTP_VARS_RC_CAL_ADC_TARGET%3ARC_CAL_ADC_TARGET">RC_CAL_ADC_TARGET</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rc_cal_adc_target</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xffff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_RC_CAL">OTP_VARS_RC_CAL</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x0d</li>
<li>Summary: RC32k calibration parameters.</li>
<li>Purpose:</li>
<ul><li>
TODO: DESCRIPTION?????</li></ul>
<li>Defaults: 0x04</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_RC_CAL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0d</td>
<td colspan="8">FINE_CAL_CYCLES</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0d</td>
<td colspan="8">0x4</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_RC_CAL">OTP_VARS_RC_CAL</a><ul>
<li><a name="field-OTP_VARS_RC_CAL%3AFINE_CAL_CYCLES">FINE_CAL_CYCLES</a>
<dl><dt>Description:</dt><dd>
<ul><li>
rc_cal</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_RC_CAL1">OTP_VARS_RC_CAL1</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x0e</li>
<li>Summary: RC32k calibration parameters.</li>
<li>Purpose:</li>
<li>Defaults: 0x44</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_RC_CAL1</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0e</td>
<td colspan="4">COARSE_ADC_CAL_CYCLES</td>
<td colspan="4">COARSE_CAL_CYCLES</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0e</td>
<td colspan="4">0x4</td>
<td colspan="4">0x4</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_RC_CAL1">OTP_VARS_RC_CAL1</a><ul>
<li><a name="field-OTP_VARS_RC_CAL1%3ACOARSE_ADC_CAL_CYCLES">COARSE_ADC_CAL_CYCLES</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Number of RC32k cycles to measure RC32k frequency over for ADC calibration. (nc)</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-OTP_VARS_RC_CAL1%3ACOARSE_CAL_CYCLES">COARSE_CAL_CYCLES</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Number of RC32k cycles to measure RC frequency over. (nc)</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_RC_CAL2">OTP_VARS_RC_CAL2</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x0f</li>
<li>Summary: RC32k calibration parameters.</li>
<li>Purpose:</li>
<li>Defaults: 0x42</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_RC_CAL2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x0f</td>
<td colspan="2">HIGH_CURR_CHOP</td>
<td colspan="6">SETTLE_CYCLES</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x0f</td>
<td colspan="2">0x1</td>
<td colspan="6">0x2</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_RC_CAL2">OTP_VARS_RC_CAL2</a><ul>
<li><a name="field-OTP_VARS_RC_CAL2%3AHIGH_CURR_CHOP">HIGH_CURR_CHOP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Controls chop and high current mode operation. (h)</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">CHOP_DIS_HI_DIS</td><td>0</td><td align="left">
<ul><li>
Chop disabled, High current mode disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CHOP_EN_HI_DIS</td><td>1</td><td align="left">
<ul><li>
Chop enabled, High current mode disabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CHOP_DIS_HI_EN</td><td>2</td><td align="left">
<ul><li>
Chop disabled, High current mode enabled.</li></ul>
</td></tr>
<tr valign="top"><td align="left">CHOP_EN_HI_EN</td><td>3</td><td align="left">
<ul><li>
Chop enabled, High current mode enabled.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_RC_CAL2%3ASETTLE_CYCLES">SETTLE_CYCLES</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Number of RC32k cycles to wait for clock to settle after changing frequency and before checking frequency. (ns)</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_BOOT_OSC_CAL">OTP_VARS_BOOT_OSC_CAL</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x10</li>
<li>Summary: Boot osc calibration parameters.</li>
<li>Purpose:</li>
<li>Defaults: 0x09</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_BOOT_OSC_CAL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x10</td>
<td colspan="5">XO_CAPCODE_RESTORE_DELAY</td>
<td colspan="3">BOOT_OSC_ADJ</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x10</td>
<td colspan="5">0x1</td>
<td colspan="3">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_BOOT_OSC_CAL">OTP_VARS_BOOT_OSC_CAL</a><ul>
<li><a name="field-OTP_VARS_BOOT_OSC_CAL%3AXO_CAPCODE_RESTORE_DELAY">XO_CAPCODE_RESTORE_DELAY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Delay before restoring XO_CAPCODE.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-OTP_VARS_BOOT_OSC_CAL%3ABOOT_OSC_ADJ">BOOT_OSC_ADJ</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Adjustment value for Boot osc.  This value is subtracted from BOSC aconfig register after boot osc calibration.  There is an additional adjustment factor applied based on crystal frequency.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_BOOT_OSC_CAL1">OTP_VARS_BOOT_OSC_CAL1</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x11</li>
<li>Summary: Boot osc calibration parameters.</li>
<li>Purpose:</li>
<li>Defaults: 0x02</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_BOOT_OSC_CAL1</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x11</td>
<td colspan="8">CRYSTAL_OK_DELAY</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x11</td>
<td colspan="8">0x2</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_BOOT_OSC_CAL1">OTP_VARS_BOOT_OSC_CAL1</a><ul>
<li><a name="field-OTP_VARS_BOOT_OSC_CAL1%3ACRYSTAL_OK_DELAY">CRYSTAL_OK_DELAY</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Delay after restoring capcode, before polling crystal ok.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_AUXADC_TEMP_SLOPE">OTP_VARS_AUXADC_TEMP_SLOPE</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x12</li>
<li>Summary: </li>
<li>Purpose:</li>
<li>Defaults: 0x63</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_AUXADC_TEMP_SLOPE</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x12</td>
<td colspan="8">AUXADC_TEMP_SLOPE</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x12</td>
<td colspan="8">0x63</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_AUXADC_TEMP_SLOPE">OTP_VARS_AUXADC_TEMP_SLOPE</a><ul>
<li><a name="field-OTP_VARS_AUXADC_TEMP_SLOPE%3AAUXADC_TEMP_SLOPE">AUXADC_TEMP_SLOPE</a>
<dl><dt>Description:</dt><dd>
<ul><li>
auxadc_temp_slope</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_AUXADC_TEMP_INTERCEPT">OTP_VARS_AUXADC_TEMP_INTERCEPT</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x13</li>
<li>Summary: </li>
<li>Purpose:</li>
<li>Defaults: 0x4a</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_AUXADC_TEMP_INTERCEPT</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x13</td>
<td colspan="8">AUXADC_TEMP_INTERCEPT</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x13</td>
<td colspan="8">0x4a</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_AUXADC_TEMP_INTERCEPT">OTP_VARS_AUXADC_TEMP_INTERCEPT</a><ul>
<li><a name="field-OTP_VARS_AUXADC_TEMP_INTERCEPT%3AAUXADC_TEMP_INTERCEPT">AUXADC_TEMP_INTERCEPT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
auxadc_temp_intercept</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_AUXADC_SY_GAIN_ERROR">OTP_VARS_AUXADC_SY_GAIN_ERROR</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x14</li>
<li>Summary: AuxADC gain adjustment, 8-bit signed.</li>
<li>Purpose:</li>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_AUXADC_SY_GAIN_ERROR</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x14</td>
<td colspan="8">AUXADC_SY_GAIN_ERROR</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x14</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_AUXADC_SY_GAIN_ERROR">OTP_VARS_AUXADC_SY_GAIN_ERROR</a><ul>
<li><a name="field-OTP_VARS_AUXADC_SY_GAIN_ERROR%3AAUXADC_SY_GAIN_ERROR">AUXADC_SY_GAIN_ERROR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
auxadc_sy_gain_error</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_AUXADC_SY_OFFSET_ERROR">OTP_VARS_AUXADC_SY_OFFSET_ERROR</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x15</li>
<li>Summary: AuxADC offset adjustment, 8-bit signed.</li>
<li>Purpose:</li>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_AUXADC_SY_OFFSET_ERROR</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x15</td>
<td colspan="8">AUXADC_SY_OFFSET_ERROR</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x15</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_AUXADC_SY_OFFSET_ERROR">OTP_VARS_AUXADC_SY_OFFSET_ERROR</a><ul>
<li><a name="field-OTP_VARS_AUXADC_SY_OFFSET_ERROR%3AAUXADC_SY_OFFSET_ERROR">AUXADC_SY_OFFSET_ERROR</a>
<dl><dt>Description:</dt><dd>
<ul><li>
auxadc_sy_offset_error</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_ADC_VOLTAGE_TRIM">OTP_VARS_ADC_VOLTAGE_TRIM</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x16</li>
<li>Summary: </li>
<li>Purpose:</li>
<li>Defaults: 0x0f</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_ADC_VOLTAGE_TRIM</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x16</td>
<td colspan="8">ADC_VOLTAGE_TRIM</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x16</td>
<td colspan="8">0xf</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_ADC_VOLTAGE_TRIM">OTP_VARS_ADC_VOLTAGE_TRIM</a><ul>
<li><a name="field-OTP_VARS_ADC_VOLTAGE_TRIM%3AADC_VOLTAGE_TRIM">ADC_VOLTAGE_TRIM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
adc_voltage_trim</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_VCO_LOAD5_XO">OTP_VARS_VCO_LOAD5_XO</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x17</li>
<li>Summary: </li>
<li>Purpose:</li>
<li>Defaults: 0x04</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_VCO_LOAD5_XO</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x17</td>
<td colspan="4">XO_VPK_LP</td>
<td colspan="2">VCO_LOAD5_HPF</td>
<td colspan="2">VCO_LOAD5_LPF</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x17</td>
<td colspan="4">0x0</td>
<td colspan="2">0x1</td>
<td colspan="2">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_VCO_LOAD5_XO">OTP_VARS_VCO_LOAD5_XO</a><ul>
<li><a name="field-OTP_VARS_VCO_LOAD5_XO%3AXO_VPK_LP">XO_VPK_LP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
xo_vpk low power setting.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x3</dd></dl>
</li>
<li><a name="field-OTP_VARS_VCO_LOAD5_XO%3AVCO_LOAD5_HPF">VCO_LOAD5_HPF</a>
<dl><dt>Description:</dt><dd>
<ul><li>
pro2_sy_vco.r_Iref_tune high performance setting.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x3</dd></dl>
</li>
<li><a name="field-OTP_VARS_VCO_LOAD5_XO%3AVCO_LOAD5_LPF">VCO_LOAD5_LPF</a>
<dl><dt>Description:</dt><dd>
<ul><li>
pro2_sy_vco.r_Iref_tune low power setting.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x3</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_REG_RXFE_LPF">OTP_VARS_REG_RXFE_LPF</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x18</li>
<li>Summary: </li>
<li>Purpose:</li>
<li>Defaults: 0x35</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_REG_RXFE_LPF</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x18</td>
<td colspan="8">REG_RXFE_LPF</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x18</td>
<td colspan="8">0x35</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_REG_RXFE_LPF">OTP_VARS_REG_RXFE_LPF</a><ul>
<li><a name="field-OTP_VARS_REG_RXFE_LPF%3AREG_RXFE_LPF">REG_RXFE_LPF</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reg_rxfe_lpf</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_REG_ADC_LPF">OTP_VARS_REG_ADC_LPF</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x19</li>
<li>Summary: </li>
<li>Purpose:</li>
<li>Defaults: 0x40</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_REG_ADC_LPF</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x19</td>
<td colspan="8">REG_ADC_LPF</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x19</td>
<td colspan="8">0x40</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_REG_ADC_LPF">OTP_VARS_REG_ADC_LPF</a><ul>
<li><a name="field-OTP_VARS_REG_ADC_LPF%3AREG_ADC_LPF">REG_ADC_LPF</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reg_adc_lpf</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_REG_CLKGEN_COM_LPF">OTP_VARS_REG_CLKGEN_COM_LPF</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x1a</li>
<li>Summary: CLKGEN ACONFIG register value.</li>
<li>Purpose:</li>
<ul><li>
This is the value that will be used for the CLKGEN ACONFIG register for RX if in LPF and <a href="#field-MODEM_CLKGEN_BAND%3ABAND">MODEM_CLKGEN_BAND:BAND</a>
 less than FVCO/16.</li></ul>
<li>Defaults: 0x10</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_REG_CLKGEN_COM_LPF</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1a</td>
<td colspan="8">REG_CLKGEN_COM_LPF</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1a</td>
<td colspan="8">0x10</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_REG_CLKGEN_COM_LPF">OTP_VARS_REG_CLKGEN_COM_LPF</a><ul>
<li><a name="field-OTP_VARS_REG_CLKGEN_COM_LPF%3AREG_CLKGEN_COM_LPF">REG_CLKGEN_COM_LPF</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reg_clkgen_com_lpf</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_REG_FBDIV_LPF">OTP_VARS_REG_FBDIV_LPF</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x1b</li>
<li>Summary: Low power mode feedback divider regulator settings.</li>
<li>Purpose:</li>
<li>Defaults: 0x01</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_REG_FBDIV_LPF</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1b</td>
<td colspan="4">REG_FBDIV_COM_LPF</td>
<td colspan="4">REG_FBDIV_TX_LPF</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1b</td>
<td colspan="4">0x0</td>
<td colspan="4">0x1</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_REG_FBDIV_LPF">OTP_VARS_REG_FBDIV_LPF</a><ul>
<li><a name="field-OTP_VARS_REG_FBDIV_LPF%3AREG_FBDIV_COM_LPF">REG_FBDIV_COM_LPF</a>
<dl><dt>Description:</dt><dd>
<ul><li>
fbdiv setting when in low power mode and not in TX state.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
<li><a name="field-OTP_VARS_REG_FBDIV_LPF%3AREG_FBDIV_TX_LPF">REG_FBDIV_TX_LPF</a>
<dl><dt>Description:</dt><dd>
<ul><li>
fbdiv setting when in low power mode and TX state.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_REG_CLKGEN_TX_LPF">OTP_VARS_REG_CLKGEN_TX_LPF</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x1c</li>
<li>Summary: CLKGEN ACONFIG register value.</li>
<li>Purpose:</li>
<ul><li>
This is the value that will be used for the CLKGEN ACONFIG register for TX if in LPF and <a href="#field-MODEM_CLKGEN_BAND%3ABAND">MODEM_CLKGEN_BAND:BAND</a>
 less than FVCO/16.</li></ul>
<li>Defaults: 0x10</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_REG_CLKGEN_TX_LPF</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1c</td>
<td colspan="8">REG_CLKGEN_TX_LPF</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1c</td>
<td colspan="8">0x10</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_REG_CLKGEN_TX_LPF">OTP_VARS_REG_CLKGEN_TX_LPF</a><ul>
<li><a name="field-OTP_VARS_REG_CLKGEN_TX_LPF%3AREG_CLKGEN_TX_LPF">REG_CLKGEN_TX_LPF</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reg_clkgen_tx_lpf</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_REG_CLKGEN_COM_LOW_BAND">OTP_VARS_REG_CLKGEN_COM_LOW_BAND</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x1d</li>
<li>Summary: CLKGEN ACONFIG register value.</li>
<li>Purpose:</li>
<ul><li>
This is the value that will be used for the CLKGEN ACONFIG register for RX and TX if <a href="#field-MODEM_CLKGEN_BAND%3ABAND">MODEM_CLKGEN_BAND:BAND</a>
 >= FVCO/16 regardless of LPF/HPF.</li></ul>
<li>Defaults: 0x10</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_REG_CLKGEN_COM_LOW_BAND</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1d</td>
<td colspan="8">REG_CLKGEN_COM_LOW_BAND</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1d</td>
<td colspan="8">0x10</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_REG_CLKGEN_COM_LOW_BAND">OTP_VARS_REG_CLKGEN_COM_LOW_BAND</a><ul>
<li><a name="field-OTP_VARS_REG_CLKGEN_COM_LOW_BAND%3AREG_CLKGEN_COM_LOW_BAND">REG_CLKGEN_COM_LOW_BAND</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reg_clkgen_com_low_band</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_REG_RXFE_HPF">OTP_VARS_REG_RXFE_HPF</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x1e</li>
<li>Summary: </li>
<li>Purpose:</li>
<li>Defaults: 0x40</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_REG_RXFE_HPF</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1e</td>
<td colspan="8">REG_RXFE_HPF</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1e</td>
<td colspan="8">0x40</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_REG_RXFE_HPF">OTP_VARS_REG_RXFE_HPF</a><ul>
<li><a name="field-OTP_VARS_REG_RXFE_HPF%3AREG_RXFE_HPF">REG_RXFE_HPF</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reg_rxfe_hpf</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_REG_ADC_HPF">OTP_VARS_REG_ADC_HPF</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x1f</li>
<li>Summary: </li>
<li>Purpose:</li>
<li>Defaults: 0x40</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_REG_ADC_HPF</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x1f</td>
<td colspan="8">REG_ADC_HPF</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x1f</td>
<td colspan="8">0x40</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_REG_ADC_HPF">OTP_VARS_REG_ADC_HPF</a><ul>
<li><a name="field-OTP_VARS_REG_ADC_HPF%3AREG_ADC_HPF">REG_ADC_HPF</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reg_adc_hpf</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_REG_CLKGEN_COM_HPF">OTP_VARS_REG_CLKGEN_COM_HPF</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x20</li>
<li>Summary: CLKGEN ACONFIG register value.</li>
<li>Purpose:</li>
<ul><li>
This is the value that will be used for the CLKGEN ACONFIG register for RX if in HPF and <a href="#field-MODEM_CLKGEN_BAND%3ABAND">MODEM_CLKGEN_BAND:BAND</a>
 less than FVCO/16.</li></ul>
<li>Defaults: 0x30</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_REG_CLKGEN_COM_HPF</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x20</td>
<td colspan="8">REG_CLKGEN_COM_HPF</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x20</td>
<td colspan="8">0x30</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_REG_CLKGEN_COM_HPF">OTP_VARS_REG_CLKGEN_COM_HPF</a><ul>
<li><a name="field-OTP_VARS_REG_CLKGEN_COM_HPF%3AREG_CLKGEN_COM_HPF">REG_CLKGEN_COM_HPF</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reg_clkgen_com_hpf</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_REG_FBDIV_HPF">OTP_VARS_REG_FBDIV_HPF</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x21</li>
<li>Summary: </li>
<li>Purpose:</li>
<li>Defaults: 0x04</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_REG_FBDIV_HPF</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x21</td>
<td colspan="4">REG_FBDIV_COM_HPF</td>
<td colspan="4">REG_FBDIV_TX_HPF</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x21</td>
<td colspan="4">0x0</td>
<td colspan="4">0x4</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_REG_FBDIV_HPF">OTP_VARS_REG_FBDIV_HPF</a><ul>
<li><a name="field-OTP_VARS_REG_FBDIV_HPF%3AREG_FBDIV_COM_HPF">REG_FBDIV_COM_HPF</a>
<dl><dt>Description:</dt><dd>
<ul><li>
fbdiv setting when in high performance and not in TX state.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
<li><a name="field-OTP_VARS_REG_FBDIV_HPF%3AREG_FBDIV_TX_HPF">REG_FBDIV_TX_HPF</a>
<dl><dt>Description:</dt><dd>
<ul><li>
fbdiv setting when in high performance and in TX state.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_REG_CLKGEN_TX_HPF">OTP_VARS_REG_CLKGEN_TX_HPF</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x22</li>
<li>Summary: CLKGEN ACONFIG register value.</li>
<li>Purpose:</li>
<ul><li>
This is the value that will be used for the CLKGEN ACONFIG register for TX if in HPF and <a href="#field-MODEM_CLKGEN_BAND%3ABAND">MODEM_CLKGEN_BAND:BAND</a>
 less than FVCO/16.</li></ul>
<li>Defaults: 0x20</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_REG_CLKGEN_TX_HPF</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x22</td>
<td colspan="8">REG_CLKGEN_TX_HPF</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x22</td>
<td colspan="8">0x20</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_REG_CLKGEN_TX_HPF">OTP_VARS_REG_CLKGEN_TX_HPF</a><ul>
<li><a name="field-OTP_VARS_REG_CLKGEN_TX_HPF%3AREG_CLKGEN_TX_HPF">REG_CLKGEN_TX_HPF</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reg_clkgen_tx_hpf</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_ETSI_CFG0">OTP_VARS_ETSI_CFG0</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x23</li>
<li>Summary: ETSI configuration register.</li>
<li>Purpose:</li>
<ul><li>
Controls for ETSI mode configuration.</li></ul>
<li>Defaults: 0x09</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_ETSI_CFG0</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x23</td>
<td colspan="1">HVCM_EN</td>
<td>0</td>
<td colspan="6">RFPKD_TH_ETSI_169</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x23</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td colspan="6">0x9</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_ETSI_CFG0">OTP_VARS_ETSI_CFG0</a><ul>
<li><a name="field-OTP_VARS_ETSI_CFG0%3AHVCM_EN">HVCM_EN</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects high or low vcm for ETSI 169 mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
<li><a name="field-OTP_VARS_ETSI_CFG0%3ARFPKD_TH_ETSI_169">RFPKD_TH_ETSI_169</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value for rfpkd thresholds thL and thH when in ETSI 169 mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_ETSI_CFG1">OTP_VARS_ETSI_CFG1</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x24</li>
<li>Summary: ETSI configuration register.</li>
<li>Purpose:</li>
<ul><li>
Controls for ETSI mode configuration.</li></ul>
<li>Defaults: 0x40</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_ETSI_CFG1</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x24</td>
<td colspan="4">REG_FBDIV_COM</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x24</td>
<td colspan="4">0x4</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_ETSI_CFG1">OTP_VARS_ETSI_CFG1</a><ul>
<li><a name="field-OTP_VARS_ETSI_CFG1%3AREG_FBDIV_COM">REG_FBDIV_COM</a>
<dl><dt>Description:</dt><dd>
<ul><li>
fbdiv setting when in high performance, not in TX state, and in etsi 868 mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x10</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_ETSI_CFG2">OTP_VARS_ETSI_CFG2</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x25</li>
<li>Summary: ETSI configuration register.</li>
<li>Purpose:</li>
<ul><li>
Controls for ETSI mode configuration.</li></ul>
<li>Defaults: 0x3c</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_ETSI_CFG2</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x25</td>
<td>0</td>
<td>0</td>
<td colspan="6">RFPKD_TH</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x25</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="6">0x3c</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_ETSI_CFG2">OTP_VARS_ETSI_CFG2</a><ul>
<li><a name="field-OTP_VARS_ETSI_CFG2%3ARFPKD_TH">RFPKD_TH</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Value for rfpkd thresholds thL and thH when not in ETSI 169 mode.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_PH_WATERMARK">OTP_VARS_PH_WATERMARK</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x26</li>
<li>Summary: </li>
<li>Purpose:</li>
<li>Defaults: 0x42</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_PH_WATERMARK</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x26</td>
<td colspan="4">RX_WATERMARK</td>
<td colspan="4">TX_WATERMARK</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x26</td>
<td colspan="4">0x4</td>
<td colspan="4">0x2</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_PH_WATERMARK">OTP_VARS_PH_WATERMARK</a><ul>
<li><a name="field-OTP_VARS_PH_WATERMARK%3ARX_WATERMARK">RX_WATERMARK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the high watermark for the packet handler RX fifo.  The internal firmware will get interrupted when this is crossed.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x1</dd></dl>
<dl><dt>Max:</dt><dd>0x8</dd></dl>
</li>
<li><a name="field-OTP_VARS_PH_WATERMARK%3ATX_WATERMARK">TX_WATERMARK</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Selects the low watermark for the packet handler TX fifo.  The internal firmware will get interrupted when this is crossed.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x1</dd></dl>
<dl><dt>Max:</dt><dd>0x8</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_PROC_MON_RCAL">OTP_VARS_PROC_MON_RCAL</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x27</li>
<li>Summary: </li>
<li>Purpose:</li>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_PROC_MON_RCAL</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x27</td>
<td colspan="8">PROC_MON_RCAL</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x27</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_PROC_MON_RCAL">OTP_VARS_PROC_MON_RCAL</a><ul>
<li><a name="field-OTP_VARS_PROC_MON_RCAL%3APROC_MON_RCAL">PROC_MON_RCAL</a>
<dl><dt>Description:</dt><dd>
<ul><li>
proc_mon_rcal</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_REF_CAL_BANDGAP">OTP_VARS_REF_CAL_BANDGAP</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x28</li>
<li>Summary: REF_CAL bandgap calibration.</li>
<li>Purpose:</li>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_REF_CAL_BANDGAP</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x28</td>
<td colspan="8">REF_CAL_BANDGAP</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x28</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_REF_CAL_BANDGAP">OTP_VARS_REF_CAL_BANDGAP</a><ul>
<li><a name="field-OTP_VARS_REF_CAL_BANDGAP%3AREF_CAL_BANDGAP">REF_CAL_BANDGAP</a>
<dl><dt>Description:</dt><dd>
<ul><li>
ref_cal_bandgap</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_VCO_ADJ">OTP_VARS_VCO_ADJ</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x29</li>
<li>Summary: </li>
<li>Purpose:</li>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_VCO_ADJ</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x29</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="4">V1P5_TX_OFFSET</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x29</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="4">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_VCO_ADJ">OTP_VARS_VCO_ADJ</a><ul>
<li><a name="field-OTP_VARS_VCO_ADJ%3AV1P5_TX_OFFSET">V1P5_TX_OFFSET</a>
<dl><dt>Description:</dt><dd>
<ul><li>
This value is added to the calibrated value for the V1P5 regulator while in TX state  if <a href="#field-MODEM_CLKGEN_BAND%3ABAND">MODEM_CLKGEN_BAND:BAND</a>
 == FVCO/4 || <a href="#prop-MODEM_CLKGEN_BAND">MODEM_CLKGEN_BAND</a>
:BAND == FVCO/8.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xf</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_MISC_DELAY">OTP_VARS_MISC_DELAY</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x2a</li>
<li>Summary: Miscellaneous delay values.</li>
<li>Purpose:</li>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_MISC_DELAY</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2a</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="4">DEMOD_RST</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2a</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="4">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_MISC_DELAY">OTP_VARS_MISC_DELAY</a><ul>
<li><a name="field-OTP_VARS_MISC_DELAY%3ADEMOD_RST">DEMOD_RST</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Number of us to delay after turning on the clock to the demod before resetting the demod.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_CAL_MAN">OTP_VARS_CAL_MAN</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x2b</li>
<li>Summary: Controls rssi latching and temperature-based calibration enables (cal_man).</li>
<li>Purpose:</li>
<li>Defaults: 0x02</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_CAL_MAN</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2b</td>
<td colspan="1">CONTROL_LOOP_EN</td>
<td colspan="1">TEMP_SENSOR_OFFSET_EN</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td colspan="3">RSSI_FIRST_LATCH_ADJ</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2b</td>
<td colspan="1">0x0</td>
<td colspan="1">0x0</td>
<td>0x0</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="3">0x2</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_CAL_MAN">OTP_VARS_CAL_MAN</a><ul>
<li><a name="field-OTP_VARS_CAL_MAN%3ACONTROL_LOOP_EN">CONTROL_LOOP_EN</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ASSERT</td><td>1</td><td align="left">
<ul><li>
Enable/disable all automatic recalibrations due to temperature change.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_CAL_MAN%3ATEMP_SENSOR_OFFSET_EN">TEMP_SENSOR_OFFSET_EN</a>
<dl><dt>Type:</dt>
<dd>Enumeration<br />
<table>
<thead><tr><td align="left">Name</td><td>Value</td><td align="left">Description</td></tr></thead>
<tbody>
<tr valign="top"><td align="left">ASSERT</td><td>1</td><td align="left">
<ul><li>
Uses otp_var_auxadc_sy_offset to determine and account for temperature sensor offset in absolute temperature measurement.</li></ul>
</td></tr>
</tbody></table>
</dl>
</li>
<li><a name="field-OTP_VARS_CAL_MAN%3ARSSI_FIRST_LATCH_ADJ">RSSI_FIRST_LATCH_ADJ</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Adjust the Tb to wait before the first RSSI latch.  Max value is 3 for RSSI updated every bit and 6 for RSSI 4 bit averaged.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_REG_CLKGEN_COM_HPF_HOT">OTP_VARS_REG_CLKGEN_COM_HPF_HOT</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x2c</li>
<li>Summary: Under high temperature, CLKGEN ACONFIG register value.</li>
<li>Purpose:</li>
<ul><li>
This value is used for the CLKGEN ACONFIG register for RX if in HPF and <a href="#field-MODEM_CLKGEN_BAND%3ABAND">MODEM_CLKGEN_BAND:BAND</a>
 less than FVCO/16.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_REG_CLKGEN_COM_HPF_HOT</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2c</td>
<td colspan="8">REG_CLKGEN_COM_HPF_HOT</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2c</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_REG_CLKGEN_COM_HPF_HOT">OTP_VARS_REG_CLKGEN_COM_HPF_HOT</a><ul>
<li><a name="field-OTP_VARS_REG_CLKGEN_COM_HPF_HOT%3AREG_CLKGEN_COM_HPF_HOT">REG_CLKGEN_COM_HPF_HOT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reg_clkgen_com_hpf_hot</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_VTR_VCO_V1P5_TARGET_VOLTAGE_HOT">OTP_VARS_VTR_VCO_V1P5_TARGET_VOLTAGE_HOT</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x2d</li>
<li>Summary: Under high temperature, VCO v1.5 target voltage.</li>
<li>Purpose:</li>
<ul><li>
Under high temperature, this value is used in place of vtr_vco_v1p5_target_voltage.</li></ul>
<li>Defaults: 0x08</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_VTR_VCO_V1P5_TARGET_VOLTAGE_HOT</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2d</td>
<td colspan="8">VTR_VCO_V1P5_TARGET_VOLTAGE_HOT</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2d</td>
<td colspan="8">0x8</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_VTR_VCO_V1P5_TARGET_VOLTAGE_HOT">OTP_VARS_VTR_VCO_V1P5_TARGET_VOLTAGE_HOT</a><ul>
<li><a name="field-OTP_VARS_VTR_VCO_V1P5_TARGET_VOLTAGE_HOT%3AVTR_VCO_V1P5_TARGET_VOLTAGE_HOT">VTR_VCO_V1P5_TARGET_VOLTAGE_HOT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
vtr_vco_v1p5_target_voltage_hot</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_REG_FBDIV_COM_HOT">OTP_VARS_REG_FBDIV_COM_HOT</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x2e</li>
<li>Summary: Under high temperature, this value is used in place of reg_fbdiv_com_.</li>
<li>Purpose:</li>
<ul><li>
Under high temperature, this value is used in place of reg_fbdiv_com_xxx.</li></ul>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_REG_FBDIV_COM_HOT</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2e</td>
<td colspan="4">REG_FBDIV_COM_HPF_HOT</td>
<td colspan="4">REG_FBDIV_COM_LPF_HOT</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2e</td>
<td colspan="4">0x0</td>
<td colspan="4">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_REG_FBDIV_COM_HOT">OTP_VARS_REG_FBDIV_COM_HOT</a><ul>
<li><a name="field-OTP_VARS_REG_FBDIV_COM_HOT%3AREG_FBDIV_COM_HPF_HOT">REG_FBDIV_COM_HPF_HOT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reg_fbdiv_com_hpf_hot</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
<li><a name="field-OTP_VARS_REG_FBDIV_COM_HOT%3AREG_FBDIV_COM_LPF_HOT">REG_FBDIV_COM_LPF_HOT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Under high temperature, this value is used in place of reg_fbdiv_com_lpf.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_REG_DIG_LOAD_ACFG_DIGREG_HOT">OTP_VARS_REG_DIG_LOAD_ACFG_DIGREG_HOT</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x2f</li>
<li>Summary: Under high temperature, this value is used in place of reg_dig_load_acfg_digreg aconfig init value.</li>
<li>Purpose:</li>
<li>Defaults: 0x20</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_REG_DIG_LOAD_ACFG_DIGREG_HOT</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x2f</td>
<td colspan="8">REG_DIG_LOAD_ACFG_DIGREG_HOT</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x2f</td>
<td colspan="8">0x20</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_REG_DIG_LOAD_ACFG_DIGREG_HOT">OTP_VARS_REG_DIG_LOAD_ACFG_DIGREG_HOT</a><ul>
<li><a name="field-OTP_VARS_REG_DIG_LOAD_ACFG_DIGREG_HOT%3AREG_DIG_LOAD_ACFG_DIGREG_HOT">REG_DIG_LOAD_ACFG_DIGREG_HOT</a>
<dl><dt>Description:</dt><dd>
<ul><li>
reg_dig_load_acfg_digreg_hot</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_CAL_MAN_ONLINE_TEMP_DELTA">OTP_VARS_CAL_MAN_ONLINE_TEMP_DELTA</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x30</li>
<li>Summary: Sets limit for online recalibration control loop. A value of 6 equates to 19.16 degrees Celsius.</li>
<li>Purpose:</li>
<li>Defaults: 0x06</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_CAL_MAN_ONLINE_TEMP_DELTA</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x30</td>
<td colspan="8">CAL_MAN_ONLINE_TEMP_DELTA</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x30</td>
<td colspan="8">0x6</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_CAL_MAN_ONLINE_TEMP_DELTA">OTP_VARS_CAL_MAN_ONLINE_TEMP_DELTA</a><ul>
<li><a name="field-OTP_VARS_CAL_MAN_ONLINE_TEMP_DELTA%3ACAL_MAN_ONLINE_TEMP_DELTA">CAL_MAN_ONLINE_TEMP_DELTA</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Temperature sensor divider code difference required to trigger an online recalibration. Setting this to zero causes the radio to continuously recalibrate all blocks every time the 8051 wakes from PCON sleep.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_CAL_MAN_OFFLINE_TEMP_DELTA">OTP_VARS_CAL_MAN_OFFLINE_TEMP_DELTA</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x31</li>
<li>Summary: Sets limit for user interupt meaning it is time to recalibrate offline. A value of 18 equates to 57.49 degrees Celsius.</li>
<li>Purpose:</li>
<li>Defaults: 0x12</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_CAL_MAN_OFFLINE_TEMP_DELTA</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x31</td>
<td colspan="8">CAL_MAN_OFFLINE_TEMP_DELTA</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x31</td>
<td colspan="8">0x12</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_CAL_MAN_OFFLINE_TEMP_DELTA">OTP_VARS_CAL_MAN_OFFLINE_TEMP_DELTA</a><ul>
<li><a name="field-OTP_VARS_CAL_MAN_OFFLINE_TEMP_DELTA%3ACAL_MAN_OFFLINE_TEMP_DELTA">CAL_MAN_OFFLINE_TEMP_DELTA</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Temperature sensor divider code difference required to generate user interrupt</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_CAL_MAN_LOWER_TEMP_TARGET">OTP_VARS_CAL_MAN_LOWER_TEMP_TARGET</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x32</li>
<li>Summary: Sets limit for switching to use lower temperature settings. A value of 20 equates to 89.39 degrees Celsius.</li>
<li>Purpose:</li>
<li>Defaults: 0x14</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_CAL_MAN_LOWER_TEMP_TARGET</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x32</td>
<td colspan="8">CAL_MAN_LOWER_TEMP_TARGET</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x32</td>
<td colspan="8">0x14</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_CAL_MAN_LOWER_TEMP_TARGET">OTP_VARS_CAL_MAN_LOWER_TEMP_TARGET</a><ul>
<li><a name="field-OTP_VARS_CAL_MAN_LOWER_TEMP_TARGET%3ACAL_MAN_LOWER_TEMP_TARGET">CAL_MAN_LOWER_TEMP_TARGET</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Temperature sensor divider code to switch into using lower temperature range settings</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_CAL_MAN_HIGHER_TEMP_TARGET">OTP_VARS_CAL_MAN_HIGHER_TEMP_TARGET</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x33</li>
<li>Summary: Sets limit for switching to use higher temperature settings. A value of 22 equates to 95.78 degrees Celsius.</li>
<li>Purpose:</li>
<li>Defaults: 0x16</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_CAL_MAN_HIGHER_TEMP_TARGET</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x33</td>
<td colspan="8">CAL_MAN_HIGHER_TEMP_TARGET</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x33</td>
<td colspan="8">0x16</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_CAL_MAN_HIGHER_TEMP_TARGET">OTP_VARS_CAL_MAN_HIGHER_TEMP_TARGET</a><ul>
<li><a name="field-OTP_VARS_CAL_MAN_HIGHER_TEMP_TARGET%3ACAL_MAN_HIGHER_TEMP_TARGET">CAL_MAN_HIGHER_TEMP_TARGET</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Temperature sensor divider code to switch into using higher temperature range settings</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>S8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x-80</dd></dl>
<dl><dt>Max:</dt><dd>0x7f</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_NVM_TIMING">OTP_VARS_NVM_TIMING</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x34</li>
<li>Summary: Configure the timing used when copying out of nvm.</li>
<li>Purpose:</li>
<ul><li>
Configure the timing used when compying out of nvm.</li></ul>
<li>Defaults: 0x0b</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_NVM_TIMING</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x34</td>
<td>0</td>
<td>0</td>
<td colspan="6">MCU_CLK_PER_100NS</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x34</td>
<td>0x0</td>
<td>0x0</td>
<td colspan="6">0xb</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_NVM_TIMING">OTP_VARS_NVM_TIMING</a><ul>
<li><a name="field-OTP_VARS_NVM_TIMING%3AMCU_CLK_PER_100NS">MCU_CLK_PER_100NS</a>
<dl><dt>Description:</dt><dd>
<ul><li>
Define the number of mcu clock cycles that constitutes a 100ns cycle during the nvm read process.</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0x40</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_SPARE_35">OTP_VARS_SPARE_35</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x35</li>
<li>Summary: For use in patches.</li>
<li>Purpose:</li>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_SPARE_35</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x35</td>
<td colspan="8">SPARE1</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x35</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_SPARE_35">OTP_VARS_SPARE_35</a><ul>
<li><a name="field-OTP_VARS_SPARE_35%3ASPARE1">SPARE1</a>
<dl><dt>Description:</dt><dd>
<ul><li>
spare1</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
<h4><a name="prop-OTP_VARS_SPARE_36">OTP_VARS_SPARE_36</a></h4>
<ul>
<li>Group: 0xf2</li>
<li>Index: 0x36</li>
<li>Summary: For use in patches.</li>
<li>Purpose:</li>
<li>Defaults: 0x00</li>
<li>Register View:
<br />
<table>
<thead><tr><td></td><th colspan="8">OTP_VARS_SPARE_36</th></tr>
<tr><td>Index</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr>
</thead><tbody>
<tr><td>0x36</td>
<td colspan="8">SPARE1</td>
</tr>
</tbody>
<thead><tr><td></td><th colspan="8">Defaults</th></tr>
</thead><tbody>
<tr><td>0x36</td>
<td colspan="8">0x0</td>
</tr>
</tbody>
</table><br />
</li>
<li>Field Details:
<ul>
<li><a name="prop-OTP_VARS%3AOTP_VARS_SPARE_36">OTP_VARS_SPARE_36</a><ul>
<li><a name="field-OTP_VARS_SPARE_36%3ASPARE1">SPARE1</a>
<dl><dt>Description:</dt><dd>
<ul><li>
spare1</li></ul>
</dd></dl>
<dl><dt>Type:</dt>
<dd>U8</dd>
</dl>
<dl><dt>Min:</dt><dd>0x0</dd></dl>
<dl><dt>Max:</dt><dd>0xff</dd></dl>
</li>
</ul></li>
</ul>
</li>
</ul>
<hr />
</body>
</html>
